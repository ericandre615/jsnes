{"version":3,"sources":["webpack:///jsnes.min.js","webpack:///webpack/bootstrap 52b5458688cdbb005394","webpack:///./index.js","webpack:///./source/nes.js","webpack:///./source/cpu.js","webpack:///./source/utils.js","webpack:///./source/ppu.js","webpack:///./source/papu.js","webpack:///./source/rom.js","webpack:///./source/mappers.js","webpack:///./source/keyboard.js"],"names":["JSNES","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","create","undefined","_nes","_nes2","opts","_cpu","_cpu2","_ppu","_ppu2","_papu","_papu2","_rom","_rom2","_keyboard","_keyboard2","DummyUI","nes","this","enable","updateStatus","writeAudio","writeFrame","ui","swfPath","preferredFrameRate","fpsInterval","showDisplay","emulateSound","sampleRate","CPU_FREQ_NTSC","CPU_FREQ_PAL","key","frameTime","cpu","ppu","papu","mmap","keyboard","VERSION","prototype","isRunning","fpsFrameCount","romData","reset","start","self","rom","valid","frameInterval","setInterval","frame","resetFps","printFps","startFrame","cycles","FRAMELOOP","cyclesToHalt","emulate","clockFrameCounter","curX","spr0HitX","f_spVisibility","scanline","spr0HitY","setStatusFlag","STATUS_SPRITE0HIT","requestEndFrame","nmiCounter","startVBlank","endScanline","now","Date","s","lastFpsTime","toFixed","stop","clearInterval","reloadRom","loadRom","data","load","createMapper","loadROM","setMirroring","getMirroringType","setFramerate","rate","setSampleRate","toJSON","fromJSON","_utils","_utils2","CPU","mem","REG_ACC","REG_X","REG_Y","REG_SP","REG_PC","REG_PC_NEW","REG_STATUS","F_CARRY","F_DECIMAL","F_INTERRUPT","F_INTERRUPT_NEW","F_OVERFLOW","F_SIGN","F_ZERO","F_NOTUSED","F_NOTUSED_NEW","F_BRK","F_BRK_NEW","opdata","crash","irqRequested","irqType","IRQ_NORMAL","IRQ_NMI","IRQ_RESET","Array","i","length","setStatus","OpData","temp","add","doIrq","doNonMaskableInterrupt","doResetInterrupt","opinf","cycleCount","cycleAdd","addrMode","opaddr","addr","load16bit","write","push","pull","stackWrap","crashMessage","toString","val","requestIrq","type","pageCrossed","addr1","addr2","haltCycles","status","getStatus","st","JSON_PROPERTIES","setOp","INS_ADC","ADDR_IMM","ADDR_ZP","ADDR_ZPX","ADDR_ABS","ADDR_ABSX","ADDR_ABSY","ADDR_PREIDXIND","ADDR_POSTIDXIND","INS_AND","INS_ASL","ADDR_ACC","INS_BCC","ADDR_REL","INS_BCS","INS_BEQ","INS_BIT","INS_BMI","INS_BNE","INS_BPL","INS_BRK","ADDR_IMP","INS_BVC","INS_BVS","INS_CLC","INS_CLD","INS_CLI","INS_CLV","INS_CMP","INS_CPX","INS_CPY","INS_DEC","INS_DEX","INS_DEY","INS_EOR","INS_INC","INS_INX","INS_INY","INS_JMP","ADDR_INDABS","INS_JSR","INS_LDA","INS_LDX","ADDR_ZPY","INS_LDY","INS_LSR","INS_NOP","INS_ORA","INS_PHA","INS_PHP","INS_PLA","INS_PLP","INS_ROL","INS_ROR","INS_RTI","INS_RTS","INS_SBC","INS_SEC","INS_SED","INS_SEI","INS_STA","INS_STX","INS_STY","INS_TAX","INS_TAY","INS_TSX","INS_TXA","INS_TXS","INS_TYA","cycTable","instname","addrDesc","INS_DUMMY","inst","op","size","utils","copyArrayElements","src","srcPos","dest","destPos","copyArray","state","isIE","test","navigator","userAgent","PPU","vramMem","spriteMem","vramAddress","vramTmpAddress","vramBufferedReadValue","firstWrite","sramAddress","currentMirroring","nmiOk","dummyCycleToggle","validTileData","scanlineAlreadyRendered","f_nmiOnVblank","f_spriteSize","f_bgPatternTable","f_spPatternTable","f_addrInc","f_nTblAddress","f_color","f_bgVisibility","f_spClipping","f_bgClipping","f_dispType","cntFV","cntV","cntH","cntVT","cntHT","regFV","regV","regH","regVT","regHT","regFH","regS","curNt","attrib","buffer","prevBuffer","bgbuffer","pixrendered","scantile","lastRenderedScanline","sprX","sprY","sprTile","sprCol","vertFlip","horiFlip","bgPriority","hitSpr0","sprPalette","imgPalette","ptTile","ntable1","nameTable","vramMirrorTable","palTable","showSpr0Hit","clipToTvSize","STATUS_VRAMWRITE","STATUS_SLSPRITECOUNT","STATUS_VBLANK","Tile","NameTable","PaletteTable","loadNTSCPalette","updateControlReg1","updateControlReg2","mirroring","triggerRendering","defineMirrorRegion","HORIZONTAL_MIRRORING","VERTICAL_MIRRORING","SINGLESCREEN_MIRRORING","SINGLESCREEN_MIRRORING2","fromStart","toStart","renderFramePartially","endFrame","renderBgScanline","checkSprite0","clockIrqCounter","regsToAddress","cntsToAddress","bgColor","x","y","setEmphasis","updatePalettes","flag","n","readStatusRegister","tmp","writeSRAMAddress","address","sramLoad","sramWrite","spriteRamWriteUpdate","scrollWrite","writeVRAMAddress","latchAccess","vramLoad","mirroredLoad","cntsFromAddress","regsFromAddress","vramWrite","mirroredWrite","writeMem","sramDMA","baseAddress","b1","b2","incTileCounter","count","alert","startScan","scanCount","renderSpritesPartially","si","ei","destIndex","scan","baseTile","t","tpix","att","col","tscanoffset","targetBuffer","tile","pix","getTileIndex","getAttrib","sx","opaque","startscan","scancount","bgPri","srcy1","srcy2","render","top","toffset","bufferIndex","tIndexAdd","patternWrite","nameTableWrite","attribTableWrite","getEntry","tileIndex","Math","floor","leftOver","setScanline","index","writeAttrib","tIndex","doNMI","width","height","name","tx","ty","attindex","basex","basey","sqy","sqx","curTable","emphTable","currentEmph","makeTables","loadPALPalette","r","g","b","rFactor","gFactor","bFactor","emph","getRed","getGreen","getBlue","getRgb","yiq","rgb","loadDefaultPalette","fbIndex","w","h","incX","incY","palIndex","tpri","initialized","setBuffer","sline","srcx1","srcx2","dx","dy","palAdd","palette","flipHorizontal","flipVertical","pri","priTable","isTransparent","PAPU","square1","ChannelSquare","square2","triangle","ChannelTriangle","noise","ChannelNoise","dmc","ChannelDM","frameIrqCounter","frameIrqCounterMax","initCounter","channelEnableValue","bufferSize","lengthLookup","dmcFreqLookup","noiseWavelengthLookup","square_table","tnd_table","sampleBuffer","frameIrqEnabled","frameIrqActive","frameClockNow","startedPlaying","recordOutput","initingHardware","masterFrameCounter","derivedFrameCounter","countSequence","sampleTimer","sampleTimerMax","sampleCount","triValue","smpSquare1","smpSquare2","smpTriangle","smpDmc","accCount","prevSampleL","prevSampleR","smpAccumL","smpAccumR","dacRange","dcValue","masterVolume","stereoPosLSquare1","stereoPosLSquare2","stereoPosLTriangle","stereoPosLNoise","stereoPosLDMC","stereoPosRSquare1","stereoPosRSquare2","stereoPosRTriangle","stereoPosRNoise","stereoPosRDMC","extraCycles","maxSample","minSample","panning","setPanning","initLengthLookup","initDmcFrequencyLookup","initNoiseWavelengthLookup","initDACtables","writeReg","updateChannelEnable","resetCounter","readReg","getLengthStatus","getIrqStatus","irqGenerated","frameCounterTick","setEnabled","nCycles","maxCycles","isEnabled","shiftCounter","dmaFrequency","clockDmc","progTimerMax","progTimerCount","linearCounter","lengthCounter","triangleCounter","sampleValue","squareCounter","updateSampleValue","acc_c","accValue","shiftReg","randomMode","randomBit","accSample","sample","sampleCondition","clockLengthCounter","clockSweep","clockEnvDecay","clockLinearCounter","sq_index","tnd_index","smpNoise","sampleValueL","sampleValueR","smpDiffL","smpDiffR","getLengthMax","getDmcFrequency","getNoiseWaveLength","pos","updateStereoPos","setMasterVolume","ival","max_sqr","max_tnd","MODE_NORMAL","MODE_LOOP","MODE_IRQ","hasSample","playMode","dmaCounter","deltaCounter","playStartAddress","playAddress","playLength","playLengthCounter","reg4012","reg4013","dacLsb","endOfSample","nextSample","envDecayDisable","envDecayLoopEnable","lengthCounterEnable","envReset","shiftNow","envDecayRate","envDecayCounter","envVolume","dutyLookup","impLookup","sqr1","sweepActive","sweepCarry","updateSweepPeriod","sweepCounter","sweepCounterMax","sweepMode","sweepShiftAmount","dutyMode","sweepResult","vol","addrAdd","lcHalt","lcControl","lcLoadValue","updateSampleCondition","clockProgrammableTimer","clockTriangleGenerator","_mappers","_mappers2","ROM","mapperName","FOURSCREEN_MIRRORING","SINGLESCREEN_MIRRORING3","SINGLESCREEN_MIRRORING4","CHRROM_MIRRORING","header","vrom","vromTile","romCount","vromCount","batteryRam","trainer","fourScreen","mapperType","j","v","indexOf","charCodeAt","foundError","offset","getMapperName","mapperSupported","Mappers","joy1StrobeState","joy2StrobeState","joypadLastWrite","mousePressed","mouseX","mouseY","regWrite","writelow","regLoad","joy1Read","max","ex","min","sy","ey","console","debug","joy2Read","ret","state1","state2","loadPRGROM","loadCHRROM","loadBatteryRam","loadRomBank","loadVromBank","ram","bank","load32kRomBank","load8kVromBank","bank4kStart","load1kVromBank","bank1k","bank4k","bankoffset","baseIndex","load2kVromBank","bank2k","load8kRomBank","bank8k","bank16k","apply","regBuffer","regBufferCounter","oneScreenMirroring","prgSwitchingArea","prgSwitchingSize","vromSwitchingSize","romSelectionReg0","romSelectionReg1","romBankSelect","arguments","getRegNumber","setReg","reg","baseBank","switchLowHighPrgRom","oldSetting","switch16to32","switch32to16","CMD_SEL_2_1K_VROM_0000","CMD_SEL_2_1K_VROM_0800","CMD_SEL_1K_VROM_1000","CMD_SEL_1K_VROM_1400","CMD_SEL_1K_VROM_1800","CMD_SEL_1K_VROM_1C00","CMD_SEL_ROM_PAGE1","CMD_SEL_ROM_PAGE2","command","prgAddressSelect","chrAddressSelect","pageNumber","irqCounter","irqLatchValue","irqEnable","prgAddressChanged","executeCommand","cmd","arg","Keyboard","keys","KEY_A","KEY_B","KEY_SELECT","KEY_START","KEY_UP","KEY_DOWN","KEY_LEFT","KEY_RIGHT","setKey","keyDown","evt","keyCode","preventDefault","keyUp","keyPress"],"mappings":"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AAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,E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","file":"jsnes.min.js","sourcesContent":["var JSNES =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.create = undefined;\n\t\n\tvar _nes = __webpack_require__(2);\n\t\n\tvar _nes2 = _interopRequireDefault(_nes);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar create = exports.create = function create(opts) {\n\t  return new _nes2.default(opts);\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _cpu = __webpack_require__(3);\n\t\n\tvar _cpu2 = _interopRequireDefault(_cpu);\n\t\n\tvar _ppu = __webpack_require__(5);\n\t\n\tvar _ppu2 = _interopRequireDefault(_ppu);\n\t\n\tvar _papu = __webpack_require__(6);\n\t\n\tvar _papu2 = _interopRequireDefault(_papu);\n\t\n\tvar _rom = __webpack_require__(7);\n\t\n\tvar _rom2 = _interopRequireDefault(_rom);\n\t\n\tvar _keyboard = __webpack_require__(9);\n\t\n\tvar _keyboard2 = _interopRequireDefault(_keyboard);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar DummyUI = function DummyUI(nes) {\n\t    this.nes = nes;\n\t    this.enable = function () {};\n\t    this.updateStatus = function () {};\n\t    this.writeAudio = function () {};\n\t    this.writeFrame = function () {};\n\t};\n\t\n\tvar JSNES = function JSNES(opts) {\n\t    this.opts = {\n\t        ui: DummyUI,\n\t        swfPath: 'lib/',\n\t\n\t        preferredFrameRate: 60,\n\t        fpsInterval: 500, // Time between updating FPS in ms\n\t        showDisplay: true,\n\t\n\t        emulateSound: false,\n\t        sampleRate: 44100, // Sound sample rate in hz\n\t\n\t        CPU_FREQ_NTSC: 1789772.5, //1789772.72727272d;\n\t        CPU_FREQ_PAL: 1773447.4\n\t    };\n\t    if (typeof opts != 'undefined') {\n\t        var key;\n\t        for (key in this.opts) {\n\t            if (typeof opts[key] != 'undefined') {\n\t                this.opts[key] = opts[key];\n\t            }\n\t        }\n\t    }\n\t\n\t    this.frameTime = 1000 / this.opts.preferredFrameRate;\n\t\n\t    this.ui = new this.opts.ui(this);\n\t    this.cpu = new _cpu2.default(this);\n\t    this.ppu = new _ppu2.default(this);\n\t    this.papu = new _papu2.default(this);\n\t    this.mmap = null; // set in loadRom()\n\t    this.keyboard = new _keyboard2.default();\n\t\n\t    this.ui.updateStatus(\"Ready to load a ROM.\");\n\t\n\t    return this;\n\t};\n\t\n\tJSNES.VERSION = \"<%= version %>\";\n\t\n\tJSNES.prototype = {\n\t    isRunning: false,\n\t    fpsFrameCount: 0,\n\t    romData: null,\n\t\n\t    // Resets the system\n\t    reset: function reset() {\n\t        if (this.mmap !== null) {\n\t            this.mmap.reset();\n\t        }\n\t\n\t        this.cpu.reset();\n\t        this.ppu.reset();\n\t        this.papu.reset();\n\t    },\n\t\n\t    start: function start() {\n\t        var self = this;\n\t\n\t        if (this.rom !== null && this.rom.valid) {\n\t            if (!this.isRunning) {\n\t                this.isRunning = true;\n\t\n\t                this.frameInterval = setInterval(function () {\n\t                    self.frame();\n\t                }, this.frameTime);\n\t                this.resetFps();\n\t                this.printFps();\n\t                this.fpsInterval = setInterval(function () {\n\t                    self.printFps();\n\t                }, this.opts.fpsInterval);\n\t            }\n\t        } else {\n\t            this.ui.updateStatus(\"There is no ROM loaded, or it is invalid.\");\n\t        }\n\t    },\n\t\n\t    frame: function frame() {\n\t        this.ppu.startFrame();\n\t        var cycles = 0;\n\t        var emulateSound = this.opts.emulateSound;\n\t        var cpu = this.cpu;\n\t        var ppu = this.ppu;\n\t        var papu = this.papu;\n\t        FRAMELOOP: for (;;) {\n\t            if (cpu.cyclesToHalt === 0) {\n\t                // Execute a CPU instruction\n\t                cycles = cpu.emulate();\n\t                if (emulateSound) {\n\t                    papu.clockFrameCounter(cycles);\n\t                }\n\t                cycles *= 3;\n\t            } else {\n\t                if (cpu.cyclesToHalt > 8) {\n\t                    cycles = 24;\n\t                    if (emulateSound) {\n\t                        papu.clockFrameCounter(8);\n\t                    }\n\t                    cpu.cyclesToHalt -= 8;\n\t                } else {\n\t                    cycles = cpu.cyclesToHalt * 3;\n\t                    if (emulateSound) {\n\t                        papu.clockFrameCounter(cpu.cyclesToHalt);\n\t                    }\n\t                    cpu.cyclesToHalt = 0;\n\t                }\n\t            }\n\t\n\t            for (; cycles > 0; cycles--) {\n\t                if (ppu.curX === ppu.spr0HitX && ppu.f_spVisibility === 1 && ppu.scanline - 21 === ppu.spr0HitY) {\n\t                    // Set sprite 0 hit flag:\n\t                    ppu.setStatusFlag(ppu.STATUS_SPRITE0HIT, true);\n\t                }\n\t\n\t                if (ppu.requestEndFrame) {\n\t                    ppu.nmiCounter--;\n\t                    if (ppu.nmiCounter === 0) {\n\t                        ppu.requestEndFrame = false;\n\t                        ppu.startVBlank();\n\t                        break FRAMELOOP;\n\t                    }\n\t                }\n\t\n\t                ppu.curX++;\n\t                if (ppu.curX === 341) {\n\t                    ppu.curX = 0;\n\t                    ppu.endScanline();\n\t                }\n\t            }\n\t        }\n\t        this.fpsFrameCount++;\n\t    },\n\t\n\t    printFps: function printFps() {\n\t        var now = +new Date();\n\t        var s = 'Running';\n\t        if (this.lastFpsTime) {\n\t            s += ': ' + (this.fpsFrameCount / ((now - this.lastFpsTime) / 1000)).toFixed(2) + ' FPS';\n\t        }\n\t        this.ui.updateStatus(s);\n\t        this.fpsFrameCount = 0;\n\t        this.lastFpsTime = now;\n\t    },\n\t\n\t    stop: function stop() {\n\t        clearInterval(this.frameInterval);\n\t        clearInterval(this.fpsInterval);\n\t        this.isRunning = false;\n\t    },\n\t\n\t    reloadRom: function reloadRom() {\n\t        if (this.romData !== null) {\n\t            this.loadRom(this.romData);\n\t        }\n\t    },\n\t\n\t    // Loads a ROM file into the CPU and PPU.\n\t    // The ROM file is validated first.\n\t    loadRom: function loadRom(data) {\n\t        if (this.isRunning) {\n\t            this.stop();\n\t        }\n\t\n\t        this.ui.updateStatus(\"Loading ROM...\");\n\t\n\t        // Load ROM file:\n\t        this.rom = new _rom2.default(this);\n\t        this.rom.load(data);\n\t\n\t        if (this.rom.valid) {\n\t            this.reset();\n\t            this.mmap = this.rom.createMapper();\n\t            if (!this.mmap) {\n\t                return;\n\t            }\n\t            this.mmap.loadROM();\n\t            this.ppu.setMirroring(this.rom.getMirroringType());\n\t            this.romData = data;\n\t\n\t            this.ui.updateStatus(\"Successfully loaded. Ready to be started.\");\n\t        } else {\n\t            this.ui.updateStatus(\"Invalid ROM!\");\n\t        }\n\t        return this.rom.valid;\n\t    },\n\t\n\t    resetFps: function resetFps() {\n\t        this.lastFpsTime = null;\n\t        this.fpsFrameCount = 0;\n\t    },\n\t\n\t    setFramerate: function setFramerate(rate) {\n\t        this.opts.preferredFrameRate = rate;\n\t        this.frameTime = 1000 / rate;\n\t        this.papu.setSampleRate(this.opts.sampleRate, false);\n\t    },\n\t\n\t    toJSON: function toJSON() {\n\t        return {\n\t            'romData': this.romData,\n\t            'cpu': this.cpu.toJSON(),\n\t            'mmap': this.mmap.toJSON(),\n\t            'ppu': this.ppu.toJSON()\n\t        };\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        this.loadRom(s.romData);\n\t        this.cpu.fromJSON(s.cpu);\n\t        this.mmap.fromJSON(s.mmap);\n\t        this.ppu.fromJSON(s.ppu);\n\t    }\n\t};\n\t\n\texports.default = JSNES;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar CPU = function CPU(nes) {\n\t    this.nes = nes;\n\t\n\t    // Keep Chrome happy\n\t    this.mem = null;\n\t    this.REG_ACC = null;\n\t    this.REG_X = null;\n\t    this.REG_Y = null;\n\t    this.REG_SP = null;\n\t    this.REG_PC = null;\n\t    this.REG_PC_NEW = null;\n\t    this.REG_STATUS = null;\n\t    this.F_CARRY = null;\n\t    this.F_DECIMAL = null;\n\t    this.F_INTERRUPT = null;\n\t    this.F_INTERRUPT_NEW = null;\n\t    this.F_OVERFLOW = null;\n\t    this.F_SIGN = null;\n\t    this.F_ZERO = null;\n\t    this.F_NOTUSED = null;\n\t    this.F_NOTUSED_NEW = null;\n\t    this.F_BRK = null;\n\t    this.F_BRK_NEW = null;\n\t    this.opdata = null;\n\t    this.cyclesToHalt = null;\n\t    this.crash = null;\n\t    this.irqRequested = null;\n\t    this.irqType = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tCPU.prototype = {\n\t    // IRQ Types\n\t    IRQ_NORMAL: 0,\n\t    IRQ_NMI: 1,\n\t    IRQ_RESET: 2,\n\t\n\t    reset: function reset() {\n\t        // Main memory\n\t        this.mem = new Array(0x10000);\n\t\n\t        for (var i = 0; i < 0x2000; i++) {\n\t            this.mem[i] = 0xFF;\n\t        }\n\t        for (var p = 0; p < 4; p++) {\n\t            var i = p * 0x800;\n\t            this.mem[i + 0x008] = 0xF7;\n\t            this.mem[i + 0x009] = 0xEF;\n\t            this.mem[i + 0x00A] = 0xDF;\n\t            this.mem[i + 0x00F] = 0xBF;\n\t        }\n\t        for (var i = 0x2001; i < this.mem.length; i++) {\n\t            this.mem[i] = 0;\n\t        }\n\t\n\t        // CPU Registers:\n\t        this.REG_ACC = 0;\n\t        this.REG_X = 0;\n\t        this.REG_Y = 0;\n\t        // Reset Stack pointer:\n\t        this.REG_SP = 0x01FF;\n\t        // Reset Program counter:\n\t        this.REG_PC = 0x8000 - 1;\n\t        this.REG_PC_NEW = 0x8000 - 1;\n\t        // Reset Status register:\n\t        this.REG_STATUS = 0x28;\n\t\n\t        this.setStatus(0x28);\n\t\n\t        // Set flags:\n\t        this.F_CARRY = 0;\n\t        this.F_DECIMAL = 0;\n\t        this.F_INTERRUPT = 1;\n\t        this.F_INTERRUPT_NEW = 1;\n\t        this.F_OVERFLOW = 0;\n\t        this.F_SIGN = 0;\n\t        this.F_ZERO = 1;\n\t\n\t        this.F_NOTUSED = 1;\n\t        this.F_NOTUSED_NEW = 1;\n\t        this.F_BRK = 1;\n\t        this.F_BRK_NEW = 1;\n\t\n\t        this.opdata = new CPU.OpData().opdata;\n\t        this.cyclesToHalt = 0;\n\t\n\t        // Reset crash flag:\n\t        this.crash = false;\n\t\n\t        // Interrupt notification:\n\t        this.irqRequested = false;\n\t        this.irqType = null;\n\t    },\n\t\n\t    // Emulates a single CPU instruction, returns the number of cycles\n\t    emulate: function emulate() {\n\t        var temp;\n\t        var add;\n\t\n\t        // Check interrupts:\n\t        if (this.irqRequested) {\n\t            temp = this.F_CARRY | (this.F_ZERO === 0 ? 1 : 0) << 1 | this.F_INTERRUPT << 2 | this.F_DECIMAL << 3 | this.F_BRK << 4 | this.F_NOTUSED << 5 | this.F_OVERFLOW << 6 | this.F_SIGN << 7;\n\t\n\t            this.REG_PC_NEW = this.REG_PC;\n\t            this.F_INTERRUPT_NEW = this.F_INTERRUPT;\n\t            switch (this.irqType) {\n\t                case 0:\n\t                    {\n\t                        // Normal IRQ:\n\t                        if (this.F_INTERRUPT != 0) {\n\t                            ////System.out.println(\"Interrupt was masked.\");\n\t                            break;\n\t                        }\n\t                        this.doIrq(temp);\n\t                        ////System.out.println(\"Did normal IRQ. I=\"+this.F_INTERRUPT);\n\t                        break;\n\t                    }case 1:\n\t                    {\n\t                        // NMI:\n\t                        this.doNonMaskableInterrupt(temp);\n\t                        break;\n\t                    }case 2:\n\t                    {\n\t                        // Reset:\n\t                        this.doResetInterrupt();\n\t                        break;\n\t                    }\n\t            }\n\t\n\t            this.REG_PC = this.REG_PC_NEW;\n\t            this.F_INTERRUPT = this.F_INTERRUPT_NEW;\n\t            this.F_BRK = this.F_BRK_NEW;\n\t            this.irqRequested = false;\n\t        }\n\t\n\t        var opinf = this.opdata[this.nes.mmap.load(this.REG_PC + 1)];\n\t        var cycleCount = opinf >> 24;\n\t        var cycleAdd = 0;\n\t\n\t        // Find address mode:\n\t        var addrMode = opinf >> 8 & 0xFF;\n\t\n\t        // Increment PC by number of op bytes:\n\t        var opaddr = this.REG_PC;\n\t        this.REG_PC += opinf >> 16 & 0xFF;\n\t\n\t        var addr = 0;\n\t        switch (addrMode) {\n\t            case 0:\n\t                {\n\t                    // Zero Page mode. Use the address given after the opcode,\n\t                    // but without high byte.\n\t                    addr = this.load(opaddr + 2);\n\t                    break;\n\t                }case 1:\n\t                {\n\t                    // Relative mode.\n\t                    addr = this.load(opaddr + 2);\n\t                    if (addr < 0x80) {\n\t                        addr += this.REG_PC;\n\t                    } else {\n\t                        addr += this.REG_PC - 256;\n\t                    }\n\t                    break;\n\t                }case 2:\n\t                {\n\t                    // Ignore. Address is implied in instruction.\n\t                    break;\n\t                }case 3:\n\t                {\n\t                    // Absolute mode. Use the two bytes following the opcode as\n\t                    // an address.\n\t                    addr = this.load16bit(opaddr + 2);\n\t                    break;\n\t                }case 4:\n\t                {\n\t                    // Accumulator mode. The address is in the accumulator\n\t                    // register.\n\t                    addr = this.REG_ACC;\n\t                    break;\n\t                }case 5:\n\t                {\n\t                    // Immediate mode. The value is given after the opcode.\n\t                    addr = this.REG_PC;\n\t                    break;\n\t                }case 6:\n\t                {\n\t                    // Zero Page Indexed mode, X as index. Use the address given\n\t                    // after the opcode, then add the\n\t                    // X register to it to get the final address.\n\t                    addr = this.load(opaddr + 2) + this.REG_X & 0xFF;\n\t                    break;\n\t                }case 7:\n\t                {\n\t                    // Zero Page Indexed mode, Y as index. Use the address given\n\t                    // after the opcode, then add the\n\t                    // Y register to it to get the final address.\n\t                    addr = this.load(opaddr + 2) + this.REG_Y & 0xFF;\n\t                    break;\n\t                }case 8:\n\t                {\n\t                    // Absolute Indexed Mode, X as index. Same as zero page\n\t                    // indexed, but with the high byte.\n\t                    addr = this.load16bit(opaddr + 2);\n\t                    if ((addr & 0xFF00) != (addr + this.REG_X & 0xFF00)) {\n\t                        cycleAdd = 1;\n\t                    }\n\t                    addr += this.REG_X;\n\t                    break;\n\t                }case 9:\n\t                {\n\t                    // Absolute Indexed Mode, Y as index. Same as zero page\n\t                    // indexed, but with the high byte.\n\t                    addr = this.load16bit(opaddr + 2);\n\t                    if ((addr & 0xFF00) != (addr + this.REG_Y & 0xFF00)) {\n\t                        cycleAdd = 1;\n\t                    }\n\t                    addr += this.REG_Y;\n\t                    break;\n\t                }case 10:\n\t                {\n\t                    // Pre-indexed Indirect mode. Find the 16-bit address\n\t                    // starting at the given location plus\n\t                    // the current X register. The value is the contents of that\n\t                    // address.\n\t                    addr = this.load(opaddr + 2);\n\t                    if ((addr & 0xFF00) != (addr + this.REG_X & 0xFF00)) {\n\t                        cycleAdd = 1;\n\t                    }\n\t                    addr += this.REG_X;\n\t                    addr &= 0xFF;\n\t                    addr = this.load16bit(addr);\n\t                    break;\n\t                }case 11:\n\t                {\n\t                    // Post-indexed Indirect mode. Find the 16-bit address\n\t                    // contained in the given location\n\t                    // (and the one following). Add to that address the contents\n\t                    // of the Y register. Fetch the value\n\t                    // stored at that adress.\n\t                    addr = this.load16bit(this.load(opaddr + 2));\n\t                    if ((addr & 0xFF00) != (addr + this.REG_Y & 0xFF00)) {\n\t                        cycleAdd = 1;\n\t                    }\n\t                    addr += this.REG_Y;\n\t                    break;\n\t                }case 12:\n\t                {\n\t                    // Indirect Absolute mode. Find the 16-bit address contained\n\t                    // at the given location.\n\t                    addr = this.load16bit(opaddr + 2); // Find op\n\t                    if (addr < 0x1FFF) {\n\t                        addr = this.mem[addr] + (this.mem[addr & 0xFF00 | (addr & 0xFF) + 1 & 0xFF] << 8); // Read from address given in op\n\t                    } else {\n\t                            addr = this.nes.mmap.load(addr) + (this.nes.mmap.load(addr & 0xFF00 | (addr & 0xFF) + 1 & 0xFF) << 8);\n\t                        }\n\t                    break;\n\t                }\n\t\n\t        }\n\t        // Wrap around for addresses above 0xFFFF:\n\t        addr &= 0xFFFF;\n\t\n\t        // ----------------------------------------------------------------------------------------------------\n\t        // Decode & execute instruction:\n\t        // ----------------------------------------------------------------------------------------------------\n\t\n\t        // This should be compiled to a jump table.\n\t        switch (opinf & 0xFF) {\n\t            case 0:\n\t                {\n\t                    // *******\n\t                    // * ADC *\n\t                    // *******\n\t\n\t                    // Add with carry.\n\t                    temp = this.REG_ACC + this.load(addr) + this.F_CARRY;\n\t                    this.F_OVERFLOW = !(((this.REG_ACC ^ this.load(addr)) & 0x80) != 0) && ((this.REG_ACC ^ temp) & 0x80) != 0 ? 1 : 0;\n\t                    this.F_CARRY = temp > 255 ? 1 : 0;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    this.REG_ACC = temp & 255;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 1:\n\t                {\n\t                    // *******\n\t                    // * AND *\n\t                    // *******\n\t\n\t                    // AND memory with accumulator.\n\t                    this.REG_ACC = this.REG_ACC & this.load(addr);\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    //this.REG_ACC = temp;\n\t                    if (addrMode != 11) cycleCount += cycleAdd; // PostIdxInd = 11\n\t                    break;\n\t                }case 2:\n\t                {\n\t                    // *******\n\t                    // * ASL *\n\t                    // *******\n\t\n\t                    // Shift left one bit\n\t                    if (addrMode == 4) {\n\t                        // ADDR_ACC = 4\n\t\n\t                        this.F_CARRY = this.REG_ACC >> 7 & 1;\n\t                        this.REG_ACC = this.REG_ACC << 1 & 255;\n\t                        this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                        this.F_ZERO = this.REG_ACC;\n\t                    } else {\n\t\n\t                        temp = this.load(addr);\n\t                        this.F_CARRY = temp >> 7 & 1;\n\t                        temp = temp << 1 & 255;\n\t                        this.F_SIGN = temp >> 7 & 1;\n\t                        this.F_ZERO = temp;\n\t                        this.write(addr, temp);\n\t                    }\n\t                    break;\n\t                }case 3:\n\t                {\n\t\n\t                    // *******\n\t                    // * BCC *\n\t                    // *******\n\t\n\t                    // Branch on carry clear\n\t                    if (this.F_CARRY == 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 4:\n\t                {\n\t\n\t                    // *******\n\t                    // * BCS *\n\t                    // *******\n\t\n\t                    // Branch on carry set\n\t                    if (this.F_CARRY == 1) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 5:\n\t                {\n\t\n\t                    // *******\n\t                    // * BEQ *\n\t                    // *******\n\t\n\t                    // Branch on zero\n\t                    if (this.F_ZERO == 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 6:\n\t                {\n\t\n\t                    // *******\n\t                    // * BIT *\n\t                    // *******\n\t\n\t                    temp = this.load(addr);\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_OVERFLOW = temp >> 6 & 1;\n\t                    temp &= this.REG_ACC;\n\t                    this.F_ZERO = temp;\n\t                    break;\n\t                }case 7:\n\t                {\n\t\n\t                    // *******\n\t                    // * BMI *\n\t                    // *******\n\t\n\t                    // Branch on negative result\n\t                    if (this.F_SIGN == 1) {\n\t                        cycleCount++;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 8:\n\t                {\n\t\n\t                    // *******\n\t                    // * BNE *\n\t                    // *******\n\t\n\t                    // Branch on not zero\n\t                    if (this.F_ZERO != 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 9:\n\t                {\n\t\n\t                    // *******\n\t                    // * BPL *\n\t                    // *******\n\t\n\t                    // Branch on positive result\n\t                    if (this.F_SIGN == 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 10:\n\t                {\n\t\n\t                    // *******\n\t                    // * BRK *\n\t                    // *******\n\t\n\t                    this.REG_PC += 2;\n\t                    this.push(this.REG_PC >> 8 & 255);\n\t                    this.push(this.REG_PC & 255);\n\t                    this.F_BRK = 1;\n\t\n\t                    this.push(this.F_CARRY | (this.F_ZERO == 0 ? 1 : 0) << 1 | this.F_INTERRUPT << 2 | this.F_DECIMAL << 3 | this.F_BRK << 4 | this.F_NOTUSED << 5 | this.F_OVERFLOW << 6 | this.F_SIGN << 7);\n\t\n\t                    this.F_INTERRUPT = 1;\n\t                    //this.REG_PC = load(0xFFFE) | (load(0xFFFF) << 8);\n\t                    this.REG_PC = this.load16bit(0xFFFE);\n\t                    this.REG_PC--;\n\t                    break;\n\t                }case 11:\n\t                {\n\t\n\t                    // *******\n\t                    // * BVC *\n\t                    // *******\n\t\n\t                    // Branch on overflow clear\n\t                    if (this.F_OVERFLOW == 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 12:\n\t                {\n\t\n\t                    // *******\n\t                    // * BVS *\n\t                    // *******\n\t\n\t                    // Branch on overflow set\n\t                    if (this.F_OVERFLOW == 1) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 13:\n\t                {\n\t\n\t                    // *******\n\t                    // * CLC *\n\t                    // *******\n\t\n\t                    // Clear carry flag\n\t                    this.F_CARRY = 0;\n\t                    break;\n\t                }case 14:\n\t                {\n\t\n\t                    // *******\n\t                    // * CLD *\n\t                    // *******\n\t\n\t                    // Clear decimal flag\n\t                    this.F_DECIMAL = 0;\n\t                    break;\n\t                }case 15:\n\t                {\n\t\n\t                    // *******\n\t                    // * CLI *\n\t                    // *******\n\t\n\t                    // Clear interrupt flag\n\t                    this.F_INTERRUPT = 0;\n\t                    break;\n\t                }case 16:\n\t                {\n\t\n\t                    // *******\n\t                    // * CLV *\n\t                    // *******\n\t\n\t                    // Clear overflow flag\n\t                    this.F_OVERFLOW = 0;\n\t                    break;\n\t                }case 17:\n\t                {\n\t\n\t                    // *******\n\t                    // * CMP *\n\t                    // *******\n\t\n\t                    // Compare memory and accumulator:\n\t                    temp = this.REG_ACC - this.load(addr);\n\t                    this.F_CARRY = temp >= 0 ? 1 : 0;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 18:\n\t                {\n\t\n\t                    // *******\n\t                    // * CPX *\n\t                    // *******\n\t\n\t                    // Compare memory and index X:\n\t                    temp = this.REG_X - this.load(addr);\n\t                    this.F_CARRY = temp >= 0 ? 1 : 0;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    break;\n\t                }case 19:\n\t                {\n\t\n\t                    // *******\n\t                    // * CPY *\n\t                    // *******\n\t\n\t                    // Compare memory and index Y:\n\t                    temp = this.REG_Y - this.load(addr);\n\t                    this.F_CARRY = temp >= 0 ? 1 : 0;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    break;\n\t                }case 20:\n\t                {\n\t\n\t                    // *******\n\t                    // * DEC *\n\t                    // *******\n\t\n\t                    // Decrement memory by one:\n\t                    temp = this.load(addr) - 1 & 0xFF;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    this.write(addr, temp);\n\t                    break;\n\t                }case 21:\n\t                {\n\t\n\t                    // *******\n\t                    // * DEX *\n\t                    // *******\n\t\n\t                    // Decrement index X by one:\n\t                    this.REG_X = this.REG_X - 1 & 0xFF;\n\t                    this.F_SIGN = this.REG_X >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    break;\n\t                }case 22:\n\t                {\n\t\n\t                    // *******\n\t                    // * DEY *\n\t                    // *******\n\t\n\t                    // Decrement index Y by one:\n\t                    this.REG_Y = this.REG_Y - 1 & 0xFF;\n\t                    this.F_SIGN = this.REG_Y >> 7 & 1;\n\t                    this.F_ZERO = this.REG_Y;\n\t                    break;\n\t                }case 23:\n\t                {\n\t\n\t                    // *******\n\t                    // * EOR *\n\t                    // *******\n\t\n\t                    // XOR Memory with accumulator, store in accumulator:\n\t                    this.REG_ACC = (this.load(addr) ^ this.REG_ACC) & 0xFF;\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 24:\n\t                {\n\t\n\t                    // *******\n\t                    // * INC *\n\t                    // *******\n\t\n\t                    // Increment memory by one:\n\t                    temp = this.load(addr) + 1 & 0xFF;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    this.write(addr, temp & 0xFF);\n\t                    break;\n\t                }case 25:\n\t                {\n\t\n\t                    // *******\n\t                    // * INX *\n\t                    // *******\n\t\n\t                    // Increment index X by one:\n\t                    this.REG_X = this.REG_X + 1 & 0xFF;\n\t                    this.F_SIGN = this.REG_X >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    break;\n\t                }case 26:\n\t                {\n\t\n\t                    // *******\n\t                    // * INY *\n\t                    // *******\n\t\n\t                    // Increment index Y by one:\n\t                    this.REG_Y++;\n\t                    this.REG_Y &= 0xFF;\n\t                    this.F_SIGN = this.REG_Y >> 7 & 1;\n\t                    this.F_ZERO = this.REG_Y;\n\t                    break;\n\t                }case 27:\n\t                {\n\t\n\t                    // *******\n\t                    // * JMP *\n\t                    // *******\n\t\n\t                    // Jump to new location:\n\t                    this.REG_PC = addr - 1;\n\t                    break;\n\t                }case 28:\n\t                {\n\t\n\t                    // *******\n\t                    // * JSR *\n\t                    // *******\n\t\n\t                    // Jump to new location, saving return address.\n\t                    // Push return address on stack:\n\t                    this.push(this.REG_PC >> 8 & 255);\n\t                    this.push(this.REG_PC & 255);\n\t                    this.REG_PC = addr - 1;\n\t                    break;\n\t                }case 29:\n\t                {\n\t\n\t                    // *******\n\t                    // * LDA *\n\t                    // *******\n\t\n\t                    // Load accumulator with memory:\n\t                    this.REG_ACC = this.load(addr);\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 30:\n\t                {\n\t\n\t                    // *******\n\t                    // * LDX *\n\t                    // *******\n\t\n\t                    // Load index X with memory:\n\t                    this.REG_X = this.load(addr);\n\t                    this.F_SIGN = this.REG_X >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 31:\n\t                {\n\t\n\t                    // *******\n\t                    // * LDY *\n\t                    // *******\n\t\n\t                    // Load index Y with memory:\n\t                    this.REG_Y = this.load(addr);\n\t                    this.F_SIGN = this.REG_Y >> 7 & 1;\n\t                    this.F_ZERO = this.REG_Y;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 32:\n\t                {\n\t\n\t                    // *******\n\t                    // * LSR *\n\t                    // *******\n\t\n\t                    // Shift right one bit:\n\t                    if (addrMode == 4) {\n\t                        // ADDR_ACC\n\t\n\t                        temp = this.REG_ACC & 0xFF;\n\t                        this.F_CARRY = temp & 1;\n\t                        temp >>= 1;\n\t                        this.REG_ACC = temp;\n\t                    } else {\n\t\n\t                        temp = this.load(addr) & 0xFF;\n\t                        this.F_CARRY = temp & 1;\n\t                        temp >>= 1;\n\t                        this.write(addr, temp);\n\t                    }\n\t                    this.F_SIGN = 0;\n\t                    this.F_ZERO = temp;\n\t                    break;\n\t                }case 33:\n\t                {\n\t\n\t                    // *******\n\t                    // * NOP *\n\t                    // *******\n\t\n\t                    // No OPeration.\n\t                    // Ignore.\n\t                    break;\n\t                }case 34:\n\t                {\n\t\n\t                    // *******\n\t                    // * ORA *\n\t                    // *******\n\t\n\t                    // OR memory with accumulator, store in accumulator.\n\t                    temp = (this.load(addr) | this.REG_ACC) & 255;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    this.REG_ACC = temp;\n\t                    if (addrMode != 11) cycleCount += cycleAdd; // PostIdxInd = 11\n\t                    break;\n\t                }case 35:\n\t                {\n\t\n\t                    // *******\n\t                    // * PHA *\n\t                    // *******\n\t\n\t                    // Push accumulator on stack\n\t                    this.push(this.REG_ACC);\n\t                    break;\n\t                }case 36:\n\t                {\n\t\n\t                    // *******\n\t                    // * PHP *\n\t                    // *******\n\t\n\t                    // Push processor status on stack\n\t                    this.F_BRK = 1;\n\t                    this.push(this.F_CARRY | (this.F_ZERO == 0 ? 1 : 0) << 1 | this.F_INTERRUPT << 2 | this.F_DECIMAL << 3 | this.F_BRK << 4 | this.F_NOTUSED << 5 | this.F_OVERFLOW << 6 | this.F_SIGN << 7);\n\t                    break;\n\t                }case 37:\n\t                {\n\t\n\t                    // *******\n\t                    // * PLA *\n\t                    // *******\n\t\n\t                    // Pull accumulator from stack\n\t                    this.REG_ACC = this.pull();\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    break;\n\t                }case 38:\n\t                {\n\t\n\t                    // *******\n\t                    // * PLP *\n\t                    // *******\n\t\n\t                    // Pull processor status from stack\n\t                    temp = this.pull();\n\t                    this.F_CARRY = temp & 1;\n\t                    this.F_ZERO = (temp >> 1 & 1) == 1 ? 0 : 1;\n\t                    this.F_INTERRUPT = temp >> 2 & 1;\n\t                    this.F_DECIMAL = temp >> 3 & 1;\n\t                    this.F_BRK = temp >> 4 & 1;\n\t                    this.F_NOTUSED = temp >> 5 & 1;\n\t                    this.F_OVERFLOW = temp >> 6 & 1;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t\n\t                    this.F_NOTUSED = 1;\n\t                    break;\n\t                }case 39:\n\t                {\n\t\n\t                    // *******\n\t                    // * ROL *\n\t                    // *******\n\t\n\t                    // Rotate one bit left\n\t                    if (addrMode == 4) {\n\t                        // ADDR_ACC = 4\n\t\n\t                        temp = this.REG_ACC;\n\t                        add = this.F_CARRY;\n\t                        this.F_CARRY = temp >> 7 & 1;\n\t                        temp = (temp << 1 & 0xFF) + add;\n\t                        this.REG_ACC = temp;\n\t                    } else {\n\t\n\t                        temp = this.load(addr);\n\t                        add = this.F_CARRY;\n\t                        this.F_CARRY = temp >> 7 & 1;\n\t                        temp = (temp << 1 & 0xFF) + add;\n\t                        this.write(addr, temp);\n\t                    }\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    break;\n\t                }case 40:\n\t                {\n\t\n\t                    // *******\n\t                    // * ROR *\n\t                    // *******\n\t\n\t                    // Rotate one bit right\n\t                    if (addrMode == 4) {\n\t                        // ADDR_ACC = 4\n\t\n\t                        add = this.F_CARRY << 7;\n\t                        this.F_CARRY = this.REG_ACC & 1;\n\t                        temp = (this.REG_ACC >> 1) + add;\n\t                        this.REG_ACC = temp;\n\t                    } else {\n\t\n\t                        temp = this.load(addr);\n\t                        add = this.F_CARRY << 7;\n\t                        this.F_CARRY = temp & 1;\n\t                        temp = (temp >> 1) + add;\n\t                        this.write(addr, temp);\n\t                    }\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    break;\n\t                }case 41:\n\t                {\n\t\n\t                    // *******\n\t                    // * RTI *\n\t                    // *******\n\t\n\t                    // Return from interrupt. Pull status and PC from stack.\n\t\n\t                    temp = this.pull();\n\t                    this.F_CARRY = temp & 1;\n\t                    this.F_ZERO = (temp >> 1 & 1) == 0 ? 1 : 0;\n\t                    this.F_INTERRUPT = temp >> 2 & 1;\n\t                    this.F_DECIMAL = temp >> 3 & 1;\n\t                    this.F_BRK = temp >> 4 & 1;\n\t                    this.F_NOTUSED = temp >> 5 & 1;\n\t                    this.F_OVERFLOW = temp >> 6 & 1;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t\n\t                    this.REG_PC = this.pull();\n\t                    this.REG_PC += this.pull() << 8;\n\t                    if (this.REG_PC == 0xFFFF) {\n\t                        return;\n\t                    }\n\t                    this.REG_PC--;\n\t                    this.F_NOTUSED = 1;\n\t                    break;\n\t                }case 42:\n\t                {\n\t\n\t                    // *******\n\t                    // * RTS *\n\t                    // *******\n\t\n\t                    // Return from subroutine. Pull PC from stack.\n\t\n\t                    this.REG_PC = this.pull();\n\t                    this.REG_PC += this.pull() << 8;\n\t\n\t                    if (this.REG_PC == 0xFFFF) {\n\t                        return; // return from NSF play routine:\n\t                    }\n\t                    break;\n\t                }case 43:\n\t                {\n\t\n\t                    // *******\n\t                    // * SBC *\n\t                    // *******\n\t\n\t                    temp = this.REG_ACC - this.load(addr) - (1 - this.F_CARRY);\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    this.F_OVERFLOW = ((this.REG_ACC ^ temp) & 0x80) != 0 && ((this.REG_ACC ^ this.load(addr)) & 0x80) != 0 ? 1 : 0;\n\t                    this.F_CARRY = temp < 0 ? 0 : 1;\n\t                    this.REG_ACC = temp & 0xFF;\n\t                    if (addrMode != 11) cycleCount += cycleAdd; // PostIdxInd = 11\n\t                    break;\n\t                }case 44:\n\t                {\n\t\n\t                    // *******\n\t                    // * SEC *\n\t                    // *******\n\t\n\t                    // Set carry flag\n\t                    this.F_CARRY = 1;\n\t                    break;\n\t                }case 45:\n\t                {\n\t\n\t                    // *******\n\t                    // * SED *\n\t                    // *******\n\t\n\t                    // Set decimal mode\n\t                    this.F_DECIMAL = 1;\n\t                    break;\n\t                }case 46:\n\t                {\n\t\n\t                    // *******\n\t                    // * SEI *\n\t                    // *******\n\t\n\t                    // Set interrupt disable status\n\t                    this.F_INTERRUPT = 1;\n\t                    break;\n\t                }case 47:\n\t                {\n\t\n\t                    // *******\n\t                    // * STA *\n\t                    // *******\n\t\n\t                    // Store accumulator in memory\n\t                    this.write(addr, this.REG_ACC);\n\t                    break;\n\t                }case 48:\n\t                {\n\t\n\t                    // *******\n\t                    // * STX *\n\t                    // *******\n\t\n\t                    // Store index X in memory\n\t                    this.write(addr, this.REG_X);\n\t                    break;\n\t                }case 49:\n\t                {\n\t\n\t                    // *******\n\t                    // * STY *\n\t                    // *******\n\t\n\t                    // Store index Y in memory:\n\t                    this.write(addr, this.REG_Y);\n\t                    break;\n\t                }case 50:\n\t                {\n\t\n\t                    // *******\n\t                    // * TAX *\n\t                    // *******\n\t\n\t                    // Transfer accumulator to index X:\n\t                    this.REG_X = this.REG_ACC;\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    break;\n\t                }case 51:\n\t                {\n\t\n\t                    // *******\n\t                    // * TAY *\n\t                    // *******\n\t\n\t                    // Transfer accumulator to index Y:\n\t                    this.REG_Y = this.REG_ACC;\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    break;\n\t                }case 52:\n\t                {\n\t\n\t                    // *******\n\t                    // * TSX *\n\t                    // *******\n\t\n\t                    // Transfer stack pointer to index X:\n\t                    this.REG_X = this.REG_SP - 0x0100;\n\t                    this.F_SIGN = this.REG_SP >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    break;\n\t                }case 53:\n\t                {\n\t\n\t                    // *******\n\t                    // * TXA *\n\t                    // *******\n\t\n\t                    // Transfer index X to accumulator:\n\t                    this.REG_ACC = this.REG_X;\n\t                    this.F_SIGN = this.REG_X >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    break;\n\t                }case 54:\n\t                {\n\t\n\t                    // *******\n\t                    // * TXS *\n\t                    // *******\n\t\n\t                    // Transfer index X to stack pointer:\n\t                    this.REG_SP = this.REG_X + 0x0100;\n\t                    this.stackWrap();\n\t                    break;\n\t                }case 55:\n\t                {\n\t\n\t                    // *******\n\t                    // * TYA *\n\t                    // *******\n\t\n\t                    // Transfer index Y to accumulator:\n\t                    this.REG_ACC = this.REG_Y;\n\t                    this.F_SIGN = this.REG_Y >> 7 & 1;\n\t                    this.F_ZERO = this.REG_Y;\n\t                    break;\n\t                }default:\n\t                {\n\t\n\t                    // *******\n\t                    // * ??? *\n\t                    // *******\n\t\n\t                    this.nes.stop();\n\t                    this.nes.crashMessage = \"Game crashed, invalid opcode at address $\" + opaddr.toString(16);\n\t                    break;\n\t                }\n\t\n\t        } // end of switch\n\t\n\t        return cycleCount;\n\t    },\n\t\n\t    load: function load(addr) {\n\t        if (addr < 0x2000) {\n\t            return this.mem[addr & 0x7FF];\n\t        } else {\n\t            return this.nes.mmap.load(addr);\n\t        }\n\t    },\n\t\n\t    load16bit: function load16bit(addr) {\n\t        if (addr < 0x1FFF) {\n\t            return this.mem[addr & 0x7FF] | this.mem[addr + 1 & 0x7FF] << 8;\n\t        } else {\n\t            return this.nes.mmap.load(addr) | this.nes.mmap.load(addr + 1) << 8;\n\t        }\n\t    },\n\t\n\t    write: function write(addr, val) {\n\t        if (addr < 0x2000) {\n\t            this.mem[addr & 0x7FF] = val;\n\t        } else {\n\t            this.nes.mmap.write(addr, val);\n\t        }\n\t    },\n\t\n\t    requestIrq: function requestIrq(type) {\n\t        if (this.irqRequested) {\n\t            if (type == this.IRQ_NORMAL) {\n\t                return;\n\t            }\n\t            ////System.out.println(\"too fast irqs. type=\"+type);\n\t        }\n\t        this.irqRequested = true;\n\t        this.irqType = type;\n\t    },\n\t\n\t    push: function push(value) {\n\t        this.nes.mmap.write(this.REG_SP, value);\n\t        this.REG_SP--;\n\t        this.REG_SP = 0x0100 | this.REG_SP & 0xFF;\n\t    },\n\t\n\t    stackWrap: function stackWrap() {\n\t        this.REG_SP = 0x0100 | this.REG_SP & 0xFF;\n\t    },\n\t\n\t    pull: function pull() {\n\t        this.REG_SP++;\n\t        this.REG_SP = 0x0100 | this.REG_SP & 0xFF;\n\t        return this.nes.mmap.load(this.REG_SP);\n\t    },\n\t\n\t    pageCrossed: function pageCrossed(addr1, addr2) {\n\t        return (addr1 & 0xFF00) != (addr2 & 0xFF00);\n\t    },\n\t\n\t    haltCycles: function haltCycles(cycles) {\n\t        this.cyclesToHalt += cycles;\n\t    },\n\t\n\t    doNonMaskableInterrupt: function doNonMaskableInterrupt(status) {\n\t        if ((this.nes.mmap.load(0x2000) & 128) != 0) {\n\t            // Check whether VBlank Interrupts are enabled\n\t\n\t            this.REG_PC_NEW++;\n\t            this.push(this.REG_PC_NEW >> 8 & 0xFF);\n\t            this.push(this.REG_PC_NEW & 0xFF);\n\t            //this.F_INTERRUPT_NEW = 1;\n\t            this.push(status);\n\t\n\t            this.REG_PC_NEW = this.nes.mmap.load(0xFFFA) | this.nes.mmap.load(0xFFFB) << 8;\n\t            this.REG_PC_NEW--;\n\t        }\n\t    },\n\t\n\t    doResetInterrupt: function doResetInterrupt() {\n\t        this.REG_PC_NEW = this.nes.mmap.load(0xFFFC) | this.nes.mmap.load(0xFFFD) << 8;\n\t        this.REG_PC_NEW--;\n\t    },\n\t\n\t    doIrq: function doIrq(status) {\n\t        this.REG_PC_NEW++;\n\t        this.push(this.REG_PC_NEW >> 8 & 0xFF);\n\t        this.push(this.REG_PC_NEW & 0xFF);\n\t        this.push(status);\n\t        this.F_INTERRUPT_NEW = 1;\n\t        this.F_BRK_NEW = 0;\n\t\n\t        this.REG_PC_NEW = this.nes.mmap.load(0xFFFE) | this.nes.mmap.load(0xFFFF) << 8;\n\t        this.REG_PC_NEW--;\n\t    },\n\t\n\t    getStatus: function getStatus() {\n\t        return this.F_CARRY | this.F_ZERO << 1 | this.F_INTERRUPT << 2 | this.F_DECIMAL << 3 | this.F_BRK << 4 | this.F_NOTUSED << 5 | this.F_OVERFLOW << 6 | this.F_SIGN << 7;\n\t    },\n\t\n\t    setStatus: function setStatus(st) {\n\t        this.F_CARRY = st & 1;\n\t        this.F_ZERO = st >> 1 & 1;\n\t        this.F_INTERRUPT = st >> 2 & 1;\n\t        this.F_DECIMAL = st >> 3 & 1;\n\t        this.F_BRK = st >> 4 & 1;\n\t        this.F_NOTUSED = st >> 5 & 1;\n\t        this.F_OVERFLOW = st >> 6 & 1;\n\t        this.F_SIGN = st >> 7 & 1;\n\t    },\n\t\n\t    JSON_PROPERTIES: ['mem', 'cyclesToHalt', 'irqRequested', 'irqType',\n\t    // Registers\n\t    'REG_ACC', 'REG_X', 'REG_Y', 'REG_SP', 'REG_PC', 'REG_PC_NEW', 'REG_STATUS',\n\t    // Status\n\t    'F_CARRY', 'F_DECIMAL', 'F_INTERRUPT', 'F_INTERRUPT_NEW', 'F_OVERFLOW', 'F_SIGN', 'F_ZERO', 'F_NOTUSED', 'F_NOTUSED_NEW', 'F_BRK', 'F_BRK_NEW'],\n\t\n\t    toJSON: function toJSON() {\n\t        return _utils2.default.toJSON(this);\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        _utils2.default.fromJSON(this, s);\n\t    }\n\t};\n\t\n\t// Generates and provides an array of details about instructions\n\tCPU.OpData = function () {\n\t    this.opdata = new Array(256);\n\t\n\t    // Set all to invalid instruction (to detect crashes):\n\t    for (var i = 0; i < 256; i++) {\n\t        this.opdata[i] = 0xFF;\n\t    } // Now fill in all valid opcodes:\n\t\n\t    // ADC:\n\t    this.setOp(this.INS_ADC, 0x69, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_ADC, 0x65, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_ADC, 0x75, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_ADC, 0x6D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_ADC, 0x7D, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_ADC, 0x79, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_ADC, 0x61, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_ADC, 0x71, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // AND:\n\t    this.setOp(this.INS_AND, 0x29, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_AND, 0x25, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_AND, 0x35, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_AND, 0x2D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_AND, 0x3D, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_AND, 0x39, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_AND, 0x21, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_AND, 0x31, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // ASL:\n\t    this.setOp(this.INS_ASL, 0x0A, this.ADDR_ACC, 1, 2);\n\t    this.setOp(this.INS_ASL, 0x06, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_ASL, 0x16, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_ASL, 0x0E, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_ASL, 0x1E, this.ADDR_ABSX, 3, 7);\n\t\n\t    // BCC:\n\t    this.setOp(this.INS_BCC, 0x90, this.ADDR_REL, 2, 2);\n\t\n\t    // BCS:\n\t    this.setOp(this.INS_BCS, 0xB0, this.ADDR_REL, 2, 2);\n\t\n\t    // BEQ:\n\t    this.setOp(this.INS_BEQ, 0xF0, this.ADDR_REL, 2, 2);\n\t\n\t    // BIT:\n\t    this.setOp(this.INS_BIT, 0x24, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_BIT, 0x2C, this.ADDR_ABS, 3, 4);\n\t\n\t    // BMI:\n\t    this.setOp(this.INS_BMI, 0x30, this.ADDR_REL, 2, 2);\n\t\n\t    // BNE:\n\t    this.setOp(this.INS_BNE, 0xD0, this.ADDR_REL, 2, 2);\n\t\n\t    // BPL:\n\t    this.setOp(this.INS_BPL, 0x10, this.ADDR_REL, 2, 2);\n\t\n\t    // BRK:\n\t    this.setOp(this.INS_BRK, 0x00, this.ADDR_IMP, 1, 7);\n\t\n\t    // BVC:\n\t    this.setOp(this.INS_BVC, 0x50, this.ADDR_REL, 2, 2);\n\t\n\t    // BVS:\n\t    this.setOp(this.INS_BVS, 0x70, this.ADDR_REL, 2, 2);\n\t\n\t    // CLC:\n\t    this.setOp(this.INS_CLC, 0x18, this.ADDR_IMP, 1, 2);\n\t\n\t    // CLD:\n\t    this.setOp(this.INS_CLD, 0xD8, this.ADDR_IMP, 1, 2);\n\t\n\t    // CLI:\n\t    this.setOp(this.INS_CLI, 0x58, this.ADDR_IMP, 1, 2);\n\t\n\t    // CLV:\n\t    this.setOp(this.INS_CLV, 0xB8, this.ADDR_IMP, 1, 2);\n\t\n\t    // CMP:\n\t    this.setOp(this.INS_CMP, 0xC9, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_CMP, 0xC5, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_CMP, 0xD5, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_CMP, 0xCD, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_CMP, 0xDD, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_CMP, 0xD9, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_CMP, 0xC1, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_CMP, 0xD1, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // CPX:\n\t    this.setOp(this.INS_CPX, 0xE0, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_CPX, 0xE4, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_CPX, 0xEC, this.ADDR_ABS, 3, 4);\n\t\n\t    // CPY:\n\t    this.setOp(this.INS_CPY, 0xC0, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_CPY, 0xC4, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_CPY, 0xCC, this.ADDR_ABS, 3, 4);\n\t\n\t    // DEC:\n\t    this.setOp(this.INS_DEC, 0xC6, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_DEC, 0xD6, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_DEC, 0xCE, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_DEC, 0xDE, this.ADDR_ABSX, 3, 7);\n\t\n\t    // DEX:\n\t    this.setOp(this.INS_DEX, 0xCA, this.ADDR_IMP, 1, 2);\n\t\n\t    // DEY:\n\t    this.setOp(this.INS_DEY, 0x88, this.ADDR_IMP, 1, 2);\n\t\n\t    // EOR:\n\t    this.setOp(this.INS_EOR, 0x49, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_EOR, 0x45, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_EOR, 0x55, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_EOR, 0x4D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_EOR, 0x5D, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_EOR, 0x59, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_EOR, 0x41, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_EOR, 0x51, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // INC:\n\t    this.setOp(this.INS_INC, 0xE6, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_INC, 0xF6, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_INC, 0xEE, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_INC, 0xFE, this.ADDR_ABSX, 3, 7);\n\t\n\t    // INX:\n\t    this.setOp(this.INS_INX, 0xE8, this.ADDR_IMP, 1, 2);\n\t\n\t    // INY:\n\t    this.setOp(this.INS_INY, 0xC8, this.ADDR_IMP, 1, 2);\n\t\n\t    // JMP:\n\t    this.setOp(this.INS_JMP, 0x4C, this.ADDR_ABS, 3, 3);\n\t    this.setOp(this.INS_JMP, 0x6C, this.ADDR_INDABS, 3, 5);\n\t\n\t    // JSR:\n\t    this.setOp(this.INS_JSR, 0x20, this.ADDR_ABS, 3, 6);\n\t\n\t    // LDA:\n\t    this.setOp(this.INS_LDA, 0xA9, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_LDA, 0xA5, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_LDA, 0xB5, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_LDA, 0xAD, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_LDA, 0xBD, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_LDA, 0xB9, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_LDA, 0xA1, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_LDA, 0xB1, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // LDX:\n\t    this.setOp(this.INS_LDX, 0xA2, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_LDX, 0xA6, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_LDX, 0xB6, this.ADDR_ZPY, 2, 4);\n\t    this.setOp(this.INS_LDX, 0xAE, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_LDX, 0xBE, this.ADDR_ABSY, 3, 4);\n\t\n\t    // LDY:\n\t    this.setOp(this.INS_LDY, 0xA0, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_LDY, 0xA4, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_LDY, 0xB4, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_LDY, 0xAC, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_LDY, 0xBC, this.ADDR_ABSX, 3, 4);\n\t\n\t    // LSR:\n\t    this.setOp(this.INS_LSR, 0x4A, this.ADDR_ACC, 1, 2);\n\t    this.setOp(this.INS_LSR, 0x46, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_LSR, 0x56, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_LSR, 0x4E, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_LSR, 0x5E, this.ADDR_ABSX, 3, 7);\n\t\n\t    // NOP:\n\t    this.setOp(this.INS_NOP, 0xEA, this.ADDR_IMP, 1, 2);\n\t\n\t    // ORA:\n\t    this.setOp(this.INS_ORA, 0x09, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_ORA, 0x05, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_ORA, 0x15, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_ORA, 0x0D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_ORA, 0x1D, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_ORA, 0x19, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_ORA, 0x01, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_ORA, 0x11, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // PHA:\n\t    this.setOp(this.INS_PHA, 0x48, this.ADDR_IMP, 1, 3);\n\t\n\t    // PHP:\n\t    this.setOp(this.INS_PHP, 0x08, this.ADDR_IMP, 1, 3);\n\t\n\t    // PLA:\n\t    this.setOp(this.INS_PLA, 0x68, this.ADDR_IMP, 1, 4);\n\t\n\t    // PLP:\n\t    this.setOp(this.INS_PLP, 0x28, this.ADDR_IMP, 1, 4);\n\t\n\t    // ROL:\n\t    this.setOp(this.INS_ROL, 0x2A, this.ADDR_ACC, 1, 2);\n\t    this.setOp(this.INS_ROL, 0x26, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_ROL, 0x36, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_ROL, 0x2E, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_ROL, 0x3E, this.ADDR_ABSX, 3, 7);\n\t\n\t    // ROR:\n\t    this.setOp(this.INS_ROR, 0x6A, this.ADDR_ACC, 1, 2);\n\t    this.setOp(this.INS_ROR, 0x66, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_ROR, 0x76, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_ROR, 0x6E, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_ROR, 0x7E, this.ADDR_ABSX, 3, 7);\n\t\n\t    // RTI:\n\t    this.setOp(this.INS_RTI, 0x40, this.ADDR_IMP, 1, 6);\n\t\n\t    // RTS:\n\t    this.setOp(this.INS_RTS, 0x60, this.ADDR_IMP, 1, 6);\n\t\n\t    // SBC:\n\t    this.setOp(this.INS_SBC, 0xE9, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_SBC, 0xE5, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_SBC, 0xF5, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_SBC, 0xED, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_SBC, 0xFD, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_SBC, 0xF9, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_SBC, 0xE1, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_SBC, 0xF1, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // SEC:\n\t    this.setOp(this.INS_SEC, 0x38, this.ADDR_IMP, 1, 2);\n\t\n\t    // SED:\n\t    this.setOp(this.INS_SED, 0xF8, this.ADDR_IMP, 1, 2);\n\t\n\t    // SEI:\n\t    this.setOp(this.INS_SEI, 0x78, this.ADDR_IMP, 1, 2);\n\t\n\t    // STA:\n\t    this.setOp(this.INS_STA, 0x85, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_STA, 0x95, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_STA, 0x8D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_STA, 0x9D, this.ADDR_ABSX, 3, 5);\n\t    this.setOp(this.INS_STA, 0x99, this.ADDR_ABSY, 3, 5);\n\t    this.setOp(this.INS_STA, 0x81, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_STA, 0x91, this.ADDR_POSTIDXIND, 2, 6);\n\t\n\t    // STX:\n\t    this.setOp(this.INS_STX, 0x86, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_STX, 0x96, this.ADDR_ZPY, 2, 4);\n\t    this.setOp(this.INS_STX, 0x8E, this.ADDR_ABS, 3, 4);\n\t\n\t    // STY:\n\t    this.setOp(this.INS_STY, 0x84, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_STY, 0x94, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_STY, 0x8C, this.ADDR_ABS, 3, 4);\n\t\n\t    // TAX:\n\t    this.setOp(this.INS_TAX, 0xAA, this.ADDR_IMP, 1, 2);\n\t\n\t    // TAY:\n\t    this.setOp(this.INS_TAY, 0xA8, this.ADDR_IMP, 1, 2);\n\t\n\t    // TSX:\n\t    this.setOp(this.INS_TSX, 0xBA, this.ADDR_IMP, 1, 2);\n\t\n\t    // TXA:\n\t    this.setOp(this.INS_TXA, 0x8A, this.ADDR_IMP, 1, 2);\n\t\n\t    // TXS:\n\t    this.setOp(this.INS_TXS, 0x9A, this.ADDR_IMP, 1, 2);\n\t\n\t    // TYA:\n\t    this.setOp(this.INS_TYA, 0x98, this.ADDR_IMP, 1, 2);\n\t\n\t    this.cycTable = new Array(\n\t    /*0x00*/7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6,\n\t    /*0x10*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0x20*/6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6,\n\t    /*0x30*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0x40*/6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6,\n\t    /*0x50*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0x60*/6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6,\n\t    /*0x70*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0x80*/2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,\n\t    /*0x90*/2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5,\n\t    /*0xA0*/2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,\n\t    /*0xB0*/2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4,\n\t    /*0xC0*/2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,\n\t    /*0xD0*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0xE0*/2, 6, 3, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,\n\t    /*0xF0*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7);\n\t\n\t    this.instname = new Array(56);\n\t\n\t    // Instruction Names:\n\t    this.instname[0] = \"ADC\";\n\t    this.instname[1] = \"AND\";\n\t    this.instname[2] = \"ASL\";\n\t    this.instname[3] = \"BCC\";\n\t    this.instname[4] = \"BCS\";\n\t    this.instname[5] = \"BEQ\";\n\t    this.instname[6] = \"BIT\";\n\t    this.instname[7] = \"BMI\";\n\t    this.instname[8] = \"BNE\";\n\t    this.instname[9] = \"BPL\";\n\t    this.instname[10] = \"BRK\";\n\t    this.instname[11] = \"BVC\";\n\t    this.instname[12] = \"BVS\";\n\t    this.instname[13] = \"CLC\";\n\t    this.instname[14] = \"CLD\";\n\t    this.instname[15] = \"CLI\";\n\t    this.instname[16] = \"CLV\";\n\t    this.instname[17] = \"CMP\";\n\t    this.instname[18] = \"CPX\";\n\t    this.instname[19] = \"CPY\";\n\t    this.instname[20] = \"DEC\";\n\t    this.instname[21] = \"DEX\";\n\t    this.instname[22] = \"DEY\";\n\t    this.instname[23] = \"EOR\";\n\t    this.instname[24] = \"INC\";\n\t    this.instname[25] = \"INX\";\n\t    this.instname[26] = \"INY\";\n\t    this.instname[27] = \"JMP\";\n\t    this.instname[28] = \"JSR\";\n\t    this.instname[29] = \"LDA\";\n\t    this.instname[30] = \"LDX\";\n\t    this.instname[31] = \"LDY\";\n\t    this.instname[32] = \"LSR\";\n\t    this.instname[33] = \"NOP\";\n\t    this.instname[34] = \"ORA\";\n\t    this.instname[35] = \"PHA\";\n\t    this.instname[36] = \"PHP\";\n\t    this.instname[37] = \"PLA\";\n\t    this.instname[38] = \"PLP\";\n\t    this.instname[39] = \"ROL\";\n\t    this.instname[40] = \"ROR\";\n\t    this.instname[41] = \"RTI\";\n\t    this.instname[42] = \"RTS\";\n\t    this.instname[43] = \"SBC\";\n\t    this.instname[44] = \"SEC\";\n\t    this.instname[45] = \"SED\";\n\t    this.instname[46] = \"SEI\";\n\t    this.instname[47] = \"STA\";\n\t    this.instname[48] = \"STX\";\n\t    this.instname[49] = \"STY\";\n\t    this.instname[50] = \"TAX\";\n\t    this.instname[51] = \"TAY\";\n\t    this.instname[52] = \"TSX\";\n\t    this.instname[53] = \"TXA\";\n\t    this.instname[54] = \"TXS\";\n\t    this.instname[55] = \"TYA\";\n\t\n\t    this.addrDesc = new Array(\"Zero Page           \", \"Relative            \", \"Implied             \", \"Absolute            \", \"Accumulator         \", \"Immediate           \", \"Zero Page,X         \", \"Zero Page,Y         \", \"Absolute,X          \", \"Absolute,Y          \", \"Preindexed Indirect \", \"Postindexed Indirect\", \"Indirect Absolute   \");\n\t};\n\t\n\tCPU.OpData.prototype = {\n\t    INS_ADC: 0,\n\t    INS_AND: 1,\n\t    INS_ASL: 2,\n\t\n\t    INS_BCC: 3,\n\t    INS_BCS: 4,\n\t    INS_BEQ: 5,\n\t    INS_BIT: 6,\n\t    INS_BMI: 7,\n\t    INS_BNE: 8,\n\t    INS_BPL: 9,\n\t    INS_BRK: 10,\n\t    INS_BVC: 11,\n\t    INS_BVS: 12,\n\t\n\t    INS_CLC: 13,\n\t    INS_CLD: 14,\n\t    INS_CLI: 15,\n\t    INS_CLV: 16,\n\t    INS_CMP: 17,\n\t    INS_CPX: 18,\n\t    INS_CPY: 19,\n\t\n\t    INS_DEC: 20,\n\t    INS_DEX: 21,\n\t    INS_DEY: 22,\n\t\n\t    INS_EOR: 23,\n\t\n\t    INS_INC: 24,\n\t    INS_INX: 25,\n\t    INS_INY: 26,\n\t\n\t    INS_JMP: 27,\n\t    INS_JSR: 28,\n\t\n\t    INS_LDA: 29,\n\t    INS_LDX: 30,\n\t    INS_LDY: 31,\n\t    INS_LSR: 32,\n\t\n\t    INS_NOP: 33,\n\t\n\t    INS_ORA: 34,\n\t\n\t    INS_PHA: 35,\n\t    INS_PHP: 36,\n\t    INS_PLA: 37,\n\t    INS_PLP: 38,\n\t\n\t    INS_ROL: 39,\n\t    INS_ROR: 40,\n\t    INS_RTI: 41,\n\t    INS_RTS: 42,\n\t\n\t    INS_SBC: 43,\n\t    INS_SEC: 44,\n\t    INS_SED: 45,\n\t    INS_SEI: 46,\n\t    INS_STA: 47,\n\t    INS_STX: 48,\n\t    INS_STY: 49,\n\t\n\t    INS_TAX: 50,\n\t    INS_TAY: 51,\n\t    INS_TSX: 52,\n\t    INS_TXA: 53,\n\t    INS_TXS: 54,\n\t    INS_TYA: 55,\n\t\n\t    INS_DUMMY: 56, // dummy instruction used for 'halting' the processor some cycles\n\t\n\t    // -------------------------------- //\n\t\n\t    // Addressing modes:\n\t    ADDR_ZP: 0,\n\t    ADDR_REL: 1,\n\t    ADDR_IMP: 2,\n\t    ADDR_ABS: 3,\n\t    ADDR_ACC: 4,\n\t    ADDR_IMM: 5,\n\t    ADDR_ZPX: 6,\n\t    ADDR_ZPY: 7,\n\t    ADDR_ABSX: 8,\n\t    ADDR_ABSY: 9,\n\t    ADDR_PREIDXIND: 10,\n\t    ADDR_POSTIDXIND: 11,\n\t    ADDR_INDABS: 12,\n\t\n\t    setOp: function setOp(inst, op, addr, size, cycles) {\n\t        this.opdata[op] = inst & 0xFF | (addr & 0xFF) << 8 | (size & 0xFF) << 16 | (cycles & 0xFF) << 24;\n\t    }\n\t};\n\t\n\texports.default = CPU;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar utils = {\n\t    copyArrayElements: function copyArrayElements(src, srcPos, dest, destPos, length) {\n\t        for (var i = 0; i < length; ++i) {\n\t            dest[destPos + i] = src[srcPos + i];\n\t        }\n\t    },\n\t\n\t    copyArray: function copyArray(src) {\n\t        var dest = new Array(src.length);\n\t        for (var i = 0; i < src.length; i++) {\n\t            dest[i] = src[i];\n\t        }\n\t        return dest;\n\t    },\n\t\n\t    fromJSON: function fromJSON(obj, state) {\n\t        for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n\t            obj[obj.JSON_PROPERTIES[i]] = state[obj.JSON_PROPERTIES[i]];\n\t        }\n\t    },\n\t\n\t    toJSON: function toJSON(obj) {\n\t        var state = {};\n\t        for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n\t            state[obj.JSON_PROPERTIES[i]] = obj[obj.JSON_PROPERTIES[i]];\n\t        }\n\t        return state;\n\t    },\n\t\n\t    isIE: function isIE() {\n\t        return (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)\n\t        );\n\t    }\n\t};\n\t\n\texports.default = utils;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar PPU = function PPU(nes) {\n\t    this.nes = nes;\n\t\n\t    // Keep Chrome happy\n\t    this.vramMem = null;\n\t    this.spriteMem = null;\n\t    this.vramAddress = null;\n\t    this.vramTmpAddress = null;\n\t    this.vramBufferedReadValue = null;\n\t    this.firstWrite = null;\n\t    this.sramAddress = null;\n\t    this.currentMirroring = null;\n\t    this.requestEndFrame = null;\n\t    this.nmiOk = null;\n\t    this.dummyCycleToggle = null;\n\t    this.validTileData = null;\n\t    this.nmiCounter = null;\n\t    this.scanlineAlreadyRendered = null;\n\t    this.f_nmiOnVblank = null;\n\t    this.f_spriteSize = null;\n\t    this.f_bgPatternTable = null;\n\t    this.f_spPatternTable = null;\n\t    this.f_addrInc = null;\n\t    this.f_nTblAddress = null;\n\t    this.f_color = null;\n\t    this.f_spVisibility = null;\n\t    this.f_bgVisibility = null;\n\t    this.f_spClipping = null;\n\t    this.f_bgClipping = null;\n\t    this.f_dispType = null;\n\t    this.cntFV = null;\n\t    this.cntV = null;\n\t    this.cntH = null;\n\t    this.cntVT = null;\n\t    this.cntHT = null;\n\t    this.regFV = null;\n\t    this.regV = null;\n\t    this.regH = null;\n\t    this.regVT = null;\n\t    this.regHT = null;\n\t    this.regFH = null;\n\t    this.regS = null;\n\t    this.curNt = null;\n\t    this.attrib = null;\n\t    this.buffer = null;\n\t    this.prevBuffer = null;\n\t    this.bgbuffer = null;\n\t    this.pixrendered = null;\n\t\n\t    this.validTileData = null;\n\t    this.scantile = null;\n\t    this.scanline = null;\n\t    this.lastRenderedScanline = null;\n\t    this.curX = null;\n\t    this.sprX = null;\n\t    this.sprY = null;\n\t    this.sprTile = null;\n\t    this.sprCol = null;\n\t    this.vertFlip = null;\n\t    this.horiFlip = null;\n\t    this.bgPriority = null;\n\t    this.spr0HitX = null;\n\t    this.spr0HitY = null;\n\t    this.hitSpr0 = null;\n\t    this.sprPalette = null;\n\t    this.imgPalette = null;\n\t    this.ptTile = null;\n\t    this.ntable1 = null;\n\t    this.currentMirroring = null;\n\t    this.nameTable = null;\n\t    this.vramMirrorTable = null;\n\t    this.palTable = null;\n\t\n\t    // Rendering Options:\n\t    this.showSpr0Hit = false;\n\t    this.clipToTvSize = true;\n\t\n\t    this.reset();\n\t}; /*\n\t   JSNES, based on Jamie Sanders' vNES\n\t   Copyright (C) 2010 Ben Firshman\n\t   \n\t   This program is free software: you can redistribute it and/or modify\n\t   it under the terms of the GNU General Public License as published by\n\t   the Free Software Foundation, either version 3 of the License, or\n\t   (at your option) any later version.\n\t   \n\t   This program is distributed in the hope that it will be useful,\n\t   but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t   GNU General Public License for more details.\n\t   \n\t   You should have received a copy of the GNU General Public License\n\t   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t   */\n\t\n\tPPU.prototype = {\n\t    // Status flags:\n\t    STATUS_VRAMWRITE: 4,\n\t    STATUS_SLSPRITECOUNT: 5,\n\t    STATUS_SPRITE0HIT: 6,\n\t    STATUS_VBLANK: 7,\n\t\n\t    reset: function reset() {\n\t        var i;\n\t\n\t        // Memory\n\t        this.vramMem = new Array(0x8000);\n\t        this.spriteMem = new Array(0x100);\n\t        for (i = 0; i < this.vramMem.length; i++) {\n\t            this.vramMem[i] = 0;\n\t        }\n\t        for (i = 0; i < this.spriteMem.length; i++) {\n\t            this.spriteMem[i] = 0;\n\t        }\n\t\n\t        // VRAM I/O:\n\t        this.vramAddress = null;\n\t        this.vramTmpAddress = null;\n\t        this.vramBufferedReadValue = 0;\n\t        this.firstWrite = true; // VRAM/Scroll Hi/Lo latch\n\t\n\t        // SPR-RAM I/O:\n\t        this.sramAddress = 0; // 8-bit only.\n\t\n\t        this.currentMirroring = -1;\n\t        this.requestEndFrame = false;\n\t        this.nmiOk = false;\n\t        this.dummyCycleToggle = false;\n\t        this.validTileData = false;\n\t        this.nmiCounter = 0;\n\t        this.scanlineAlreadyRendered = null;\n\t\n\t        // Control Flags Register 1:\n\t        this.f_nmiOnVblank = 0; // NMI on VBlank. 0=disable, 1=enable\n\t        this.f_spriteSize = 0; // Sprite size. 0=8x8, 1=8x16\n\t        this.f_bgPatternTable = 0; // Background Pattern Table address. 0=0x0000,1=0x1000\n\t        this.f_spPatternTable = 0; // Sprite Pattern Table address. 0=0x0000,1=0x1000\n\t        this.f_addrInc = 0; // PPU Address Increment. 0=1,1=32\n\t        this.f_nTblAddress = 0; // Name Table Address. 0=0x2000,1=0x2400,2=0x2800,3=0x2C00\n\t\n\t        // Control Flags Register 2:\n\t        this.f_color = 0; // Background color. 0=black, 1=blue, 2=green, 4=red\n\t        this.f_spVisibility = 0; // Sprite visibility. 0=not displayed,1=displayed\n\t        this.f_bgVisibility = 0; // Background visibility. 0=Not Displayed,1=displayed\n\t        this.f_spClipping = 0; // Sprite clipping. 0=Sprites invisible in left 8-pixel column,1=No clipping\n\t        this.f_bgClipping = 0; // Background clipping. 0=BG invisible in left 8-pixel column, 1=No clipping\n\t        this.f_dispType = 0; // Display type. 0=color, 1=monochrome\n\t\n\t        // Counters:\n\t        this.cntFV = 0;\n\t        this.cntV = 0;\n\t        this.cntH = 0;\n\t        this.cntVT = 0;\n\t        this.cntHT = 0;\n\t\n\t        // Registers:\n\t        this.regFV = 0;\n\t        this.regV = 0;\n\t        this.regH = 0;\n\t        this.regVT = 0;\n\t        this.regHT = 0;\n\t        this.regFH = 0;\n\t        this.regS = 0;\n\t\n\t        // These are temporary variables used in rendering and sound procedures.\n\t        // Their states outside of those procedures can be ignored.\n\t        // TODO: the use of this is a bit weird, investigate\n\t        this.curNt = null;\n\t\n\t        // Variables used when rendering:\n\t        this.attrib = new Array(32);\n\t        this.buffer = new Array(256 * 240);\n\t        this.prevBuffer = new Array(256 * 240);\n\t        this.bgbuffer = new Array(256 * 240);\n\t        this.pixrendered = new Array(256 * 240);\n\t\n\t        this.validTileData = null;\n\t\n\t        this.scantile = new Array(32);\n\t\n\t        // Initialize misc vars:\n\t        this.scanline = 0;\n\t        this.lastRenderedScanline = -1;\n\t        this.curX = 0;\n\t\n\t        // Sprite data:\n\t        this.sprX = new Array(64); // X coordinate\n\t        this.sprY = new Array(64); // Y coordinate\n\t        this.sprTile = new Array(64); // Tile Index (into pattern table)\n\t        this.sprCol = new Array(64); // Upper two bits of color\n\t        this.vertFlip = new Array(64); // Vertical Flip\n\t        this.horiFlip = new Array(64); // Horizontal Flip\n\t        this.bgPriority = new Array(64); // Background priority\n\t        this.spr0HitX = 0; // Sprite #0 hit X coordinate\n\t        this.spr0HitY = 0; // Sprite #0 hit Y coordinate\n\t        this.hitSpr0 = false;\n\t\n\t        // Palette data:\n\t        this.sprPalette = new Array(16);\n\t        this.imgPalette = new Array(16);\n\t\n\t        // Create pattern table tile buffers:\n\t        this.ptTile = new Array(512);\n\t        for (i = 0; i < 512; i++) {\n\t            this.ptTile[i] = new PPU.Tile();\n\t        }\n\t\n\t        // Create nametable buffers:\n\t        // Name table data:\n\t        this.ntable1 = new Array(4);\n\t        this.currentMirroring = -1;\n\t        this.nameTable = new Array(4);\n\t        for (i = 0; i < 4; i++) {\n\t            this.nameTable[i] = new PPU.NameTable(32, 32, \"Nt\" + i);\n\t        }\n\t\n\t        // Initialize mirroring lookup table:\n\t        this.vramMirrorTable = new Array(0x8000);\n\t        for (i = 0; i < 0x8000; i++) {\n\t            this.vramMirrorTable[i] = i;\n\t        }\n\t\n\t        this.palTable = new PPU.PaletteTable();\n\t        this.palTable.loadNTSCPalette();\n\t        //this.palTable.loadDefaultPalette();\n\t\n\t        this.updateControlReg1(0);\n\t        this.updateControlReg2(0);\n\t    },\n\t\n\t    // Sets Nametable mirroring.\n\t    setMirroring: function setMirroring(mirroring) {\n\t\n\t        if (mirroring == this.currentMirroring) {\n\t            return;\n\t        }\n\t\n\t        this.currentMirroring = mirroring;\n\t        this.triggerRendering();\n\t\n\t        // Remove mirroring:\n\t        if (this.vramMirrorTable === null) {\n\t            this.vramMirrorTable = new Array(0x8000);\n\t        }\n\t        for (var i = 0; i < 0x8000; i++) {\n\t            this.vramMirrorTable[i] = i;\n\t        }\n\t\n\t        // Palette mirroring:\n\t        this.defineMirrorRegion(0x3f20, 0x3f00, 0x20);\n\t        this.defineMirrorRegion(0x3f40, 0x3f00, 0x20);\n\t        this.defineMirrorRegion(0x3f80, 0x3f00, 0x20);\n\t        this.defineMirrorRegion(0x3fc0, 0x3f00, 0x20);\n\t\n\t        // Additional mirroring:\n\t        this.defineMirrorRegion(0x3000, 0x2000, 0xf00);\n\t        this.defineMirrorRegion(0x4000, 0x0000, 0x4000);\n\t\n\t        if (mirroring == this.nes.rom.HORIZONTAL_MIRRORING) {\n\t            // Horizontal mirroring.\n\t\n\t            this.ntable1[0] = 0;\n\t            this.ntable1[1] = 0;\n\t            this.ntable1[2] = 1;\n\t            this.ntable1[3] = 1;\n\t\n\t            this.defineMirrorRegion(0x2400, 0x2000, 0x400);\n\t            this.defineMirrorRegion(0x2c00, 0x2800, 0x400);\n\t        } else if (mirroring == this.nes.rom.VERTICAL_MIRRORING) {\n\t            // Vertical mirroring.\n\t\n\t            this.ntable1[0] = 0;\n\t            this.ntable1[1] = 1;\n\t            this.ntable1[2] = 0;\n\t            this.ntable1[3] = 1;\n\t\n\t            this.defineMirrorRegion(0x2800, 0x2000, 0x400);\n\t            this.defineMirrorRegion(0x2c00, 0x2400, 0x400);\n\t        } else if (mirroring == this.nes.rom.SINGLESCREEN_MIRRORING) {\n\t\n\t            // Single Screen mirroring\n\t\n\t            this.ntable1[0] = 0;\n\t            this.ntable1[1] = 0;\n\t            this.ntable1[2] = 0;\n\t            this.ntable1[3] = 0;\n\t\n\t            this.defineMirrorRegion(0x2400, 0x2000, 0x400);\n\t            this.defineMirrorRegion(0x2800, 0x2000, 0x400);\n\t            this.defineMirrorRegion(0x2c00, 0x2000, 0x400);\n\t        } else if (mirroring == this.nes.rom.SINGLESCREEN_MIRRORING2) {\n\t\n\t            this.ntable1[0] = 1;\n\t            this.ntable1[1] = 1;\n\t            this.ntable1[2] = 1;\n\t            this.ntable1[3] = 1;\n\t\n\t            this.defineMirrorRegion(0x2400, 0x2400, 0x400);\n\t            this.defineMirrorRegion(0x2800, 0x2400, 0x400);\n\t            this.defineMirrorRegion(0x2c00, 0x2400, 0x400);\n\t        } else {\n\t\n\t            // Assume Four-screen mirroring.\n\t\n\t            this.ntable1[0] = 0;\n\t            this.ntable1[1] = 1;\n\t            this.ntable1[2] = 2;\n\t            this.ntable1[3] = 3;\n\t        }\n\t    },\n\t\n\t    // Define a mirrored area in the address lookup table.\n\t    // Assumes the regions don't overlap.\n\t    // The 'to' region is the region that is physically in memory.\n\t    defineMirrorRegion: function defineMirrorRegion(fromStart, toStart, size) {\n\t        for (var i = 0; i < size; i++) {\n\t            this.vramMirrorTable[fromStart + i] = toStart + i;\n\t        }\n\t    },\n\t\n\t    startVBlank: function startVBlank() {\n\t\n\t        // Do NMI:\n\t        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n\t\n\t        // Make sure everything is rendered:\n\t        if (this.lastRenderedScanline < 239) {\n\t            this.renderFramePartially(this.lastRenderedScanline + 1, 240 - this.lastRenderedScanline);\n\t        }\n\t\n\t        // End frame:\n\t        this.endFrame();\n\t\n\t        // Reset scanline counter:\n\t        this.lastRenderedScanline = -1;\n\t    },\n\t\n\t    endScanline: function endScanline() {\n\t        switch (this.scanline) {\n\t            case 19:\n\t                // Dummy scanline.\n\t                // May be variable length:\n\t                if (this.dummyCycleToggle) {\n\t\n\t                    // Remove dead cycle at end of scanline,\n\t                    // for next scanline:\n\t                    this.curX = 1;\n\t                    this.dummyCycleToggle = !this.dummyCycleToggle;\n\t                }\n\t                break;\n\t\n\t            case 20:\n\t                // Clear VBlank flag:\n\t                this.setStatusFlag(this.STATUS_VBLANK, false);\n\t\n\t                // Clear Sprite #0 hit flag:\n\t                this.setStatusFlag(this.STATUS_SPRITE0HIT, false);\n\t                this.hitSpr0 = false;\n\t                this.spr0HitX = -1;\n\t                this.spr0HitY = -1;\n\t\n\t                if (this.f_bgVisibility == 1 || this.f_spVisibility == 1) {\n\t\n\t                    // Update counters:\n\t                    this.cntFV = this.regFV;\n\t                    this.cntV = this.regV;\n\t                    this.cntH = this.regH;\n\t                    this.cntVT = this.regVT;\n\t                    this.cntHT = this.regHT;\n\t\n\t                    if (this.f_bgVisibility == 1) {\n\t                        // Render dummy scanline:\n\t                        this.renderBgScanline(false, 0);\n\t                    }\n\t                }\n\t\n\t                if (this.f_bgVisibility == 1 && this.f_spVisibility == 1) {\n\t\n\t                    // Check sprite 0 hit for first scanline:\n\t                    this.checkSprite0(0);\n\t                }\n\t\n\t                if (this.f_bgVisibility == 1 || this.f_spVisibility == 1) {\n\t                    // Clock mapper IRQ Counter:\n\t                    this.nes.mmap.clockIrqCounter();\n\t                }\n\t                break;\n\t\n\t            case 261:\n\t                // Dead scanline, no rendering.\n\t                // Set VINT:\n\t                this.setStatusFlag(this.STATUS_VBLANK, true);\n\t                this.requestEndFrame = true;\n\t                this.nmiCounter = 9;\n\t\n\t                // Wrap around:\n\t                this.scanline = -1; // will be incremented to 0\n\t\n\t                break;\n\t\n\t            default:\n\t                if (this.scanline >= 21 && this.scanline <= 260) {\n\t\n\t                    // Render normally:\n\t                    if (this.f_bgVisibility == 1) {\n\t\n\t                        if (!this.scanlineAlreadyRendered) {\n\t                            // update scroll:\n\t                            this.cntHT = this.regHT;\n\t                            this.cntH = this.regH;\n\t                            this.renderBgScanline(true, this.scanline + 1 - 21);\n\t                        }\n\t                        this.scanlineAlreadyRendered = false;\n\t\n\t                        // Check for sprite 0 (next scanline):\n\t                        if (!this.hitSpr0 && this.f_spVisibility == 1) {\n\t                            if (this.sprX[0] >= -7 && this.sprX[0] < 256 && this.sprY[0] + 1 <= this.scanline - 20 && this.sprY[0] + 1 + (this.f_spriteSize === 0 ? 8 : 16) >= this.scanline - 20) {\n\t                                if (this.checkSprite0(this.scanline - 20)) {\n\t                                    this.hitSpr0 = true;\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    if (this.f_bgVisibility == 1 || this.f_spVisibility == 1) {\n\t                        // Clock mapper IRQ Counter:\n\t                        this.nes.mmap.clockIrqCounter();\n\t                    }\n\t                }\n\t        }\n\t\n\t        this.scanline++;\n\t        this.regsToAddress();\n\t        this.cntsToAddress();\n\t    },\n\t\n\t    startFrame: function startFrame() {\n\t        // Set background color:\n\t        var bgColor = 0;\n\t\n\t        if (this.f_dispType === 0) {\n\t            // Color display.\n\t            // f_color determines color emphasis.\n\t            // Use first entry of image palette as BG color.\n\t            bgColor = this.imgPalette[0];\n\t        } else {\n\t            // Monochrome display.\n\t            // f_color determines the bg color.\n\t            switch (this.f_color) {\n\t                case 0:\n\t                    // Black\n\t                    bgColor = 0x00000;\n\t                    break;\n\t                case 1:\n\t                    // Green\n\t                    bgColor = 0x00FF00;\n\t                    break;\n\t                case 2:\n\t                    // Blue\n\t                    bgColor = 0xFF0000;\n\t                    break;\n\t                case 3:\n\t                    // Invalid. Use black.\n\t                    bgColor = 0x000000;\n\t                    break;\n\t                case 4:\n\t                    // Red\n\t                    bgColor = 0x0000FF;\n\t                    break;\n\t                default:\n\t                    // Invalid. Use black.\n\t                    bgColor = 0x0;\n\t            }\n\t        }\n\t\n\t        var buffer = this.buffer;\n\t        var i;\n\t        for (i = 0; i < 256 * 240; i++) {\n\t            buffer[i] = bgColor;\n\t        }\n\t        var pixrendered = this.pixrendered;\n\t        for (i = 0; i < pixrendered.length; i++) {\n\t            pixrendered[i] = 65;\n\t        }\n\t    },\n\t\n\t    endFrame: function endFrame() {\n\t        var i, x, y;\n\t        var buffer = this.buffer;\n\t\n\t        // Draw spr#0 hit coordinates:\n\t        if (this.showSpr0Hit) {\n\t            // Spr 0 position:\n\t            if (this.sprX[0] >= 0 && this.sprX[0] < 256 && this.sprY[0] >= 0 && this.sprY[0] < 240) {\n\t                for (i = 0; i < 256; i++) {\n\t                    buffer[(this.sprY[0] << 8) + i] = 0xFF5555;\n\t                }\n\t                for (i = 0; i < 240; i++) {\n\t                    buffer[(i << 8) + this.sprX[0]] = 0xFF5555;\n\t                }\n\t            }\n\t            // Hit position:\n\t            if (this.spr0HitX >= 0 && this.spr0HitX < 256 && this.spr0HitY >= 0 && this.spr0HitY < 240) {\n\t                for (i = 0; i < 256; i++) {\n\t                    buffer[(this.spr0HitY << 8) + i] = 0x55FF55;\n\t                }\n\t                for (i = 0; i < 240; i++) {\n\t                    buffer[(i << 8) + this.spr0HitX] = 0x55FF55;\n\t                }\n\t            }\n\t        }\n\t\n\t        // This is a bit lazy..\n\t        // if either the sprites or the background should be clipped,\n\t        // both are clipped after rendering is finished.\n\t        if (this.clipToTvSize || this.f_bgClipping === 0 || this.f_spClipping === 0) {\n\t            // Clip left 8-pixels column:\n\t            for (y = 0; y < 240; y++) {\n\t                for (x = 0; x < 8; x++) {\n\t                    buffer[(y << 8) + x] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (this.clipToTvSize) {\n\t            // Clip right 8-pixels column too:\n\t            for (y = 0; y < 240; y++) {\n\t                for (x = 0; x < 8; x++) {\n\t                    buffer[(y << 8) + 255 - x] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        // Clip top and bottom 8 pixels:\n\t        if (this.clipToTvSize) {\n\t            for (y = 0; y < 8; y++) {\n\t                for (x = 0; x < 256; x++) {\n\t                    buffer[(y << 8) + x] = 0;\n\t                    buffer[(239 - y << 8) + x] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (this.nes.opts.showDisplay) {\n\t            this.nes.ui.writeFrame(buffer, this.prevBuffer);\n\t        }\n\t    },\n\t\n\t    updateControlReg1: function updateControlReg1(value) {\n\t\n\t        this.triggerRendering();\n\t\n\t        this.f_nmiOnVblank = value >> 7 & 1;\n\t        this.f_spriteSize = value >> 5 & 1;\n\t        this.f_bgPatternTable = value >> 4 & 1;\n\t        this.f_spPatternTable = value >> 3 & 1;\n\t        this.f_addrInc = value >> 2 & 1;\n\t        this.f_nTblAddress = value & 3;\n\t\n\t        this.regV = value >> 1 & 1;\n\t        this.regH = value & 1;\n\t        this.regS = value >> 4 & 1;\n\t    },\n\t\n\t    updateControlReg2: function updateControlReg2(value) {\n\t\n\t        this.triggerRendering();\n\t\n\t        this.f_color = value >> 5 & 7;\n\t        this.f_spVisibility = value >> 4 & 1;\n\t        this.f_bgVisibility = value >> 3 & 1;\n\t        this.f_spClipping = value >> 2 & 1;\n\t        this.f_bgClipping = value >> 1 & 1;\n\t        this.f_dispType = value & 1;\n\t\n\t        if (this.f_dispType === 0) {\n\t            this.palTable.setEmphasis(this.f_color);\n\t        }\n\t        this.updatePalettes();\n\t    },\n\t\n\t    setStatusFlag: function setStatusFlag(flag, value) {\n\t        var n = 1 << flag;\n\t        this.nes.cpu.mem[0x2002] = this.nes.cpu.mem[0x2002] & 255 - n | (value ? n : 0);\n\t    },\n\t\n\t    // CPU Register $2002:\n\t    // Read the Status Register.\n\t    readStatusRegister: function readStatusRegister() {\n\t\n\t        var tmp = this.nes.cpu.mem[0x2002];\n\t\n\t        // Reset scroll & VRAM Address toggle:\n\t        this.firstWrite = true;\n\t\n\t        // Clear VBlank flag:\n\t        this.setStatusFlag(this.STATUS_VBLANK, false);\n\t\n\t        // Fetch status data:\n\t        return tmp;\n\t    },\n\t\n\t    // CPU Register $2003:\n\t    // Write the SPR-RAM address that is used for sramWrite (Register 0x2004 in CPU memory map)\n\t    writeSRAMAddress: function writeSRAMAddress(address) {\n\t        this.sramAddress = address;\n\t    },\n\t\n\t    // CPU Register $2004 (R):\n\t    // Read from SPR-RAM (Sprite RAM).\n\t    // The address should be set first.\n\t    sramLoad: function sramLoad() {\n\t        /*short tmp = sprMem.load(sramAddress);\n\t        sramAddress++; // Increment address\n\t        sramAddress%=0x100;\n\t        return tmp;*/\n\t        return this.spriteMem[this.sramAddress];\n\t    },\n\t\n\t    // CPU Register $2004 (W):\n\t    // Write to SPR-RAM (Sprite RAM).\n\t    // The address should be set first.\n\t    sramWrite: function sramWrite(value) {\n\t        this.spriteMem[this.sramAddress] = value;\n\t        this.spriteRamWriteUpdate(this.sramAddress, value);\n\t        this.sramAddress++; // Increment address\n\t        this.sramAddress %= 0x100;\n\t    },\n\t\n\t    // CPU Register $2005:\n\t    // Write to scroll registers.\n\t    // The first write is the vertical offset, the second is the\n\t    // horizontal offset:\n\t    scrollWrite: function scrollWrite(value) {\n\t        this.triggerRendering();\n\t\n\t        if (this.firstWrite) {\n\t            // First write, horizontal scroll:\n\t            this.regHT = value >> 3 & 31;\n\t            this.regFH = value & 7;\n\t        } else {\n\t\n\t            // Second write, vertical scroll:\n\t            this.regFV = value & 7;\n\t            this.regVT = value >> 3 & 31;\n\t        }\n\t        this.firstWrite = !this.firstWrite;\n\t    },\n\t\n\t    // CPU Register $2006:\n\t    // Sets the adress used when reading/writing from/to VRAM.\n\t    // The first write sets the high byte, the second the low byte.\n\t    writeVRAMAddress: function writeVRAMAddress(address) {\n\t\n\t        if (this.firstWrite) {\n\t\n\t            this.regFV = address >> 4 & 3;\n\t            this.regV = address >> 3 & 1;\n\t            this.regH = address >> 2 & 1;\n\t            this.regVT = this.regVT & 7 | (address & 3) << 3;\n\t        } else {\n\t            this.triggerRendering();\n\t\n\t            this.regVT = this.regVT & 24 | address >> 5 & 7;\n\t            this.regHT = address & 31;\n\t\n\t            this.cntFV = this.regFV;\n\t            this.cntV = this.regV;\n\t            this.cntH = this.regH;\n\t            this.cntVT = this.regVT;\n\t            this.cntHT = this.regHT;\n\t\n\t            this.checkSprite0(this.scanline - 20);\n\t        }\n\t\n\t        this.firstWrite = !this.firstWrite;\n\t\n\t        // Invoke mapper latch:\n\t        this.cntsToAddress();\n\t        if (this.vramAddress < 0x2000) {\n\t            this.nes.mmap.latchAccess(this.vramAddress);\n\t        }\n\t    },\n\t\n\t    // CPU Register $2007(R):\n\t    // Read from PPU memory. The address should be set first.\n\t    vramLoad: function vramLoad() {\n\t        var tmp;\n\t\n\t        this.cntsToAddress();\n\t        this.regsToAddress();\n\t\n\t        // If address is in range 0x0000-0x3EFF, return buffered values:\n\t        if (this.vramAddress <= 0x3EFF) {\n\t            tmp = this.vramBufferedReadValue;\n\t\n\t            // Update buffered value:\n\t            if (this.vramAddress < 0x2000) {\n\t                this.vramBufferedReadValue = this.vramMem[this.vramAddress];\n\t            } else {\n\t                this.vramBufferedReadValue = this.mirroredLoad(this.vramAddress);\n\t            }\n\t\n\t            // Mapper latch access:\n\t            if (this.vramAddress < 0x2000) {\n\t                this.nes.mmap.latchAccess(this.vramAddress);\n\t            }\n\t\n\t            // Increment by either 1 or 32, depending on d2 of Control Register 1:\n\t            this.vramAddress += this.f_addrInc == 1 ? 32 : 1;\n\t\n\t            this.cntsFromAddress();\n\t            this.regsFromAddress();\n\t\n\t            return tmp; // Return the previous buffered value.\n\t        }\n\t\n\t        // No buffering in this mem range. Read normally.\n\t        tmp = this.mirroredLoad(this.vramAddress);\n\t\n\t        // Increment by either 1 or 32, depending on d2 of Control Register 1:\n\t        this.vramAddress += this.f_addrInc == 1 ? 32 : 1;\n\t\n\t        this.cntsFromAddress();\n\t        this.regsFromAddress();\n\t\n\t        return tmp;\n\t    },\n\t\n\t    // CPU Register $2007(W):\n\t    // Write to PPU memory. The address should be set first.\n\t    vramWrite: function vramWrite(value) {\n\t\n\t        this.triggerRendering();\n\t        this.cntsToAddress();\n\t        this.regsToAddress();\n\t\n\t        if (this.vramAddress >= 0x2000) {\n\t            // Mirroring is used.\n\t            this.mirroredWrite(this.vramAddress, value);\n\t        } else {\n\t\n\t            // Write normally.\n\t            this.writeMem(this.vramAddress, value);\n\t\n\t            // Invoke mapper latch:\n\t            this.nes.mmap.latchAccess(this.vramAddress);\n\t        }\n\t\n\t        // Increment by either 1 or 32, depending on d2 of Control Register 1:\n\t        this.vramAddress += this.f_addrInc == 1 ? 32 : 1;\n\t        this.regsFromAddress();\n\t        this.cntsFromAddress();\n\t    },\n\t\n\t    // CPU Register $4014:\n\t    // Write 256 bytes of main memory\n\t    // into Sprite RAM.\n\t    sramDMA: function sramDMA(value) {\n\t        var baseAddress = value * 0x100;\n\t        var data;\n\t        for (var i = this.sramAddress; i < 256; i++) {\n\t            data = this.nes.cpu.mem[baseAddress + i];\n\t            this.spriteMem[i] = data;\n\t            this.spriteRamWriteUpdate(i, data);\n\t        }\n\t\n\t        this.nes.cpu.haltCycles(513);\n\t    },\n\t\n\t    // Updates the scroll registers from a new VRAM address.\n\t    regsFromAddress: function regsFromAddress() {\n\t\n\t        var address = this.vramTmpAddress >> 8 & 0xFF;\n\t        this.regFV = address >> 4 & 7;\n\t        this.regV = address >> 3 & 1;\n\t        this.regH = address >> 2 & 1;\n\t        this.regVT = this.regVT & 7 | (address & 3) << 3;\n\t\n\t        address = this.vramTmpAddress & 0xFF;\n\t        this.regVT = this.regVT & 24 | address >> 5 & 7;\n\t        this.regHT = address & 31;\n\t    },\n\t\n\t    // Updates the scroll registers from a new VRAM address.\n\t    cntsFromAddress: function cntsFromAddress() {\n\t\n\t        var address = this.vramAddress >> 8 & 0xFF;\n\t        this.cntFV = address >> 4 & 3;\n\t        this.cntV = address >> 3 & 1;\n\t        this.cntH = address >> 2 & 1;\n\t        this.cntVT = this.cntVT & 7 | (address & 3) << 3;\n\t\n\t        address = this.vramAddress & 0xFF;\n\t        this.cntVT = this.cntVT & 24 | address >> 5 & 7;\n\t        this.cntHT = address & 31;\n\t    },\n\t\n\t    regsToAddress: function regsToAddress() {\n\t        var b1 = (this.regFV & 7) << 4;\n\t        b1 |= (this.regV & 1) << 3;\n\t        b1 |= (this.regH & 1) << 2;\n\t        b1 |= this.regVT >> 3 & 3;\n\t\n\t        var b2 = (this.regVT & 7) << 5;\n\t        b2 |= this.regHT & 31;\n\t\n\t        this.vramTmpAddress = (b1 << 8 | b2) & 0x7FFF;\n\t    },\n\t\n\t    cntsToAddress: function cntsToAddress() {\n\t        var b1 = (this.cntFV & 7) << 4;\n\t        b1 |= (this.cntV & 1) << 3;\n\t        b1 |= (this.cntH & 1) << 2;\n\t        b1 |= this.cntVT >> 3 & 3;\n\t\n\t        var b2 = (this.cntVT & 7) << 5;\n\t        b2 |= this.cntHT & 31;\n\t\n\t        this.vramAddress = (b1 << 8 | b2) & 0x7FFF;\n\t    },\n\t\n\t    incTileCounter: function incTileCounter(count) {\n\t        for (var i = count; i !== 0; i--) {\n\t            this.cntHT++;\n\t            if (this.cntHT == 32) {\n\t                this.cntHT = 0;\n\t                this.cntVT++;\n\t                if (this.cntVT >= 30) {\n\t                    this.cntH++;\n\t                    if (this.cntH == 2) {\n\t                        this.cntH = 0;\n\t                        this.cntV++;\n\t                        if (this.cntV == 2) {\n\t                            this.cntV = 0;\n\t                            this.cntFV++;\n\t                            this.cntFV &= 0x7;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    // Reads from memory, taking into account\n\t    // mirroring/mapping of address ranges.\n\t    mirroredLoad: function mirroredLoad(address) {\n\t        return this.vramMem[this.vramMirrorTable[address]];\n\t    },\n\t\n\t    // Writes to memory, taking into account\n\t    // mirroring/mapping of address ranges.\n\t    mirroredWrite: function mirroredWrite(address, value) {\n\t        if (address >= 0x3f00 && address < 0x3f20) {\n\t            // Palette write mirroring.\n\t            if (address == 0x3F00 || address == 0x3F10) {\n\t                this.writeMem(0x3F00, value);\n\t                this.writeMem(0x3F10, value);\n\t            } else if (address == 0x3F04 || address == 0x3F14) {\n\t\n\t                this.writeMem(0x3F04, value);\n\t                this.writeMem(0x3F14, value);\n\t            } else if (address == 0x3F08 || address == 0x3F18) {\n\t\n\t                this.writeMem(0x3F08, value);\n\t                this.writeMem(0x3F18, value);\n\t            } else if (address == 0x3F0C || address == 0x3F1C) {\n\t\n\t                this.writeMem(0x3F0C, value);\n\t                this.writeMem(0x3F1C, value);\n\t            } else {\n\t                this.writeMem(address, value);\n\t            }\n\t        } else {\n\t\n\t            // Use lookup table for mirrored address:\n\t            if (address < this.vramMirrorTable.length) {\n\t                this.writeMem(this.vramMirrorTable[address], value);\n\t            } else {\n\t                // FIXME\n\t                alert(\"Invalid VRAM address: \" + address.toString(16));\n\t            }\n\t        }\n\t    },\n\t\n\t    triggerRendering: function triggerRendering() {\n\t        if (this.scanline >= 21 && this.scanline <= 260) {\n\t            // Render sprites, and combine:\n\t            this.renderFramePartially(this.lastRenderedScanline + 1, this.scanline - 21 - this.lastRenderedScanline);\n\t\n\t            // Set last rendered scanline:\n\t            this.lastRenderedScanline = this.scanline - 21;\n\t        }\n\t    },\n\t\n\t    renderFramePartially: function renderFramePartially(startScan, scanCount) {\n\t        if (this.f_spVisibility == 1) {\n\t            this.renderSpritesPartially(startScan, scanCount, true);\n\t        }\n\t\n\t        if (this.f_bgVisibility == 1) {\n\t            var si = startScan << 8;\n\t            var ei = startScan + scanCount << 8;\n\t            if (ei > 0xF000) {\n\t                ei = 0xF000;\n\t            }\n\t            var buffer = this.buffer;\n\t            var bgbuffer = this.bgbuffer;\n\t            var pixrendered = this.pixrendered;\n\t            for (var destIndex = si; destIndex < ei; destIndex++) {\n\t                if (pixrendered[destIndex] > 0xFF) {\n\t                    buffer[destIndex] = bgbuffer[destIndex];\n\t                }\n\t            }\n\t        }\n\t\n\t        if (this.f_spVisibility == 1) {\n\t            this.renderSpritesPartially(startScan, scanCount, false);\n\t        }\n\t\n\t        this.validTileData = false;\n\t    },\n\t\n\t    renderBgScanline: function renderBgScanline(bgbuffer, scan) {\n\t        var baseTile = this.regS === 0 ? 0 : 256;\n\t        var destIndex = (scan << 8) - this.regFH;\n\t\n\t        this.curNt = this.ntable1[this.cntV + this.cntV + this.cntH];\n\t\n\t        this.cntHT = this.regHT;\n\t        this.cntH = this.regH;\n\t        this.curNt = this.ntable1[this.cntV + this.cntV + this.cntH];\n\t\n\t        if (scan < 240 && scan - this.cntFV >= 0) {\n\t\n\t            var tscanoffset = this.cntFV << 3;\n\t            var scantile = this.scantile;\n\t            var attrib = this.attrib;\n\t            var ptTile = this.ptTile;\n\t            var nameTable = this.nameTable;\n\t            var imgPalette = this.imgPalette;\n\t            var pixrendered = this.pixrendered;\n\t            var targetBuffer = bgbuffer ? this.bgbuffer : this.buffer;\n\t\n\t            var t, tpix, att, col;\n\t\n\t            for (var tile = 0; tile < 32; tile++) {\n\t\n\t                if (scan >= 0) {\n\t\n\t                    // Fetch tile & attrib data:\n\t                    if (this.validTileData) {\n\t                        // Get data from array:\n\t                        t = scantile[tile];\n\t                        tpix = t.pix;\n\t                        att = attrib[tile];\n\t                    } else {\n\t                        // Fetch data:\n\t                        t = ptTile[baseTile + nameTable[this.curNt].getTileIndex(this.cntHT, this.cntVT)];\n\t                        tpix = t.pix;\n\t                        att = nameTable[this.curNt].getAttrib(this.cntHT, this.cntVT);\n\t                        scantile[tile] = t;\n\t                        attrib[tile] = att;\n\t                    }\n\t\n\t                    // Render tile scanline:\n\t                    var sx = 0;\n\t                    var x = (tile << 3) - this.regFH;\n\t\n\t                    if (x > -8) {\n\t                        if (x < 0) {\n\t                            destIndex -= x;\n\t                            sx = -x;\n\t                        }\n\t                        if (t.opaque[this.cntFV]) {\n\t                            for (; sx < 8; sx++) {\n\t                                targetBuffer[destIndex] = imgPalette[tpix[tscanoffset + sx] + att];\n\t                                pixrendered[destIndex] |= 256;\n\t                                destIndex++;\n\t                            }\n\t                        } else {\n\t                            for (; sx < 8; sx++) {\n\t                                col = tpix[tscanoffset + sx];\n\t                                if (col !== 0) {\n\t                                    targetBuffer[destIndex] = imgPalette[col + att];\n\t                                    pixrendered[destIndex] |= 256;\n\t                                }\n\t                                destIndex++;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                // Increase Horizontal Tile Counter:\n\t                if (++this.cntHT == 32) {\n\t                    this.cntHT = 0;\n\t                    this.cntH++;\n\t                    this.cntH %= 2;\n\t                    this.curNt = this.ntable1[(this.cntV << 1) + this.cntH];\n\t                }\n\t            }\n\t\n\t            // Tile data for one row should now have been fetched,\n\t            // so the data in the array is valid.\n\t            this.validTileData = true;\n\t        }\n\t\n\t        // update vertical scroll:\n\t        this.cntFV++;\n\t        if (this.cntFV == 8) {\n\t            this.cntFV = 0;\n\t            this.cntVT++;\n\t            if (this.cntVT == 30) {\n\t                this.cntVT = 0;\n\t                this.cntV++;\n\t                this.cntV %= 2;\n\t                this.curNt = this.ntable1[(this.cntV << 1) + this.cntH];\n\t            } else if (this.cntVT == 32) {\n\t                this.cntVT = 0;\n\t            }\n\t\n\t            // Invalidate fetched data:\n\t            this.validTileData = false;\n\t        }\n\t    },\n\t\n\t    renderSpritesPartially: function renderSpritesPartially(startscan, scancount, bgPri) {\n\t        if (this.f_spVisibility === 1) {\n\t\n\t            for (var i = 0; i < 64; i++) {\n\t                if (this.bgPriority[i] == bgPri && this.sprX[i] >= 0 && this.sprX[i] < 256 && this.sprY[i] + 8 >= startscan && this.sprY[i] < startscan + scancount) {\n\t                    // Show sprite.\n\t                    if (this.f_spriteSize === 0) {\n\t                        // 8x8 sprites\n\t\n\t                        this.srcy1 = 0;\n\t                        this.srcy2 = 8;\n\t\n\t                        if (this.sprY[i] < startscan) {\n\t                            this.srcy1 = startscan - this.sprY[i] - 1;\n\t                        }\n\t\n\t                        if (this.sprY[i] + 8 > startscan + scancount) {\n\t                            this.srcy2 = startscan + scancount - this.sprY[i] + 1;\n\t                        }\n\t\n\t                        if (this.f_spPatternTable === 0) {\n\t                            this.ptTile[this.sprTile[i]].render(this.buffer, 0, this.srcy1, 8, this.srcy2, this.sprX[i], this.sprY[i] + 1, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n\t                        } else {\n\t                            this.ptTile[this.sprTile[i] + 256].render(this.buffer, 0, this.srcy1, 8, this.srcy2, this.sprX[i], this.sprY[i] + 1, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n\t                        }\n\t                    } else {\n\t                        // 8x16 sprites\n\t                        var top = this.sprTile[i];\n\t                        if ((top & 1) !== 0) {\n\t                            top = this.sprTile[i] - 1 + 256;\n\t                        }\n\t\n\t                        var srcy1 = 0;\n\t                        var srcy2 = 8;\n\t\n\t                        if (this.sprY[i] < startscan) {\n\t                            srcy1 = startscan - this.sprY[i] - 1;\n\t                        }\n\t\n\t                        if (this.sprY[i] + 8 > startscan + scancount) {\n\t                            srcy2 = startscan + scancount - this.sprY[i];\n\t                        }\n\t\n\t                        this.ptTile[top + (this.vertFlip[i] ? 1 : 0)].render(this.buffer, 0, srcy1, 8, srcy2, this.sprX[i], this.sprY[i] + 1, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n\t\n\t                        srcy1 = 0;\n\t                        srcy2 = 8;\n\t\n\t                        if (this.sprY[i] + 8 < startscan) {\n\t                            srcy1 = startscan - (this.sprY[i] + 8 + 1);\n\t                        }\n\t\n\t                        if (this.sprY[i] + 16 > startscan + scancount) {\n\t                            srcy2 = startscan + scancount - (this.sprY[i] + 8);\n\t                        }\n\t\n\t                        this.ptTile[top + (this.vertFlip[i] ? 0 : 1)].render(this.buffer, 0, srcy1, 8, srcy2, this.sprX[i], this.sprY[i] + 1 + 8, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    checkSprite0: function checkSprite0(scan) {\n\t\n\t        this.spr0HitX = -1;\n\t        this.spr0HitY = -1;\n\t\n\t        var toffset;\n\t        var tIndexAdd = this.f_spPatternTable === 0 ? 0 : 256;\n\t        var x, y, t, i;\n\t        var bufferIndex;\n\t        var col;\n\t        var bgPri;\n\t\n\t        x = this.sprX[0];\n\t        y = this.sprY[0] + 1;\n\t\n\t        if (this.f_spriteSize === 0) {\n\t            // 8x8 sprites.\n\t\n\t            // Check range:\n\t            if (y <= scan && y + 8 > scan && x >= -7 && x < 256) {\n\t\n\t                // Sprite is in range.\n\t                // Draw scanline:\n\t                t = this.ptTile[this.sprTile[0] + tIndexAdd];\n\t                col = this.sprCol[0];\n\t                bgPri = this.bgPriority[0];\n\t\n\t                if (this.vertFlip[0]) {\n\t                    toffset = 7 - (scan - y);\n\t                } else {\n\t                    toffset = scan - y;\n\t                }\n\t                toffset *= 8;\n\t\n\t                bufferIndex = scan * 256 + x;\n\t                if (this.horiFlip[0]) {\n\t                    for (i = 7; i >= 0; i--) {\n\t                        if (x >= 0 && x < 256) {\n\t                            if (bufferIndex >= 0 && bufferIndex < 61440 && this.pixrendered[bufferIndex] !== 0) {\n\t                                if (t.pix[toffset + i] !== 0) {\n\t                                    this.spr0HitX = bufferIndex % 256;\n\t                                    this.spr0HitY = scan;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }\n\t                        x++;\n\t                        bufferIndex++;\n\t                    }\n\t                } else {\n\t                    for (i = 0; i < 8; i++) {\n\t                        if (x >= 0 && x < 256) {\n\t                            if (bufferIndex >= 0 && bufferIndex < 61440 && this.pixrendered[bufferIndex] !== 0) {\n\t                                if (t.pix[toffset + i] !== 0) {\n\t                                    this.spr0HitX = bufferIndex % 256;\n\t                                    this.spr0HitY = scan;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }\n\t                        x++;\n\t                        bufferIndex++;\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            // 8x16 sprites:\n\t\n\t            // Check range:\n\t            if (y <= scan && y + 16 > scan && x >= -7 && x < 256) {\n\t                // Sprite is in range.\n\t                // Draw scanline:\n\t\n\t                if (this.vertFlip[0]) {\n\t                    toffset = 15 - (scan - y);\n\t                } else {\n\t                    toffset = scan - y;\n\t                }\n\t\n\t                if (toffset < 8) {\n\t                    // first half of sprite.\n\t                    t = this.ptTile[this.sprTile[0] + (this.vertFlip[0] ? 1 : 0) + ((this.sprTile[0] & 1) !== 0 ? 255 : 0)];\n\t                } else {\n\t                    // second half of sprite.\n\t                    t = this.ptTile[this.sprTile[0] + (this.vertFlip[0] ? 0 : 1) + ((this.sprTile[0] & 1) !== 0 ? 255 : 0)];\n\t                    if (this.vertFlip[0]) {\n\t                        toffset = 15 - toffset;\n\t                    } else {\n\t                        toffset -= 8;\n\t                    }\n\t                }\n\t                toffset *= 8;\n\t                col = this.sprCol[0];\n\t                bgPri = this.bgPriority[0];\n\t\n\t                bufferIndex = scan * 256 + x;\n\t                if (this.horiFlip[0]) {\n\t                    for (i = 7; i >= 0; i--) {\n\t                        if (x >= 0 && x < 256) {\n\t                            if (bufferIndex >= 0 && bufferIndex < 61440 && this.pixrendered[bufferIndex] !== 0) {\n\t                                if (t.pix[toffset + i] !== 0) {\n\t                                    this.spr0HitX = bufferIndex % 256;\n\t                                    this.spr0HitY = scan;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }\n\t                        x++;\n\t                        bufferIndex++;\n\t                    }\n\t                } else {\n\t\n\t                    for (i = 0; i < 8; i++) {\n\t                        if (x >= 0 && x < 256) {\n\t                            if (bufferIndex >= 0 && bufferIndex < 61440 && this.pixrendered[bufferIndex] !== 0) {\n\t                                if (t.pix[toffset + i] !== 0) {\n\t                                    this.spr0HitX = bufferIndex % 256;\n\t                                    this.spr0HitY = scan;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }\n\t                        x++;\n\t                        bufferIndex++;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        return false;\n\t    },\n\t\n\t    // This will write to PPU memory, and\n\t    // update internally buffered data\n\t    // appropriately.\n\t    writeMem: function writeMem(address, value) {\n\t        this.vramMem[address] = value;\n\t\n\t        // Update internally buffered data:\n\t        if (address < 0x2000) {\n\t            this.vramMem[address] = value;\n\t            this.patternWrite(address, value);\n\t        } else if (address >= 0x2000 && address < 0x23c0) {\n\t            this.nameTableWrite(this.ntable1[0], address - 0x2000, value);\n\t        } else if (address >= 0x23c0 && address < 0x2400) {\n\t            this.attribTableWrite(this.ntable1[0], address - 0x23c0, value);\n\t        } else if (address >= 0x2400 && address < 0x27c0) {\n\t            this.nameTableWrite(this.ntable1[1], address - 0x2400, value);\n\t        } else if (address >= 0x27c0 && address < 0x2800) {\n\t            this.attribTableWrite(this.ntable1[1], address - 0x27c0, value);\n\t        } else if (address >= 0x2800 && address < 0x2bc0) {\n\t            this.nameTableWrite(this.ntable1[2], address - 0x2800, value);\n\t        } else if (address >= 0x2bc0 && address < 0x2c00) {\n\t            this.attribTableWrite(this.ntable1[2], address - 0x2bc0, value);\n\t        } else if (address >= 0x2c00 && address < 0x2fc0) {\n\t            this.nameTableWrite(this.ntable1[3], address - 0x2c00, value);\n\t        } else if (address >= 0x2fc0 && address < 0x3000) {\n\t            this.attribTableWrite(this.ntable1[3], address - 0x2fc0, value);\n\t        } else if (address >= 0x3f00 && address < 0x3f20) {\n\t            this.updatePalettes();\n\t        }\n\t    },\n\t\n\t    // Reads data from $3f00 to $f20\n\t    // into the two buffered palettes.\n\t    updatePalettes: function updatePalettes() {\n\t        var i;\n\t\n\t        for (i = 0; i < 16; i++) {\n\t            if (this.f_dispType === 0) {\n\t                this.imgPalette[i] = this.palTable.getEntry(this.vramMem[0x3f00 + i] & 63);\n\t            } else {\n\t                this.imgPalette[i] = this.palTable.getEntry(this.vramMem[0x3f00 + i] & 32);\n\t            }\n\t        }\n\t        for (i = 0; i < 16; i++) {\n\t            if (this.f_dispType === 0) {\n\t                this.sprPalette[i] = this.palTable.getEntry(this.vramMem[0x3f10 + i] & 63);\n\t            } else {\n\t                this.sprPalette[i] = this.palTable.getEntry(this.vramMem[0x3f10 + i] & 32);\n\t            }\n\t        }\n\t    },\n\t\n\t    // Updates the internal pattern\n\t    // table buffers with this new byte.\n\t    // In vNES, there is a version of this with 4 arguments which isn't used.\n\t    patternWrite: function patternWrite(address, value) {\n\t        var tileIndex = Math.floor(address / 16);\n\t        var leftOver = address % 16;\n\t        if (leftOver < 8) {\n\t            this.ptTile[tileIndex].setScanline(leftOver, value, this.vramMem[address + 8]);\n\t        } else {\n\t            this.ptTile[tileIndex].setScanline(leftOver - 8, this.vramMem[address - 8], value);\n\t        }\n\t    },\n\t\n\t    // Updates the internal name table buffers\n\t    // with this new byte.\n\t    nameTableWrite: function nameTableWrite(index, address, value) {\n\t        this.nameTable[index].tile[address] = value;\n\t\n\t        // Update Sprite #0 hit:\n\t        //updateSpr0Hit();\n\t        this.checkSprite0(this.scanline - 20);\n\t    },\n\t\n\t    // Updates the internal pattern\n\t    // table buffers with this new attribute\n\t    // table byte.\n\t    attribTableWrite: function attribTableWrite(index, address, value) {\n\t        this.nameTable[index].writeAttrib(address, value);\n\t    },\n\t\n\t    // Updates the internally buffered sprite\n\t    // data with this new byte of info.\n\t    spriteRamWriteUpdate: function spriteRamWriteUpdate(address, value) {\n\t        var tIndex = Math.floor(address / 4);\n\t\n\t        if (tIndex === 0) {\n\t            //updateSpr0Hit();\n\t            this.checkSprite0(this.scanline - 20);\n\t        }\n\t\n\t        if (address % 4 === 0) {\n\t            // Y coordinate\n\t            this.sprY[tIndex] = value;\n\t        } else if (address % 4 == 1) {\n\t            // Tile index\n\t            this.sprTile[tIndex] = value;\n\t        } else if (address % 4 == 2) {\n\t            // Attributes\n\t            this.vertFlip[tIndex] = (value & 0x80) !== 0;\n\t            this.horiFlip[tIndex] = (value & 0x40) !== 0;\n\t            this.bgPriority[tIndex] = (value & 0x20) !== 0;\n\t            this.sprCol[tIndex] = (value & 3) << 2;\n\t        } else if (address % 4 == 3) {\n\t            // X coordinate\n\t            this.sprX[tIndex] = value;\n\t        }\n\t    },\n\t\n\t    doNMI: function doNMI() {\n\t        // Set VBlank flag:\n\t        this.setStatusFlag(this.STATUS_VBLANK, true);\n\t        //nes.getCpu().doNonMaskableInterrupt();\n\t        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n\t    },\n\t\n\t    JSON_PROPERTIES: [\n\t    // Memory\n\t    'vramMem', 'spriteMem',\n\t    // Counters\n\t    'cntFV', 'cntV', 'cntH', 'cntVT', 'cntHT',\n\t    // Registers\n\t    'regFV', 'regV', 'regH', 'regVT', 'regHT', 'regFH', 'regS',\n\t    // VRAM addr\n\t    'vramAddress', 'vramTmpAddress',\n\t    // Control/Status registers\n\t    'f_nmiOnVblank', 'f_spriteSize', 'f_bgPatternTable', 'f_spPatternTable', 'f_addrInc', 'f_nTblAddress', 'f_color', 'f_spVisibility', 'f_bgVisibility', 'f_spClipping', 'f_bgClipping', 'f_dispType',\n\t    // VRAM I/O\n\t    'vramBufferedReadValue', 'firstWrite',\n\t    // Mirroring\n\t    'currentMirroring', 'vramMirrorTable', 'ntable1',\n\t    // SPR-RAM I/O\n\t    'sramAddress',\n\t    // Sprites. Most sprite data is rebuilt from spriteMem\n\t    'hitSpr0',\n\t    // Palettes\n\t    'sprPalette', 'imgPalette',\n\t    // Rendering progression\n\t    'curX', 'scanline', 'lastRenderedScanline', 'curNt', 'scantile',\n\t    // Used during rendering\n\t    'attrib', 'buffer', 'bgbuffer', 'pixrendered',\n\t    // Misc\n\t    'requestEndFrame', 'nmiOk', 'dummyCycleToggle', 'nmiCounter', 'validTileData', 'scanlineAlreadyRendered'],\n\t\n\t    toJSON: function toJSON() {\n\t        var i;\n\t        var state = _utils2.default.toJSON(this);\n\t\n\t        state.nameTable = [];\n\t        for (i = 0; i < this.nameTable.length; i++) {\n\t            state.nameTable[i] = this.nameTable[i].toJSON();\n\t        }\n\t\n\t        state.ptTile = [];\n\t        for (i = 0; i < this.ptTile.length; i++) {\n\t            state.ptTile[i] = this.ptTile[i].toJSON();\n\t        }\n\t\n\t        return state;\n\t    },\n\t\n\t    fromJSON: function fromJSON(state) {\n\t        var i;\n\t\n\t        _utils2.default.fromJSON(this, state);\n\t\n\t        for (i = 0; i < this.nameTable.length; i++) {\n\t            this.nameTable[i].fromJSON(state.nameTable[i]);\n\t        }\n\t\n\t        for (i = 0; i < this.ptTile.length; i++) {\n\t            this.ptTile[i].fromJSON(state.ptTile[i]);\n\t        }\n\t\n\t        // Sprite data:\n\t        for (i = 0; i < this.spriteMem.length; i++) {\n\t            this.spriteRamWriteUpdate(i, this.spriteMem[i]);\n\t        }\n\t    }\n\t};\n\t\n\tPPU.NameTable = function (width, height, name) {\n\t    this.width = width;\n\t    this.height = height;\n\t    this.name = name;\n\t\n\t    this.tile = new Array(width * height);\n\t    this.attrib = new Array(width * height);\n\t};\n\t\n\tPPU.NameTable.prototype = {\n\t    getTileIndex: function getTileIndex(x, y) {\n\t        return this.tile[y * this.width + x];\n\t    },\n\t\n\t    getAttrib: function getAttrib(x, y) {\n\t        return this.attrib[y * this.width + x];\n\t    },\n\t\n\t    writeAttrib: function writeAttrib(index, value) {\n\t        var basex = index % 8 * 4;\n\t        var basey = Math.floor(index / 8) * 4;\n\t        var add;\n\t        var tx, ty;\n\t        var attindex;\n\t\n\t        for (var sqy = 0; sqy < 2; sqy++) {\n\t            for (var sqx = 0; sqx < 2; sqx++) {\n\t                add = value >> 2 * (sqy * 2 + sqx) & 3;\n\t                for (var y = 0; y < 2; y++) {\n\t                    for (var x = 0; x < 2; x++) {\n\t                        tx = basex + sqx * 2 + x;\n\t                        ty = basey + sqy * 2 + y;\n\t                        attindex = ty * this.width + tx;\n\t                        this.attrib[ty * this.width + tx] = add << 2 & 12;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    toJSON: function toJSON() {\n\t        return {\n\t            'tile': this.tile,\n\t            'attrib': this.attrib\n\t        };\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        this.tile = s.tile;\n\t        this.attrib = s.attrib;\n\t    }\n\t};\n\t\n\tPPU.PaletteTable = function () {\n\t    this.curTable = new Array(64);\n\t    this.emphTable = new Array(8);\n\t    this.currentEmph = -1;\n\t};\n\t\n\tPPU.PaletteTable.prototype = {\n\t    reset: function reset() {\n\t        this.setEmphasis(0);\n\t    },\n\t\n\t    loadNTSCPalette: function loadNTSCPalette() {\n\t        this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n\t        this.makeTables();\n\t        this.setEmphasis(0);\n\t    },\n\t\n\t    loadPALPalette: function loadPALPalette() {\n\t        this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n\t        this.makeTables();\n\t        this.setEmphasis(0);\n\t    },\n\t\n\t    makeTables: function makeTables() {\n\t        var r, g, b, col, i, rFactor, gFactor, bFactor;\n\t\n\t        // Calculate a table for each possible emphasis setting:\n\t        for (var emph = 0; emph < 8; emph++) {\n\t\n\t            // Determine color component factors:\n\t            rFactor = 1.0;\n\t            gFactor = 1.0;\n\t            bFactor = 1.0;\n\t\n\t            if ((emph & 1) !== 0) {\n\t                rFactor = 0.75;\n\t                bFactor = 0.75;\n\t            }\n\t            if ((emph & 2) !== 0) {\n\t                rFactor = 0.75;\n\t                gFactor = 0.75;\n\t            }\n\t            if ((emph & 4) !== 0) {\n\t                gFactor = 0.75;\n\t                bFactor = 0.75;\n\t            }\n\t\n\t            this.emphTable[emph] = new Array(64);\n\t\n\t            // Calculate table:\n\t            for (i = 0; i < 64; i++) {\n\t                col = this.curTable[i];\n\t                r = Math.floor(this.getRed(col) * rFactor);\n\t                g = Math.floor(this.getGreen(col) * gFactor);\n\t                b = Math.floor(this.getBlue(col) * bFactor);\n\t                this.emphTable[emph][i] = this.getRgb(r, g, b);\n\t            }\n\t        }\n\t    },\n\t\n\t    setEmphasis: function setEmphasis(emph) {\n\t        if (emph != this.currentEmph) {\n\t            this.currentEmph = emph;\n\t            for (var i = 0; i < 64; i++) {\n\t                this.curTable[i] = this.emphTable[emph][i];\n\t            }\n\t        }\n\t    },\n\t\n\t    getEntry: function getEntry(yiq) {\n\t        return this.curTable[yiq];\n\t    },\n\t\n\t    getRed: function getRed(rgb) {\n\t        return rgb >> 16 & 0xFF;\n\t    },\n\t\n\t    getGreen: function getGreen(rgb) {\n\t        return rgb >> 8 & 0xFF;\n\t    },\n\t\n\t    getBlue: function getBlue(rgb) {\n\t        return rgb & 0xFF;\n\t    },\n\t\n\t    getRgb: function getRgb(r, g, b) {\n\t        return r << 16 | g << 8 | b;\n\t    },\n\t\n\t    loadDefaultPalette: function loadDefaultPalette() {\n\t        this.curTable[0] = this.getRgb(117, 117, 117);\n\t        this.curTable[1] = this.getRgb(39, 27, 143);\n\t        this.curTable[2] = this.getRgb(0, 0, 171);\n\t        this.curTable[3] = this.getRgb(71, 0, 159);\n\t        this.curTable[4] = this.getRgb(143, 0, 119);\n\t        this.curTable[5] = this.getRgb(171, 0, 19);\n\t        this.curTable[6] = this.getRgb(167, 0, 0);\n\t        this.curTable[7] = this.getRgb(127, 11, 0);\n\t        this.curTable[8] = this.getRgb(67, 47, 0);\n\t        this.curTable[9] = this.getRgb(0, 71, 0);\n\t        this.curTable[10] = this.getRgb(0, 81, 0);\n\t        this.curTable[11] = this.getRgb(0, 63, 23);\n\t        this.curTable[12] = this.getRgb(27, 63, 95);\n\t        this.curTable[13] = this.getRgb(0, 0, 0);\n\t        this.curTable[14] = this.getRgb(0, 0, 0);\n\t        this.curTable[15] = this.getRgb(0, 0, 0);\n\t        this.curTable[16] = this.getRgb(188, 188, 188);\n\t        this.curTable[17] = this.getRgb(0, 115, 239);\n\t        this.curTable[18] = this.getRgb(35, 59, 239);\n\t        this.curTable[19] = this.getRgb(131, 0, 243);\n\t        this.curTable[20] = this.getRgb(191, 0, 191);\n\t        this.curTable[21] = this.getRgb(231, 0, 91);\n\t        this.curTable[22] = this.getRgb(219, 43, 0);\n\t        this.curTable[23] = this.getRgb(203, 79, 15);\n\t        this.curTable[24] = this.getRgb(139, 115, 0);\n\t        this.curTable[25] = this.getRgb(0, 151, 0);\n\t        this.curTable[26] = this.getRgb(0, 171, 0);\n\t        this.curTable[27] = this.getRgb(0, 147, 59);\n\t        this.curTable[28] = this.getRgb(0, 131, 139);\n\t        this.curTable[29] = this.getRgb(0, 0, 0);\n\t        this.curTable[30] = this.getRgb(0, 0, 0);\n\t        this.curTable[31] = this.getRgb(0, 0, 0);\n\t        this.curTable[32] = this.getRgb(255, 255, 255);\n\t        this.curTable[33] = this.getRgb(63, 191, 255);\n\t        this.curTable[34] = this.getRgb(95, 151, 255);\n\t        this.curTable[35] = this.getRgb(167, 139, 253);\n\t        this.curTable[36] = this.getRgb(247, 123, 255);\n\t        this.curTable[37] = this.getRgb(255, 119, 183);\n\t        this.curTable[38] = this.getRgb(255, 119, 99);\n\t        this.curTable[39] = this.getRgb(255, 155, 59);\n\t        this.curTable[40] = this.getRgb(243, 191, 63);\n\t        this.curTable[41] = this.getRgb(131, 211, 19);\n\t        this.curTable[42] = this.getRgb(79, 223, 75);\n\t        this.curTable[43] = this.getRgb(88, 248, 152);\n\t        this.curTable[44] = this.getRgb(0, 235, 219);\n\t        this.curTable[45] = this.getRgb(0, 0, 0);\n\t        this.curTable[46] = this.getRgb(0, 0, 0);\n\t        this.curTable[47] = this.getRgb(0, 0, 0);\n\t        this.curTable[48] = this.getRgb(255, 255, 255);\n\t        this.curTable[49] = this.getRgb(171, 231, 255);\n\t        this.curTable[50] = this.getRgb(199, 215, 255);\n\t        this.curTable[51] = this.getRgb(215, 203, 255);\n\t        this.curTable[52] = this.getRgb(255, 199, 255);\n\t        this.curTable[53] = this.getRgb(255, 199, 219);\n\t        this.curTable[54] = this.getRgb(255, 191, 179);\n\t        this.curTable[55] = this.getRgb(255, 219, 171);\n\t        this.curTable[56] = this.getRgb(255, 231, 163);\n\t        this.curTable[57] = this.getRgb(227, 255, 163);\n\t        this.curTable[58] = this.getRgb(171, 243, 191);\n\t        this.curTable[59] = this.getRgb(179, 255, 207);\n\t        this.curTable[60] = this.getRgb(159, 255, 243);\n\t        this.curTable[61] = this.getRgb(0, 0, 0);\n\t        this.curTable[62] = this.getRgb(0, 0, 0);\n\t        this.curTable[63] = this.getRgb(0, 0, 0);\n\t\n\t        this.makeTables();\n\t        this.setEmphasis(0);\n\t    }\n\t};\n\t\n\tPPU.Tile = function () {\n\t    // Tile data:\n\t    this.pix = new Array(64);\n\t\n\t    this.fbIndex = null;\n\t    this.tIndex = null;\n\t    this.x = null;\n\t    this.y = null;\n\t    this.w = null;\n\t    this.h = null;\n\t    this.incX = null;\n\t    this.incY = null;\n\t    this.palIndex = null;\n\t    this.tpri = null;\n\t    this.c = null;\n\t    this.initialized = false;\n\t    this.opaque = new Array(8);\n\t};\n\t\n\tPPU.Tile.prototype = {\n\t    setBuffer: function setBuffer(scanline) {\n\t        for (this.y = 0; this.y < 8; this.y++) {\n\t            this.setScanline(this.y, scanline[this.y], scanline[this.y + 8]);\n\t        }\n\t    },\n\t\n\t    setScanline: function setScanline(sline, b1, b2) {\n\t        this.initialized = true;\n\t        this.tIndex = sline << 3;\n\t        for (this.x = 0; this.x < 8; this.x++) {\n\t            this.pix[this.tIndex + this.x] = (b1 >> 7 - this.x & 1) + ((b2 >> 7 - this.x & 1) << 1);\n\t            if (this.pix[this.tIndex + this.x] === 0) {\n\t                this.opaque[sline] = false;\n\t            }\n\t        }\n\t    },\n\t\n\t    render: function render(buffer, srcx1, srcy1, srcx2, srcy2, dx, dy, palAdd, palette, flipHorizontal, flipVertical, pri, priTable) {\n\t\n\t        if (dx < -7 || dx >= 256 || dy < -7 || dy >= 240) {\n\t            return;\n\t        }\n\t\n\t        this.w = srcx2 - srcx1;\n\t        this.h = srcy2 - srcy1;\n\t\n\t        if (dx < 0) {\n\t            srcx1 -= dx;\n\t        }\n\t        if (dx + srcx2 >= 256) {\n\t            srcx2 = 256 - dx;\n\t        }\n\t\n\t        if (dy < 0) {\n\t            srcy1 -= dy;\n\t        }\n\t        if (dy + srcy2 >= 240) {\n\t            srcy2 = 240 - dy;\n\t        }\n\t\n\t        if (!flipHorizontal && !flipVertical) {\n\t\n\t            this.fbIndex = (dy << 8) + dx;\n\t            this.tIndex = 0;\n\t            for (this.y = 0; this.y < 8; this.y++) {\n\t                for (this.x = 0; this.x < 8; this.x++) {\n\t                    if (this.x >= srcx1 && this.x < srcx2 && this.y >= srcy1 && this.y < srcy2) {\n\t                        this.palIndex = this.pix[this.tIndex];\n\t                        this.tpri = priTable[this.fbIndex];\n\t                        if (this.palIndex !== 0 && pri <= (this.tpri & 0xFF)) {\n\t                            //console.log(\"Rendering upright tile to buffer\");\n\t                            buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n\t                            this.tpri = this.tpri & 0xF00 | pri;\n\t                            priTable[this.fbIndex] = this.tpri;\n\t                        }\n\t                    }\n\t                    this.fbIndex++;\n\t                    this.tIndex++;\n\t                }\n\t                this.fbIndex -= 8;\n\t                this.fbIndex += 256;\n\t            }\n\t        } else if (flipHorizontal && !flipVertical) {\n\t\n\t            this.fbIndex = (dy << 8) + dx;\n\t            this.tIndex = 7;\n\t            for (this.y = 0; this.y < 8; this.y++) {\n\t                for (this.x = 0; this.x < 8; this.x++) {\n\t                    if (this.x >= srcx1 && this.x < srcx2 && this.y >= srcy1 && this.y < srcy2) {\n\t                        this.palIndex = this.pix[this.tIndex];\n\t                        this.tpri = priTable[this.fbIndex];\n\t                        if (this.palIndex !== 0 && pri <= (this.tpri & 0xFF)) {\n\t                            buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n\t                            this.tpri = this.tpri & 0xF00 | pri;\n\t                            priTable[this.fbIndex] = this.tpri;\n\t                        }\n\t                    }\n\t                    this.fbIndex++;\n\t                    this.tIndex--;\n\t                }\n\t                this.fbIndex -= 8;\n\t                this.fbIndex += 256;\n\t                this.tIndex += 16;\n\t            }\n\t        } else if (flipVertical && !flipHorizontal) {\n\t\n\t            this.fbIndex = (dy << 8) + dx;\n\t            this.tIndex = 56;\n\t            for (this.y = 0; this.y < 8; this.y++) {\n\t                for (this.x = 0; this.x < 8; this.x++) {\n\t                    if (this.x >= srcx1 && this.x < srcx2 && this.y >= srcy1 && this.y < srcy2) {\n\t                        this.palIndex = this.pix[this.tIndex];\n\t                        this.tpri = priTable[this.fbIndex];\n\t                        if (this.palIndex !== 0 && pri <= (this.tpri & 0xFF)) {\n\t                            buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n\t                            this.tpri = this.tpri & 0xF00 | pri;\n\t                            priTable[this.fbIndex] = this.tpri;\n\t                        }\n\t                    }\n\t                    this.fbIndex++;\n\t                    this.tIndex++;\n\t                }\n\t                this.fbIndex -= 8;\n\t                this.fbIndex += 256;\n\t                this.tIndex -= 16;\n\t            }\n\t        } else {\n\t            this.fbIndex = (dy << 8) + dx;\n\t            this.tIndex = 63;\n\t            for (this.y = 0; this.y < 8; this.y++) {\n\t                for (this.x = 0; this.x < 8; this.x++) {\n\t                    if (this.x >= srcx1 && this.x < srcx2 && this.y >= srcy1 && this.y < srcy2) {\n\t                        this.palIndex = this.pix[this.tIndex];\n\t                        this.tpri = priTable[this.fbIndex];\n\t                        if (this.palIndex !== 0 && pri <= (this.tpri & 0xFF)) {\n\t                            buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n\t                            this.tpri = this.tpri & 0xF00 | pri;\n\t                            priTable[this.fbIndex] = this.tpri;\n\t                        }\n\t                    }\n\t                    this.fbIndex++;\n\t                    this.tIndex--;\n\t                }\n\t                this.fbIndex -= 8;\n\t                this.fbIndex += 256;\n\t            }\n\t        }\n\t    },\n\t\n\t    isTransparent: function isTransparent(x, y) {\n\t        return this.pix[(y << 3) + x] === 0;\n\t    },\n\t\n\t    toJSON: function toJSON() {\n\t        return {\n\t            'opaque': this.opaque,\n\t            'pix': this.pix\n\t        };\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        this.opaque = s.opaque;\n\t        this.pix = s.pix;\n\t    }\n\t};\n\t\n\texports.default = PPU;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\tvar PAPU = function PAPU(nes) {\n\t    this.nes = nes;\n\t\n\t    this.square1 = new PAPU.ChannelSquare(this, true);\n\t    this.square2 = new PAPU.ChannelSquare(this, false);\n\t    this.triangle = new PAPU.ChannelTriangle(this);\n\t    this.noise = new PAPU.ChannelNoise(this);\n\t    this.dmc = new PAPU.ChannelDM(this);\n\t\n\t    this.frameIrqCounter = null;\n\t    this.frameIrqCounterMax = 4;\n\t    this.initCounter = 2048;\n\t    this.channelEnableValue = null;\n\t\n\t    this.bufferSize = 8192;\n\t    this.bufferIndex = 0;\n\t    this.sampleRate = 44100;\n\t\n\t    this.lengthLookup = null;\n\t    this.dmcFreqLookup = null;\n\t    this.noiseWavelengthLookup = null;\n\t    this.square_table = null;\n\t    this.tnd_table = null;\n\t    this.sampleBuffer = new Array(this.bufferSize * 2);\n\t\n\t    this.frameIrqEnabled = false;\n\t    this.frameIrqActive = null;\n\t    this.frameClockNow = null;\n\t    this.startedPlaying = false;\n\t    this.recordOutput = false;\n\t    this.initingHardware = false;\n\t\n\t    this.masterFrameCounter = null;\n\t    this.derivedFrameCounter = null;\n\t    this.countSequence = null;\n\t    this.sampleTimer = null;\n\t    this.frameTime = null;\n\t    this.sampleTimerMax = null;\n\t    this.sampleCount = null;\n\t    this.triValue = 0;\n\t\n\t    this.smpSquare1 = null;\n\t    this.smpSquare2 = null;\n\t    this.smpTriangle = null;\n\t    this.smpDmc = null;\n\t    this.accCount = null;\n\t\n\t    // DC removal vars:\n\t    this.prevSampleL = 0;\n\t    this.prevSampleR = 0;\n\t    this.smpAccumL = 0;\n\t    this.smpAccumR = 0;\n\t\n\t    // DAC range:\n\t    this.dacRange = 0;\n\t    this.dcValue = 0;\n\t\n\t    // Master volume:\n\t    this.masterVolume = 256;\n\t\n\t    // Stereo positioning:\n\t    this.stereoPosLSquare1 = null;\n\t    this.stereoPosLSquare2 = null;\n\t    this.stereoPosLTriangle = null;\n\t    this.stereoPosLNoise = null;\n\t    this.stereoPosLDMC = null;\n\t    this.stereoPosRSquare1 = null;\n\t    this.stereoPosRSquare2 = null;\n\t    this.stereoPosRTriangle = null;\n\t    this.stereoPosRNoise = null;\n\t    this.stereoPosRDMC = null;\n\t\n\t    this.extraCycles = null;\n\t\n\t    this.maxSample = null;\n\t    this.minSample = null;\n\t\n\t    // Panning:\n\t    this.panning = [80, 170, 100, 150, 128];\n\t    this.setPanning(this.panning);\n\t\n\t    // Initialize lookup tables:\n\t    this.initLengthLookup();\n\t    this.initDmcFrequencyLookup();\n\t    this.initNoiseWavelengthLookup();\n\t    this.initDACtables();\n\t\n\t    // Init sound registers:\n\t    for (var i = 0; i < 0x14; i++) {\n\t        if (i === 0x10) {\n\t            this.writeReg(0x4010, 0x10);\n\t        } else {\n\t            this.writeReg(0x4000 + i, 0);\n\t        }\n\t    }\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.prototype = {\n\t    reset: function reset() {\n\t        this.sampleRate = this.nes.opts.sampleRate;\n\t        this.sampleTimerMax = Math.floor(1024.0 * this.nes.opts.CPU_FREQ_NTSC * this.nes.opts.preferredFrameRate / (this.sampleRate * 60.0));\n\t\n\t        this.frameTime = Math.floor(14915.0 * this.nes.opts.preferredFrameRate / 60.0);\n\t\n\t        this.sampleTimer = 0;\n\t        this.bufferIndex = 0;\n\t\n\t        this.updateChannelEnable(0);\n\t        this.masterFrameCounter = 0;\n\t        this.derivedFrameCounter = 0;\n\t        this.countSequence = 0;\n\t        this.sampleCount = 0;\n\t        this.initCounter = 2048;\n\t        this.frameIrqEnabled = false;\n\t        this.initingHardware = false;\n\t\n\t        this.resetCounter();\n\t\n\t        this.square1.reset();\n\t        this.square2.reset();\n\t        this.triangle.reset();\n\t        this.noise.reset();\n\t        this.dmc.reset();\n\t\n\t        this.bufferIndex = 0;\n\t        this.accCount = 0;\n\t        this.smpSquare1 = 0;\n\t        this.smpSquare2 = 0;\n\t        this.smpTriangle = 0;\n\t        this.smpDmc = 0;\n\t\n\t        this.frameIrqEnabled = false;\n\t        this.frameIrqCounterMax = 4;\n\t\n\t        this.channelEnableValue = 0xFF;\n\t        this.startedPlaying = false;\n\t        this.prevSampleL = 0;\n\t        this.prevSampleR = 0;\n\t        this.smpAccumL = 0;\n\t        this.smpAccumR = 0;\n\t\n\t        this.maxSample = -500000;\n\t        this.minSample = 500000;\n\t    },\n\t\n\t    readReg: function readReg(address) {\n\t        // Read 0x4015:\n\t        var tmp = 0;\n\t        tmp |= this.square1.getLengthStatus();\n\t        tmp |= this.square2.getLengthStatus() << 1;\n\t        tmp |= this.triangle.getLengthStatus() << 2;\n\t        tmp |= this.noise.getLengthStatus() << 3;\n\t        tmp |= this.dmc.getLengthStatus() << 4;\n\t        tmp |= (this.frameIrqActive && this.frameIrqEnabled ? 1 : 0) << 6;\n\t        tmp |= this.dmc.getIrqStatus() << 7;\n\t\n\t        this.frameIrqActive = false;\n\t        this.dmc.irqGenerated = false;\n\t\n\t        return tmp & 0xFFFF;\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        if (address >= 0x4000 && address < 0x4004) {\n\t            // Square Wave 1 Control\n\t            this.square1.writeReg(address, value);\n\t            ////System.out.println(\"Square Write\");\n\t        } else if (address >= 0x4004 && address < 0x4008) {\n\t                // Square 2 Control\n\t                this.square2.writeReg(address, value);\n\t            } else if (address >= 0x4008 && address < 0x400C) {\n\t                // Triangle Control\n\t                this.triangle.writeReg(address, value);\n\t            } else if (address >= 0x400C && address <= 0x400F) {\n\t                // Noise Control\n\t                this.noise.writeReg(address, value);\n\t            } else if (address === 0x4010) {\n\t                // DMC Play mode & DMA frequency\n\t                this.dmc.writeReg(address, value);\n\t            } else if (address === 0x4011) {\n\t                // DMC Delta Counter\n\t                this.dmc.writeReg(address, value);\n\t            } else if (address === 0x4012) {\n\t                // DMC Play code starting address\n\t                this.dmc.writeReg(address, value);\n\t            } else if (address === 0x4013) {\n\t                // DMC Play code length\n\t                this.dmc.writeReg(address, value);\n\t            } else if (address === 0x4015) {\n\t                // Channel enable\n\t                this.updateChannelEnable(value);\n\t\n\t                if (value !== 0 && this.initCounter > 0) {\n\t                    // Start hardware initialization\n\t                    this.initingHardware = true;\n\t                }\n\t\n\t                // DMC/IRQ Status\n\t                this.dmc.writeReg(address, value);\n\t            } else if (address === 0x4017) {\n\t                // Frame counter control\n\t                this.countSequence = value >> 7 & 1;\n\t                this.masterFrameCounter = 0;\n\t                this.frameIrqActive = false;\n\t\n\t                if ((value >> 6 & 0x1) === 0) {\n\t                    this.frameIrqEnabled = true;\n\t                } else {\n\t                    this.frameIrqEnabled = false;\n\t                }\n\t\n\t                if (this.countSequence === 0) {\n\t                    // NTSC:\n\t                    this.frameIrqCounterMax = 4;\n\t                    this.derivedFrameCounter = 4;\n\t                } else {\n\t                    // PAL:\n\t                    this.frameIrqCounterMax = 5;\n\t                    this.derivedFrameCounter = 0;\n\t                    this.frameCounterTick();\n\t                }\n\t            }\n\t    },\n\t\n\t    resetCounter: function resetCounter() {\n\t        if (this.countSequence === 0) {\n\t            this.derivedFrameCounter = 4;\n\t        } else {\n\t            this.derivedFrameCounter = 0;\n\t        }\n\t    },\n\t\n\t    // Updates channel enable status.\n\t    // This is done on writes to the\n\t    // channel enable register (0x4015),\n\t    // and when the user enables/disables channels\n\t    // in the GUI.\n\t    updateChannelEnable: function updateChannelEnable(value) {\n\t        this.channelEnableValue = value & 0xFFFF;\n\t        this.square1.setEnabled((value & 1) !== 0);\n\t        this.square2.setEnabled((value & 2) !== 0);\n\t        this.triangle.setEnabled((value & 4) !== 0);\n\t        this.noise.setEnabled((value & 8) !== 0);\n\t        this.dmc.setEnabled((value & 16) !== 0);\n\t    },\n\t\n\t    // Clocks the frame counter. It should be clocked at\n\t    // twice the cpu speed, so the cycles will be\n\t    // divided by 2 for those counters that are\n\t    // clocked at cpu speed.\n\t    clockFrameCounter: function clockFrameCounter(nCycles) {\n\t        if (this.initCounter > 0) {\n\t            if (this.initingHardware) {\n\t                this.initCounter -= nCycles;\n\t                if (this.initCounter <= 0) {\n\t                    this.initingHardware = false;\n\t                }\n\t                return;\n\t            }\n\t        }\n\t\n\t        // Don't process ticks beyond next sampling:\n\t        nCycles += this.extraCycles;\n\t        var maxCycles = this.sampleTimerMax - this.sampleTimer;\n\t        if (nCycles << 10 > maxCycles) {\n\t\n\t            this.extraCycles = (nCycles << 10) - maxCycles >> 10;\n\t            nCycles -= this.extraCycles;\n\t        } else {\n\t\n\t            this.extraCycles = 0;\n\t        }\n\t\n\t        var dmc = this.dmc;\n\t        var triangle = this.triangle;\n\t        var square1 = this.square1;\n\t        var square2 = this.square2;\n\t        var noise = this.noise;\n\t\n\t        // Clock DMC:\n\t        if (dmc.isEnabled) {\n\t\n\t            dmc.shiftCounter -= nCycles << 3;\n\t            while (dmc.shiftCounter <= 0 && dmc.dmaFrequency > 0) {\n\t                dmc.shiftCounter += dmc.dmaFrequency;\n\t                dmc.clockDmc();\n\t            }\n\t        }\n\t\n\t        // Clock Triangle channel Prog timer:\n\t        if (triangle.progTimerMax > 0) {\n\t\n\t            triangle.progTimerCount -= nCycles;\n\t            while (triangle.progTimerCount <= 0) {\n\t\n\t                triangle.progTimerCount += triangle.progTimerMax + 1;\n\t                if (triangle.linearCounter > 0 && triangle.lengthCounter > 0) {\n\t\n\t                    triangle.triangleCounter++;\n\t                    triangle.triangleCounter &= 0x1F;\n\t\n\t                    if (triangle.isEnabled) {\n\t                        if (triangle.triangleCounter >= 0x10) {\n\t                            // Normal value.\n\t                            triangle.sampleValue = triangle.triangleCounter & 0xF;\n\t                        } else {\n\t                            // Inverted value.\n\t                            triangle.sampleValue = 0xF - (triangle.triangleCounter & 0xF);\n\t                        }\n\t                        triangle.sampleValue <<= 4;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // Clock Square channel 1 Prog timer:\n\t        square1.progTimerCount -= nCycles;\n\t        if (square1.progTimerCount <= 0) {\n\t\n\t            square1.progTimerCount += square1.progTimerMax + 1 << 1;\n\t\n\t            square1.squareCounter++;\n\t            square1.squareCounter &= 0x7;\n\t            square1.updateSampleValue();\n\t        }\n\t\n\t        // Clock Square channel 2 Prog timer:\n\t        square2.progTimerCount -= nCycles;\n\t        if (square2.progTimerCount <= 0) {\n\t\n\t            square2.progTimerCount += square2.progTimerMax + 1 << 1;\n\t\n\t            square2.squareCounter++;\n\t            square2.squareCounter &= 0x7;\n\t            square2.updateSampleValue();\n\t        }\n\t\n\t        // Clock noise channel Prog timer:\n\t        var acc_c = nCycles;\n\t        if (noise.progTimerCount - acc_c > 0) {\n\t\n\t            // Do all cycles at once:\n\t            noise.progTimerCount -= acc_c;\n\t            noise.accCount += acc_c;\n\t            noise.accValue += acc_c * noise.sampleValue;\n\t        } else {\n\t\n\t            // Slow-step:\n\t            while (acc_c-- > 0) {\n\t\n\t                if (--noise.progTimerCount <= 0 && noise.progTimerMax > 0) {\n\t\n\t                    // Update noise shift register:\n\t                    noise.shiftReg <<= 1;\n\t                    noise.tmp = (noise.shiftReg << (noise.randomMode === 0 ? 1 : 6) ^ noise.shiftReg) & 0x8000;\n\t                    if (noise.tmp !== 0) {\n\t\n\t                        // Sample value must be 0.\n\t                        noise.shiftReg |= 0x01;\n\t                        noise.randomBit = 0;\n\t                        noise.sampleValue = 0;\n\t                    } else {\n\t\n\t                        // Find sample value:\n\t                        noise.randomBit = 1;\n\t                        if (noise.isEnabled && noise.lengthCounter > 0) {\n\t                            noise.sampleValue = noise.masterVolume;\n\t                        } else {\n\t                            noise.sampleValue = 0;\n\t                        }\n\t                    }\n\t\n\t                    noise.progTimerCount += noise.progTimerMax;\n\t                }\n\t\n\t                noise.accValue += noise.sampleValue;\n\t                noise.accCount++;\n\t            }\n\t        }\n\t\n\t        // Frame IRQ handling:\n\t        if (this.frameIrqEnabled && this.frameIrqActive) {\n\t            this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n\t        }\n\t\n\t        // Clock frame counter at double CPU speed:\n\t        this.masterFrameCounter += nCycles << 1;\n\t        if (this.masterFrameCounter >= this.frameTime) {\n\t            // 240Hz tick:\n\t            this.masterFrameCounter -= this.frameTime;\n\t            this.frameCounterTick();\n\t        }\n\t\n\t        // Accumulate sample value:\n\t        this.accSample(nCycles);\n\t\n\t        // Clock sample timer:\n\t        this.sampleTimer += nCycles << 10;\n\t        if (this.sampleTimer >= this.sampleTimerMax) {\n\t            // Sample channels:\n\t            this.sample();\n\t            this.sampleTimer -= this.sampleTimerMax;\n\t        }\n\t    },\n\t\n\t    accSample: function accSample(cycles) {\n\t        // Special treatment for triangle channel - need to interpolate.\n\t        if (this.triangle.sampleCondition) {\n\t            this.triValue = Math.floor((this.triangle.progTimerCount << 4) / (this.triangle.progTimerMax + 1));\n\t            if (this.triValue > 16) {\n\t                this.triValue = 16;\n\t            }\n\t            if (this.triangle.triangleCounter >= 16) {\n\t                this.triValue = 16 - this.triValue;\n\t            }\n\t\n\t            // Add non-interpolated sample value:\n\t            this.triValue += this.triangle.sampleValue;\n\t        }\n\t\n\t        // Now sample normally:\n\t        if (cycles === 2) {\n\t\n\t            this.smpTriangle += this.triValue << 1;\n\t            this.smpDmc += this.dmc.sample << 1;\n\t            this.smpSquare1 += this.square1.sampleValue << 1;\n\t            this.smpSquare2 += this.square2.sampleValue << 1;\n\t            this.accCount += 2;\n\t        } else if (cycles === 4) {\n\t\n\t            this.smpTriangle += this.triValue << 2;\n\t            this.smpDmc += this.dmc.sample << 2;\n\t            this.smpSquare1 += this.square1.sampleValue << 2;\n\t            this.smpSquare2 += this.square2.sampleValue << 2;\n\t            this.accCount += 4;\n\t        } else {\n\t\n\t            this.smpTriangle += cycles * this.triValue;\n\t            this.smpDmc += cycles * this.dmc.sample;\n\t            this.smpSquare1 += cycles * this.square1.sampleValue;\n\t            this.smpSquare2 += cycles * this.square2.sampleValue;\n\t            this.accCount += cycles;\n\t        }\n\t    },\n\t\n\t    frameCounterTick: function frameCounterTick() {\n\t\n\t        this.derivedFrameCounter++;\n\t        if (this.derivedFrameCounter >= this.frameIrqCounterMax) {\n\t            this.derivedFrameCounter = 0;\n\t        }\n\t\n\t        if (this.derivedFrameCounter === 1 || this.derivedFrameCounter === 3) {\n\t\n\t            // Clock length & sweep:\n\t            this.triangle.clockLengthCounter();\n\t            this.square1.clockLengthCounter();\n\t            this.square2.clockLengthCounter();\n\t            this.noise.clockLengthCounter();\n\t            this.square1.clockSweep();\n\t            this.square2.clockSweep();\n\t        }\n\t\n\t        if (this.derivedFrameCounter >= 0 && this.derivedFrameCounter < 4) {\n\t\n\t            // Clock linear & decay:\n\t            this.square1.clockEnvDecay();\n\t            this.square2.clockEnvDecay();\n\t            this.noise.clockEnvDecay();\n\t            this.triangle.clockLinearCounter();\n\t        }\n\t\n\t        if (this.derivedFrameCounter === 3 && this.countSequence === 0) {\n\t\n\t            // Enable IRQ:\n\t            this.frameIrqActive = true;\n\t        }\n\t\n\t        // End of 240Hz tick\n\t    },\n\t\n\t    // Samples the channels, mixes the output together,\n\t    // writes to buffer and (if enabled) file.\n\t    sample: function sample() {\n\t        var sq_index, tnd_index;\n\t\n\t        if (this.accCount > 0) {\n\t\n\t            this.smpSquare1 <<= 4;\n\t            this.smpSquare1 = Math.floor(this.smpSquare1 / this.accCount);\n\t\n\t            this.smpSquare2 <<= 4;\n\t            this.smpSquare2 = Math.floor(this.smpSquare2 / this.accCount);\n\t\n\t            this.smpTriangle = Math.floor(this.smpTriangle / this.accCount);\n\t\n\t            this.smpDmc <<= 4;\n\t            this.smpDmc = Math.floor(this.smpDmc / this.accCount);\n\t\n\t            this.accCount = 0;\n\t        } else {\n\t            this.smpSquare1 = this.square1.sampleValue << 4;\n\t            this.smpSquare2 = this.square2.sampleValue << 4;\n\t            this.smpTriangle = this.triangle.sampleValue;\n\t            this.smpDmc = this.dmc.sample << 4;\n\t        }\n\t\n\t        var smpNoise = Math.floor((this.noise.accValue << 4) / this.noise.accCount);\n\t        this.noise.accValue = smpNoise >> 4;\n\t        this.noise.accCount = 1;\n\t\n\t        // Stereo sound.\n\t\n\t        // Left channel:\n\t        sq_index = this.smpSquare1 * this.stereoPosLSquare1 + this.smpSquare2 * this.stereoPosLSquare2 >> 8;\n\t        tnd_index = 3 * this.smpTriangle * this.stereoPosLTriangle + (smpNoise << 1) * this.stereoPosLNoise + this.smpDmc * this.stereoPosLDMC >> 8;\n\t        if (sq_index >= this.square_table.length) {\n\t            sq_index = this.square_table.length - 1;\n\t        }\n\t        if (tnd_index >= this.tnd_table.length) {\n\t            tnd_index = this.tnd_table.length - 1;\n\t        }\n\t        var sampleValueL = this.square_table[sq_index] + this.tnd_table[tnd_index] - this.dcValue;\n\t\n\t        // Right channel:\n\t        sq_index = this.smpSquare1 * this.stereoPosRSquare1 + this.smpSquare2 * this.stereoPosRSquare2 >> 8;\n\t        tnd_index = 3 * this.smpTriangle * this.stereoPosRTriangle + (smpNoise << 1) * this.stereoPosRNoise + this.smpDmc * this.stereoPosRDMC >> 8;\n\t        if (sq_index >= this.square_table.length) {\n\t            sq_index = this.square_table.length - 1;\n\t        }\n\t        if (tnd_index >= this.tnd_table.length) {\n\t            tnd_index = this.tnd_table.length - 1;\n\t        }\n\t        var sampleValueR = this.square_table[sq_index] + this.tnd_table[tnd_index] - this.dcValue;\n\t\n\t        // Remove DC from left channel:\n\t        var smpDiffL = sampleValueL - this.prevSampleL;\n\t        this.prevSampleL += smpDiffL;\n\t        this.smpAccumL += smpDiffL - (this.smpAccumL >> 10);\n\t        sampleValueL = this.smpAccumL;\n\t\n\t        // Remove DC from right channel:\n\t        var smpDiffR = sampleValueR - this.prevSampleR;\n\t        this.prevSampleR += smpDiffR;\n\t        this.smpAccumR += smpDiffR - (this.smpAccumR >> 10);\n\t        sampleValueR = this.smpAccumR;\n\t\n\t        // Write:\n\t        if (sampleValueL > this.maxSample) {\n\t            this.maxSample = sampleValueL;\n\t        }\n\t        if (sampleValueL < this.minSample) {\n\t            this.minSample = sampleValueL;\n\t        }\n\t        this.sampleBuffer[this.bufferIndex++] = sampleValueL;\n\t        this.sampleBuffer[this.bufferIndex++] = sampleValueR;\n\t\n\t        // Write full buffer\n\t        if (this.bufferIndex === this.sampleBuffer.length) {\n\t            this.nes.ui.writeAudio(this.sampleBuffer);\n\t            this.sampleBuffer = new Array(this.bufferSize * 2);\n\t            this.bufferIndex = 0;\n\t        }\n\t\n\t        // Reset sampled values:\n\t        this.smpSquare1 = 0;\n\t        this.smpSquare2 = 0;\n\t        this.smpTriangle = 0;\n\t        this.smpDmc = 0;\n\t    },\n\t\n\t    getLengthMax: function getLengthMax(value) {\n\t        return this.lengthLookup[value >> 3];\n\t    },\n\t\n\t    getDmcFrequency: function getDmcFrequency(value) {\n\t        if (value >= 0 && value < 0x10) {\n\t            return this.dmcFreqLookup[value];\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    getNoiseWaveLength: function getNoiseWaveLength(value) {\n\t        if (value >= 0 && value < 0x10) {\n\t            return this.noiseWavelengthLookup[value];\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    setPanning: function setPanning(pos) {\n\t        for (var i = 0; i < 5; i++) {\n\t            this.panning[i] = pos[i];\n\t        }\n\t        this.updateStereoPos();\n\t    },\n\t\n\t    setMasterVolume: function setMasterVolume(value) {\n\t        if (value < 0) {\n\t            value = 0;\n\t        }\n\t        if (value > 256) {\n\t            value = 256;\n\t        }\n\t        this.masterVolume = value;\n\t        this.updateStereoPos();\n\t    },\n\t\n\t    updateStereoPos: function updateStereoPos() {\n\t        this.stereoPosLSquare1 = this.panning[0] * this.masterVolume >> 8;\n\t        this.stereoPosLSquare2 = this.panning[1] * this.masterVolume >> 8;\n\t        this.stereoPosLTriangle = this.panning[2] * this.masterVolume >> 8;\n\t        this.stereoPosLNoise = this.panning[3] * this.masterVolume >> 8;\n\t        this.stereoPosLDMC = this.panning[4] * this.masterVolume >> 8;\n\t\n\t        this.stereoPosRSquare1 = this.masterVolume - this.stereoPosLSquare1;\n\t        this.stereoPosRSquare2 = this.masterVolume - this.stereoPosLSquare2;\n\t        this.stereoPosRTriangle = this.masterVolume - this.stereoPosLTriangle;\n\t        this.stereoPosRNoise = this.masterVolume - this.stereoPosLNoise;\n\t        this.stereoPosRDMC = this.masterVolume - this.stereoPosLDMC;\n\t    },\n\t\n\t    initLengthLookup: function initLengthLookup() {\n\t\n\t        this.lengthLookup = [0x0A, 0xFE, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06, 0xA0, 0x08, 0x3C, 0x0A, 0x0E, 0x0C, 0x1A, 0x0E, 0x0C, 0x10, 0x18, 0x12, 0x30, 0x14, 0x60, 0x16, 0xC0, 0x18, 0x48, 0x1A, 0x10, 0x1C, 0x20, 0x1E];\n\t    },\n\t\n\t    initDmcFrequencyLookup: function initDmcFrequencyLookup() {\n\t\n\t        this.dmcFreqLookup = new Array(16);\n\t\n\t        this.dmcFreqLookup[0x0] = 0xD60;\n\t        this.dmcFreqLookup[0x1] = 0xBE0;\n\t        this.dmcFreqLookup[0x2] = 0xAA0;\n\t        this.dmcFreqLookup[0x3] = 0xA00;\n\t        this.dmcFreqLookup[0x4] = 0x8F0;\n\t        this.dmcFreqLookup[0x5] = 0x7F0;\n\t        this.dmcFreqLookup[0x6] = 0x710;\n\t        this.dmcFreqLookup[0x7] = 0x6B0;\n\t        this.dmcFreqLookup[0x8] = 0x5F0;\n\t        this.dmcFreqLookup[0x9] = 0x500;\n\t        this.dmcFreqLookup[0xA] = 0x470;\n\t        this.dmcFreqLookup[0xB] = 0x400;\n\t        this.dmcFreqLookup[0xC] = 0x350;\n\t        this.dmcFreqLookup[0xD] = 0x2A0;\n\t        this.dmcFreqLookup[0xE] = 0x240;\n\t        this.dmcFreqLookup[0xF] = 0x1B0;\n\t        //for(int i=0;i<16;i++)dmcFreqLookup[i]/=8;\n\t    },\n\t\n\t    initNoiseWavelengthLookup: function initNoiseWavelengthLookup() {\n\t\n\t        this.noiseWavelengthLookup = new Array(16);\n\t\n\t        this.noiseWavelengthLookup[0x0] = 0x004;\n\t        this.noiseWavelengthLookup[0x1] = 0x008;\n\t        this.noiseWavelengthLookup[0x2] = 0x010;\n\t        this.noiseWavelengthLookup[0x3] = 0x020;\n\t        this.noiseWavelengthLookup[0x4] = 0x040;\n\t        this.noiseWavelengthLookup[0x5] = 0x060;\n\t        this.noiseWavelengthLookup[0x6] = 0x080;\n\t        this.noiseWavelengthLookup[0x7] = 0x0A0;\n\t        this.noiseWavelengthLookup[0x8] = 0x0CA;\n\t        this.noiseWavelengthLookup[0x9] = 0x0FE;\n\t        this.noiseWavelengthLookup[0xA] = 0x17C;\n\t        this.noiseWavelengthLookup[0xB] = 0x1FC;\n\t        this.noiseWavelengthLookup[0xC] = 0x2FA;\n\t        this.noiseWavelengthLookup[0xD] = 0x3F8;\n\t        this.noiseWavelengthLookup[0xE] = 0x7F2;\n\t        this.noiseWavelengthLookup[0xF] = 0xFE4;\n\t    },\n\t\n\t    initDACtables: function initDACtables() {\n\t        var value, ival, i;\n\t        var max_sqr = 0;\n\t        var max_tnd = 0;\n\t\n\t        this.square_table = new Array(32 * 16);\n\t        this.tnd_table = new Array(204 * 16);\n\t\n\t        for (i = 0; i < 32 * 16; i++) {\n\t            value = 95.52 / (8128.0 / (i / 16.0) + 100.0);\n\t            value *= 0.98411;\n\t            value *= 50000.0;\n\t            ival = Math.floor(value);\n\t\n\t            this.square_table[i] = ival;\n\t            if (ival > max_sqr) {\n\t                max_sqr = ival;\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < 204 * 16; i++) {\n\t            value = 163.67 / (24329.0 / (i / 16.0) + 100.0);\n\t            value *= 0.98411;\n\t            value *= 50000.0;\n\t            ival = Math.floor(value);\n\t\n\t            this.tnd_table[i] = ival;\n\t            if (ival > max_tnd) {\n\t                max_tnd = ival;\n\t            }\n\t        }\n\t\n\t        this.dacRange = max_sqr + max_tnd;\n\t        this.dcValue = this.dacRange / 2;\n\t    }\n\t};\n\t\n\tPAPU.ChannelDM = function (papu) {\n\t    this.papu = papu;\n\t\n\t    this.MODE_NORMAL = 0;\n\t    this.MODE_LOOP = 1;\n\t    this.MODE_IRQ = 2;\n\t\n\t    this.isEnabled = null;\n\t    this.hasSample = null;\n\t    this.irqGenerated = false;\n\t\n\t    this.playMode = null;\n\t    this.dmaFrequency = null;\n\t    this.dmaCounter = null;\n\t    this.deltaCounter = null;\n\t    this.playStartAddress = null;\n\t    this.playAddress = null;\n\t    this.playLength = null;\n\t    this.playLengthCounter = null;\n\t    this.shiftCounter = null;\n\t    this.reg4012 = null;\n\t    this.reg4013 = null;\n\t    this.sample = null;\n\t    this.dacLsb = null;\n\t    this.data = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.ChannelDM.prototype = {\n\t    clockDmc: function clockDmc() {\n\t\n\t        // Only alter DAC value if the sample buffer has data:\n\t        if (this.hasSample) {\n\t\n\t            if ((this.data & 1) === 0) {\n\t\n\t                // Decrement delta:\n\t                if (this.deltaCounter > 0) {\n\t                    this.deltaCounter--;\n\t                }\n\t            } else {\n\t                // Increment delta:\n\t                if (this.deltaCounter < 63) {\n\t                    this.deltaCounter++;\n\t                }\n\t            }\n\t\n\t            // Update sample value:\n\t            this.sample = this.isEnabled ? (this.deltaCounter << 1) + this.dacLsb : 0;\n\t\n\t            // Update shift register:\n\t            this.data >>= 1;\n\t        }\n\t\n\t        this.dmaCounter--;\n\t        if (this.dmaCounter <= 0) {\n\t\n\t            // No more sample bits.\n\t            this.hasSample = false;\n\t            this.endOfSample();\n\t            this.dmaCounter = 8;\n\t        }\n\t\n\t        if (this.irqGenerated) {\n\t            this.papu.nes.cpu.requestIrq(this.papu.nes.cpu.IRQ_NORMAL);\n\t        }\n\t    },\n\t\n\t    endOfSample: function endOfSample() {\n\t        if (this.playLengthCounter === 0 && this.playMode === this.MODE_LOOP) {\n\t\n\t            // Start from beginning of sample:\n\t            this.playAddress = this.playStartAddress;\n\t            this.playLengthCounter = this.playLength;\n\t        }\n\t\n\t        if (this.playLengthCounter > 0) {\n\t\n\t            // Fetch next sample:\n\t            this.nextSample();\n\t\n\t            if (this.playLengthCounter === 0) {\n\t\n\t                // Last byte of sample fetched, generate IRQ:\n\t                if (this.playMode === this.MODE_IRQ) {\n\t\n\t                    // Generate IRQ:\n\t                    this.irqGenerated = true;\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    nextSample: function nextSample() {\n\t        // Fetch byte:\n\t        this.data = this.papu.nes.mmap.load(this.playAddress);\n\t        this.papu.nes.cpu.haltCycles(4);\n\t\n\t        this.playLengthCounter--;\n\t        this.playAddress++;\n\t        if (this.playAddress > 0xFFFF) {\n\t            this.playAddress = 0x8000;\n\t        }\n\t\n\t        this.hasSample = true;\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        if (address === 0x4010) {\n\t\n\t            // Play mode, DMA Frequency\n\t            if (value >> 6 === 0) {\n\t                this.playMode = this.MODE_NORMAL;\n\t            } else if ((value >> 6 & 1) === 1) {\n\t                this.playMode = this.MODE_LOOP;\n\t            } else if (value >> 6 === 2) {\n\t                this.playMode = this.MODE_IRQ;\n\t            }\n\t\n\t            if ((value & 0x80) === 0) {\n\t                this.irqGenerated = false;\n\t            }\n\t\n\t            this.dmaFrequency = this.papu.getDmcFrequency(value & 0xF);\n\t        } else if (address === 0x4011) {\n\t\n\t            // Delta counter load register:\n\t            this.deltaCounter = value >> 1 & 63;\n\t            this.dacLsb = value & 1;\n\t            this.sample = (this.deltaCounter << 1) + this.dacLsb; // update sample value\n\t        } else if (address === 0x4012) {\n\t\n\t                // DMA address load register\n\t                this.playStartAddress = value << 6 | 0x0C000;\n\t                this.playAddress = this.playStartAddress;\n\t                this.reg4012 = value;\n\t            } else if (address === 0x4013) {\n\t\n\t                // Length of play code\n\t                this.playLength = (value << 4) + 1;\n\t                this.playLengthCounter = this.playLength;\n\t                this.reg4013 = value;\n\t            } else if (address === 0x4015) {\n\t\n\t                // DMC/IRQ Status\n\t                if ((value >> 4 & 1) === 0) {\n\t                    // Disable:\n\t                    this.playLengthCounter = 0;\n\t                } else {\n\t                    // Restart:\n\t                    this.playAddress = this.playStartAddress;\n\t                    this.playLengthCounter = this.playLength;\n\t                }\n\t                this.irqGenerated = false;\n\t            }\n\t    },\n\t\n\t    setEnabled: function setEnabled(value) {\n\t        if (!this.isEnabled && value) {\n\t            this.playLengthCounter = this.playLength;\n\t        }\n\t        this.isEnabled = value;\n\t    },\n\t\n\t    getLengthStatus: function getLengthStatus() {\n\t        return this.playLengthCounter === 0 || !this.isEnabled ? 0 : 1;\n\t    },\n\t\n\t    getIrqStatus: function getIrqStatus() {\n\t        return this.irqGenerated ? 1 : 0;\n\t    },\n\t\n\t    reset: function reset() {\n\t        this.isEnabled = false;\n\t        this.irqGenerated = false;\n\t        this.playMode = this.MODE_NORMAL;\n\t        this.dmaFrequency = 0;\n\t        this.dmaCounter = 0;\n\t        this.deltaCounter = 0;\n\t        this.playStartAddress = 0;\n\t        this.playAddress = 0;\n\t        this.playLength = 0;\n\t        this.playLengthCounter = 0;\n\t        this.sample = 0;\n\t        this.dacLsb = 0;\n\t        this.shiftCounter = 0;\n\t        this.reg4012 = 0;\n\t        this.reg4013 = 0;\n\t        this.data = 0;\n\t    }\n\t};\n\t\n\tPAPU.ChannelNoise = function (papu) {\n\t    this.papu = papu;\n\t\n\t    this.isEnabled = null;\n\t    this.envDecayDisable = null;\n\t    this.envDecayLoopEnable = null;\n\t    this.lengthCounterEnable = null;\n\t    this.envReset = null;\n\t    this.shiftNow = null;\n\t\n\t    this.lengthCounter = null;\n\t    this.progTimerCount = null;\n\t    this.progTimerMax = null;\n\t    this.envDecayRate = null;\n\t    this.envDecayCounter = null;\n\t    this.envVolume = null;\n\t    this.masterVolume = null;\n\t    this.shiftReg = 1 << 14;\n\t    this.randomBit = null;\n\t    this.randomMode = null;\n\t    this.sampleValue = null;\n\t    this.accValue = 0;\n\t    this.accCount = 1;\n\t    this.tmp = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.ChannelNoise.prototype = {\n\t    reset: function reset() {\n\t        this.progTimerCount = 0;\n\t        this.progTimerMax = 0;\n\t        this.isEnabled = false;\n\t        this.lengthCounter = 0;\n\t        this.lengthCounterEnable = false;\n\t        this.envDecayDisable = false;\n\t        this.envDecayLoopEnable = false;\n\t        this.shiftNow = false;\n\t        this.envDecayRate = 0;\n\t        this.envDecayCounter = 0;\n\t        this.envVolume = 0;\n\t        this.masterVolume = 0;\n\t        this.shiftReg = 1;\n\t        this.randomBit = 0;\n\t        this.randomMode = 0;\n\t        this.sampleValue = 0;\n\t        this.tmp = 0;\n\t    },\n\t\n\t    clockLengthCounter: function clockLengthCounter() {\n\t        if (this.lengthCounterEnable && this.lengthCounter > 0) {\n\t            this.lengthCounter--;\n\t            if (this.lengthCounter === 0) {\n\t                this.updateSampleValue();\n\t            }\n\t        }\n\t    },\n\t\n\t    clockEnvDecay: function clockEnvDecay() {\n\t        if (this.envReset) {\n\t            // Reset envelope:\n\t            this.envReset = false;\n\t            this.envDecayCounter = this.envDecayRate + 1;\n\t            this.envVolume = 0xF;\n\t        } else if (--this.envDecayCounter <= 0) {\n\t            // Normal handling:\n\t            this.envDecayCounter = this.envDecayRate + 1;\n\t            if (this.envVolume > 0) {\n\t                this.envVolume--;\n\t            } else {\n\t                this.envVolume = this.envDecayLoopEnable ? 0xF : 0;\n\t            }\n\t        }\n\t        this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n\t        this.updateSampleValue();\n\t    },\n\t\n\t    updateSampleValue: function updateSampleValue() {\n\t        if (this.isEnabled && this.lengthCounter > 0) {\n\t            this.sampleValue = this.randomBit * this.masterVolume;\n\t        }\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        if (address === 0x400C) {\n\t            // Volume/Envelope decay:\n\t            this.envDecayDisable = (value & 0x10) !== 0;\n\t            this.envDecayRate = value & 0xF;\n\t            this.envDecayLoopEnable = (value & 0x20) !== 0;\n\t            this.lengthCounterEnable = (value & 0x20) === 0;\n\t            this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n\t        } else if (address === 0x400E) {\n\t            // Programmable timer:\n\t            this.progTimerMax = this.papu.getNoiseWaveLength(value & 0xF);\n\t            this.randomMode = value >> 7;\n\t        } else if (address === 0x400F) {\n\t            // Length counter\n\t            this.lengthCounter = this.papu.getLengthMax(value & 248);\n\t            this.envReset = true;\n\t        }\n\t        // Update:\n\t        //updateSampleValue();\n\t    },\n\t\n\t    setEnabled: function setEnabled(value) {\n\t        this.isEnabled = value;\n\t        if (!value) {\n\t            this.lengthCounter = 0;\n\t        }\n\t        this.updateSampleValue();\n\t    },\n\t\n\t    getLengthStatus: function getLengthStatus() {\n\t        return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n\t    }\n\t};\n\t\n\tPAPU.ChannelSquare = function (papu, square1) {\n\t    this.papu = papu;\n\t\n\t    this.dutyLookup = [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1];\n\t    this.impLookup = [1, -1, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0];\n\t\n\t    this.sqr1 = square1;\n\t    this.isEnabled = null;\n\t    this.lengthCounterEnable = null;\n\t    this.sweepActive = null;\n\t    this.envDecayDisable = null;\n\t    this.envDecayLoopEnable = null;\n\t    this.envReset = null;\n\t    this.sweepCarry = null;\n\t    this.updateSweepPeriod = null;\n\t\n\t    this.progTimerCount = null;\n\t    this.progTimerMax = null;\n\t    this.lengthCounter = null;\n\t    this.squareCounter = null;\n\t    this.sweepCounter = null;\n\t    this.sweepCounterMax = null;\n\t    this.sweepMode = null;\n\t    this.sweepShiftAmount = null;\n\t    this.envDecayRate = null;\n\t    this.envDecayCounter = null;\n\t    this.envVolume = null;\n\t    this.masterVolume = null;\n\t    this.dutyMode = null;\n\t    this.sweepResult = null;\n\t    this.sampleValue = null;\n\t    this.vol = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.ChannelSquare.prototype = {\n\t    reset: function reset() {\n\t        this.progTimerCount = 0;\n\t        this.progTimerMax = 0;\n\t        this.lengthCounter = 0;\n\t        this.squareCounter = 0;\n\t        this.sweepCounter = 0;\n\t        this.sweepCounterMax = 0;\n\t        this.sweepMode = 0;\n\t        this.sweepShiftAmount = 0;\n\t        this.envDecayRate = 0;\n\t        this.envDecayCounter = 0;\n\t        this.envVolume = 0;\n\t        this.masterVolume = 0;\n\t        this.dutyMode = 0;\n\t        this.vol = 0;\n\t\n\t        this.isEnabled = false;\n\t        this.lengthCounterEnable = false;\n\t        this.sweepActive = false;\n\t        this.sweepCarry = false;\n\t        this.envDecayDisable = false;\n\t        this.envDecayLoopEnable = false;\n\t    },\n\t\n\t    clockLengthCounter: function clockLengthCounter() {\n\t        if (this.lengthCounterEnable && this.lengthCounter > 0) {\n\t            this.lengthCounter--;\n\t            if (this.lengthCounter === 0) {\n\t                this.updateSampleValue();\n\t            }\n\t        }\n\t    },\n\t\n\t    clockEnvDecay: function clockEnvDecay() {\n\t        if (this.envReset) {\n\t            // Reset envelope:\n\t            this.envReset = false;\n\t            this.envDecayCounter = this.envDecayRate + 1;\n\t            this.envVolume = 0xF;\n\t        } else if (--this.envDecayCounter <= 0) {\n\t            // Normal handling:\n\t            this.envDecayCounter = this.envDecayRate + 1;\n\t            if (this.envVolume > 0) {\n\t                this.envVolume--;\n\t            } else {\n\t                this.envVolume = this.envDecayLoopEnable ? 0xF : 0;\n\t            }\n\t        }\n\t\n\t        this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n\t        this.updateSampleValue();\n\t    },\n\t\n\t    clockSweep: function clockSweep() {\n\t        if (--this.sweepCounter <= 0) {\n\t\n\t            this.sweepCounter = this.sweepCounterMax + 1;\n\t            if (this.sweepActive && this.sweepShiftAmount > 0 && this.progTimerMax > 7) {\n\t\n\t                // Calculate result from shifter:\n\t                this.sweepCarry = false;\n\t                if (this.sweepMode === 0) {\n\t                    this.progTimerMax += this.progTimerMax >> this.sweepShiftAmount;\n\t                    if (this.progTimerMax > 4095) {\n\t                        this.progTimerMax = 4095;\n\t                        this.sweepCarry = true;\n\t                    }\n\t                } else {\n\t                    this.progTimerMax = this.progTimerMax - ((this.progTimerMax >> this.sweepShiftAmount) - (this.sqr1 ? 1 : 0));\n\t                }\n\t            }\n\t        }\n\t\n\t        if (this.updateSweepPeriod) {\n\t            this.updateSweepPeriod = false;\n\t            this.sweepCounter = this.sweepCounterMax + 1;\n\t        }\n\t    },\n\t\n\t    updateSampleValue: function updateSampleValue() {\n\t        if (this.isEnabled && this.lengthCounter > 0 && this.progTimerMax > 7) {\n\t\n\t            if (this.sweepMode === 0 && this.progTimerMax + (this.progTimerMax >> this.sweepShiftAmount) > 4095) {\n\t                //if (this.sweepCarry) {\n\t                this.sampleValue = 0;\n\t            } else {\n\t                this.sampleValue = this.masterVolume * this.dutyLookup[(this.dutyMode << 3) + this.squareCounter];\n\t            }\n\t        } else {\n\t            this.sampleValue = 0;\n\t        }\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        var addrAdd = this.sqr1 ? 0 : 4;\n\t        if (address === 0x4000 + addrAdd) {\n\t            // Volume/Envelope decay:\n\t            this.envDecayDisable = (value & 0x10) !== 0;\n\t            this.envDecayRate = value & 0xF;\n\t            this.envDecayLoopEnable = (value & 0x20) !== 0;\n\t            this.dutyMode = value >> 6 & 0x3;\n\t            this.lengthCounterEnable = (value & 0x20) === 0;\n\t            this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n\t            this.updateSampleValue();\n\t        } else if (address === 0x4001 + addrAdd) {\n\t            // Sweep:\n\t            this.sweepActive = (value & 0x80) !== 0;\n\t            this.sweepCounterMax = value >> 4 & 7;\n\t            this.sweepMode = value >> 3 & 1;\n\t            this.sweepShiftAmount = value & 7;\n\t            this.updateSweepPeriod = true;\n\t        } else if (address === 0x4002 + addrAdd) {\n\t            // Programmable timer:\n\t            this.progTimerMax &= 0x700;\n\t            this.progTimerMax |= value;\n\t        } else if (address === 0x4003 + addrAdd) {\n\t            // Programmable timer, length counter\n\t            this.progTimerMax &= 0xFF;\n\t            this.progTimerMax |= (value & 0x7) << 8;\n\t\n\t            if (this.isEnabled) {\n\t                this.lengthCounter = this.papu.getLengthMax(value & 0xF8);\n\t            }\n\t\n\t            this.envReset = true;\n\t        }\n\t    },\n\t\n\t    setEnabled: function setEnabled(value) {\n\t        this.isEnabled = value;\n\t        if (!value) {\n\t            this.lengthCounter = 0;\n\t        }\n\t        this.updateSampleValue();\n\t    },\n\t\n\t    getLengthStatus: function getLengthStatus() {\n\t        return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n\t    }\n\t};\n\t\n\tPAPU.ChannelTriangle = function (papu) {\n\t    this.papu = papu;\n\t\n\t    this.isEnabled = null;\n\t    this.sampleCondition = null;\n\t    this.lengthCounterEnable = null;\n\t    this.lcHalt = null;\n\t    this.lcControl = null;\n\t\n\t    this.progTimerCount = null;\n\t    this.progTimerMax = null;\n\t    this.triangleCounter = null;\n\t    this.lengthCounter = null;\n\t    this.linearCounter = null;\n\t    this.lcLoadValue = null;\n\t    this.sampleValue = null;\n\t    this.tmp = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.ChannelTriangle.prototype = {\n\t    reset: function reset() {\n\t        this.progTimerCount = 0;\n\t        this.progTimerMax = 0;\n\t        this.triangleCounter = 0;\n\t        this.isEnabled = false;\n\t        this.sampleCondition = false;\n\t        this.lengthCounter = 0;\n\t        this.lengthCounterEnable = false;\n\t        this.linearCounter = 0;\n\t        this.lcLoadValue = 0;\n\t        this.lcHalt = true;\n\t        this.lcControl = false;\n\t        this.tmp = 0;\n\t        this.sampleValue = 0xF;\n\t    },\n\t\n\t    clockLengthCounter: function clockLengthCounter() {\n\t        if (this.lengthCounterEnable && this.lengthCounter > 0) {\n\t            this.lengthCounter--;\n\t            if (this.lengthCounter === 0) {\n\t                this.updateSampleCondition();\n\t            }\n\t        }\n\t    },\n\t\n\t    clockLinearCounter: function clockLinearCounter() {\n\t        if (this.lcHalt) {\n\t            // Load:\n\t            this.linearCounter = this.lcLoadValue;\n\t            this.updateSampleCondition();\n\t        } else if (this.linearCounter > 0) {\n\t            // Decrement:\n\t            this.linearCounter--;\n\t            this.updateSampleCondition();\n\t        }\n\t        if (!this.lcControl) {\n\t            // Clear halt flag:\n\t            this.lcHalt = false;\n\t        }\n\t    },\n\t\n\t    getLengthStatus: function getLengthStatus() {\n\t        return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n\t    },\n\t\n\t    readReg: function readReg(address) {\n\t        return 0;\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        if (address === 0x4008) {\n\t            // New values for linear counter:\n\t            this.lcControl = (value & 0x80) !== 0;\n\t            this.lcLoadValue = value & 0x7F;\n\t\n\t            // Length counter enable:\n\t            this.lengthCounterEnable = !this.lcControl;\n\t        } else if (address === 0x400A) {\n\t            // Programmable timer:\n\t            this.progTimerMax &= 0x700;\n\t            this.progTimerMax |= value;\n\t        } else if (address === 0x400B) {\n\t            // Programmable timer, length counter\n\t            this.progTimerMax &= 0xFF;\n\t            this.progTimerMax |= (value & 0x07) << 8;\n\t            this.lengthCounter = this.papu.getLengthMax(value & 0xF8);\n\t            this.lcHalt = true;\n\t        }\n\t\n\t        this.updateSampleCondition();\n\t    },\n\t\n\t    clockProgrammableTimer: function clockProgrammableTimer(nCycles) {\n\t        if (this.progTimerMax > 0) {\n\t            this.progTimerCount += nCycles;\n\t            while (this.progTimerMax > 0 && this.progTimerCount >= this.progTimerMax) {\n\t                this.progTimerCount -= this.progTimerMax;\n\t                if (this.isEnabled && this.lengthCounter > 0 && this.linearCounter > 0) {\n\t                    this.clockTriangleGenerator();\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    clockTriangleGenerator: function clockTriangleGenerator() {\n\t        this.triangleCounter++;\n\t        this.triangleCounter &= 0x1F;\n\t    },\n\t\n\t    setEnabled: function setEnabled(value) {\n\t        this.isEnabled = value;\n\t        if (!value) {\n\t            this.lengthCounter = 0;\n\t        }\n\t        this.updateSampleCondition();\n\t    },\n\t\n\t    updateSampleCondition: function updateSampleCondition() {\n\t        this.sampleCondition = this.isEnabled && this.progTimerMax > 7 && this.linearCounter > 0 && this.lengthCounter > 0;\n\t    }\n\t};\n\t\n\texports.default = PAPU;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _ppu = __webpack_require__(5);\n\t\n\tvar _ppu2 = _interopRequireDefault(_ppu);\n\t\n\tvar _mappers = __webpack_require__(8);\n\t\n\tvar _mappers2 = _interopRequireDefault(_mappers);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\t\n\tvar ROM = function ROM(nes) {\n\t    this.nes = nes;\n\t\n\t    this.mapperName = new Array(92);\n\t\n\t    for (var i = 0; i < 92; i++) {\n\t        this.mapperName[i] = \"Unknown Mapper\";\n\t    }\n\t    this.mapperName[0] = \"Direct Access\";\n\t    this.mapperName[1] = \"Nintendo MMC1\";\n\t    this.mapperName[2] = \"UNROM\";\n\t    this.mapperName[3] = \"CNROM\";\n\t    this.mapperName[4] = \"Nintendo MMC3\";\n\t    this.mapperName[5] = \"Nintendo MMC5\";\n\t    this.mapperName[6] = \"FFE F4xxx\";\n\t    this.mapperName[7] = \"AOROM\";\n\t    this.mapperName[8] = \"FFE F3xxx\";\n\t    this.mapperName[9] = \"Nintendo MMC2\";\n\t    this.mapperName[10] = \"Nintendo MMC4\";\n\t    this.mapperName[11] = \"Color Dreams Chip\";\n\t    this.mapperName[12] = \"FFE F6xxx\";\n\t    this.mapperName[15] = \"100-in-1 switch\";\n\t    this.mapperName[16] = \"Bandai chip\";\n\t    this.mapperName[17] = \"FFE F8xxx\";\n\t    this.mapperName[18] = \"Jaleco SS8806 chip\";\n\t    this.mapperName[19] = \"Namcot 106 chip\";\n\t    this.mapperName[20] = \"Famicom Disk System\";\n\t    this.mapperName[21] = \"Konami VRC4a\";\n\t    this.mapperName[22] = \"Konami VRC2a\";\n\t    this.mapperName[23] = \"Konami VRC2a\";\n\t    this.mapperName[24] = \"Konami VRC6\";\n\t    this.mapperName[25] = \"Konami VRC4b\";\n\t    this.mapperName[32] = \"Irem G-101 chip\";\n\t    this.mapperName[33] = \"Taito TC0190/TC0350\";\n\t    this.mapperName[34] = \"32kB ROM switch\";\n\t\n\t    this.mapperName[64] = \"Tengen RAMBO-1 chip\";\n\t    this.mapperName[65] = \"Irem H-3001 chip\";\n\t    this.mapperName[66] = \"GNROM switch\";\n\t    this.mapperName[67] = \"SunSoft3 chip\";\n\t    this.mapperName[68] = \"SunSoft4 chip\";\n\t    this.mapperName[69] = \"SunSoft5 FME-7 chip\";\n\t    this.mapperName[71] = \"Camerica chip\";\n\t    this.mapperName[78] = \"Irem 74HC161/32-based\";\n\t    this.mapperName[91] = \"Pirate HK-SF3 chip\";\n\t};\n\t\n\tROM.prototype = {\n\t    // Mirroring types:\n\t    VERTICAL_MIRRORING: 0,\n\t    HORIZONTAL_MIRRORING: 1,\n\t    FOURSCREEN_MIRRORING: 2,\n\t    SINGLESCREEN_MIRRORING: 3,\n\t    SINGLESCREEN_MIRRORING2: 4,\n\t    SINGLESCREEN_MIRRORING3: 5,\n\t    SINGLESCREEN_MIRRORING4: 6,\n\t    CHRROM_MIRRORING: 7,\n\t\n\t    header: null,\n\t    rom: null,\n\t    vrom: null,\n\t    vromTile: null,\n\t\n\t    romCount: null,\n\t    vromCount: null,\n\t    mirroring: null,\n\t    batteryRam: null,\n\t    trainer: null,\n\t    fourScreen: null,\n\t    mapperType: null,\n\t    valid: false,\n\t\n\t    load: function load(data) {\n\t        var i, j, v;\n\t\n\t        if (data.indexOf(\"NES\\x1a\") === -1) {\n\t            this.nes.ui.updateStatus(\"Not a valid NES ROM.\");\n\t            return;\n\t        }\n\t        this.header = new Array(16);\n\t        for (i = 0; i < 16; i++) {\n\t            this.header[i] = data.charCodeAt(i) & 0xFF;\n\t        }\n\t        this.romCount = this.header[4];\n\t        this.vromCount = this.header[5] * 2; // Get the number of 4kB banks, not 8kB\n\t        this.mirroring = (this.header[6] & 1) !== 0 ? 1 : 0;\n\t        this.batteryRam = (this.header[6] & 2) !== 0;\n\t        this.trainer = (this.header[6] & 4) !== 0;\n\t        this.fourScreen = (this.header[6] & 8) !== 0;\n\t        this.mapperType = this.header[6] >> 4 | this.header[7] & 0xF0;\n\t        /* TODO\n\t        if (this.batteryRam)\n\t            this.loadBatteryRam();*/\n\t        // Check whether byte 8-15 are zero's:\n\t        var foundError = false;\n\t        for (i = 8; i < 16; i++) {\n\t            if (this.header[i] !== 0) {\n\t                foundError = true;\n\t                break;\n\t            }\n\t        }\n\t        if (foundError) {\n\t            this.mapperType &= 0xF; // Ignore byte 7\n\t        }\n\t        // Load PRG-ROM banks:\n\t        this.rom = new Array(this.romCount);\n\t        var offset = 16;\n\t        for (i = 0; i < this.romCount; i++) {\n\t            this.rom[i] = new Array(16384);\n\t            for (j = 0; j < 16384; j++) {\n\t                if (offset + j >= data.length) {\n\t                    break;\n\t                }\n\t                this.rom[i][j] = data.charCodeAt(offset + j) & 0xFF;\n\t            }\n\t            offset += 16384;\n\t        }\n\t        // Load CHR-ROM banks:\n\t        this.vrom = new Array(this.vromCount);\n\t        for (i = 0; i < this.vromCount; i++) {\n\t            this.vrom[i] = new Array(4096);\n\t            for (j = 0; j < 4096; j++) {\n\t                if (offset + j >= data.length) {\n\t                    break;\n\t                }\n\t                this.vrom[i][j] = data.charCodeAt(offset + j) & 0xFF;\n\t            }\n\t            offset += 4096;\n\t        }\n\t\n\t        // Create VROM tiles:\n\t        this.vromTile = new Array(this.vromCount);\n\t        for (i = 0; i < this.vromCount; i++) {\n\t            this.vromTile[i] = new Array(256);\n\t            for (j = 0; j < 256; j++) {\n\t                this.vromTile[i][j] = new _ppu2.default.Tile();\n\t            }\n\t        }\n\t\n\t        // Convert CHR-ROM banks to tiles:\n\t        var tileIndex;\n\t        var leftOver;\n\t        for (v = 0; v < this.vromCount; v++) {\n\t            for (i = 0; i < 4096; i++) {\n\t                tileIndex = i >> 4;\n\t                leftOver = i % 16;\n\t                if (leftOver < 8) {\n\t                    this.vromTile[v][tileIndex].setScanline(leftOver, this.vrom[v][i], this.vrom[v][i + 8]);\n\t                } else {\n\t                    this.vromTile[v][tileIndex].setScanline(leftOver - 8, this.vrom[v][i - 8], this.vrom[v][i]);\n\t                }\n\t            }\n\t        }\n\t\n\t        this.valid = true;\n\t    },\n\t\n\t    getMirroringType: function getMirroringType() {\n\t        if (this.fourScreen) {\n\t            return this.FOURSCREEN_MIRRORING;\n\t        }\n\t        if (this.mirroring === 0) {\n\t            return this.HORIZONTAL_MIRRORING;\n\t        }\n\t        return this.VERTICAL_MIRRORING;\n\t    },\n\t\n\t    getMapperName: function getMapperName() {\n\t        if (this.mapperType >= 0 && this.mapperType < this.mapperName.length) {\n\t            return this.mapperName[this.mapperType];\n\t        }\n\t        return \"Unknown Mapper, \" + this.mapperType;\n\t    },\n\t\n\t    mapperSupported: function mapperSupported() {\n\t        return typeof _mappers2.default[this.mapperType] !== 'undefined';\n\t    },\n\t\n\t    createMapper: function createMapper() {\n\t        if (this.mapperSupported()) {\n\t            return new _mappers2.default[this.mapperType](this.nes);\n\t        } else {\n\t            this.nes.ui.updateStatus(\"This ROM uses a mapper not supported by JSNES: \" + this.getMapperName() + \"(\" + this.mapperType + \")\");\n\t            return null;\n\t        }\n\t    }\n\t};\n\t\n\texports.default = ROM;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Mappers = {}; /*\n\t                  JSNES, based on Jamie Sanders' vNES\n\t                  Copyright (C) 2010 Ben Firshman\n\t                  \n\t                  This program is free software: you can redistribute it and/or modify\n\t                  it under the terms of the GNU General Public License as published by\n\t                  the Free Software Foundation, either version 3 of the License, or\n\t                  (at your option) any later version.\n\t                  \n\t                  This program is distributed in the hope that it will be useful,\n\t                  but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t                  GNU General Public License for more details.\n\t                  \n\t                  You should have received a copy of the GNU General Public License\n\t                  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t                  */\n\t\n\tMappers[0] = function (nes) {\n\t    this.nes = nes;\n\t};\n\t\n\tMappers[0].prototype = {\n\t    reset: function reset() {\n\t        this.joy1StrobeState = 0;\n\t        this.joy2StrobeState = 0;\n\t        this.joypadLastWrite = 0;\n\t\n\t        this.mousePressed = false;\n\t        this.mouseX = null;\n\t        this.mouseY = null;\n\t    },\n\t\n\t    write: function write(address, value) {\n\t        if (address < 0x2000) {\n\t            // Mirroring of RAM:\n\t            this.nes.cpu.mem[address & 0x7FF] = value;\n\t        } else if (address > 0x4017) {\n\t            this.nes.cpu.mem[address] = value;\n\t            if (address >= 0x6000 && address < 0x8000) {\n\t                // Write to SaveRAM. Store in file:\n\t                // TODO: not yet\n\t                //if(this.nes.rom!=null)\n\t                //    this.nes.rom.writeBatteryRam(address,value);\n\t            }\n\t        } else if (address > 0x2007 && address < 0x4000) {\n\t                this.regWrite(0x2000 + (address & 0x7), value);\n\t            } else {\n\t                this.regWrite(address, value);\n\t            }\n\t    },\n\t\n\t    writelow: function writelow(address, value) {\n\t        if (address < 0x2000) {\n\t            // Mirroring of RAM:\n\t            this.nes.cpu.mem[address & 0x7FF] = value;\n\t        } else if (address > 0x4017) {\n\t            this.nes.cpu.mem[address] = value;\n\t        } else if (address > 0x2007 && address < 0x4000) {\n\t            this.regWrite(0x2000 + (address & 0x7), value);\n\t        } else {\n\t            this.regWrite(address, value);\n\t        }\n\t    },\n\t\n\t    load: function load(address) {\n\t        // Wrap around:\n\t        address &= 0xFFFF;\n\t\n\t        // Check address range:\n\t        if (address > 0x4017) {\n\t            // ROM:\n\t            return this.nes.cpu.mem[address];\n\t        } else if (address >= 0x2000) {\n\t            // I/O Ports.\n\t            return this.regLoad(address);\n\t        } else {\n\t            // RAM (mirrored)\n\t            return this.nes.cpu.mem[address & 0x7FF];\n\t        }\n\t    },\n\t\n\t    regLoad: function regLoad(address) {\n\t        switch (address >> 12) {// use fourth nibble (0xF000)\n\t            case 0:\n\t                break;\n\t\n\t            case 1:\n\t                break;\n\t\n\t            case 2:\n\t            // Fall through to case 3\n\t            case 3:\n\t                // PPU Registers\n\t                switch (address & 0x7) {\n\t                    case 0x0:\n\t                        // 0x2000:\n\t                        // PPU Control Register 1.\n\t                        // (the value is stored both\n\t                        // in main memory and in the\n\t                        // PPU as flags):\n\t                        // (not in the real NES)\n\t                        return this.nes.cpu.mem[0x2000];\n\t\n\t                    case 0x1:\n\t                        // 0x2001:\n\t                        // PPU Control Register 2.\n\t                        // (the value is stored both\n\t                        // in main memory and in the\n\t                        // PPU as flags):\n\t                        // (not in the real NES)\n\t                        return this.nes.cpu.mem[0x2001];\n\t\n\t                    case 0x2:\n\t                        // 0x2002:\n\t                        // PPU Status Register.\n\t                        // The value is stored in\n\t                        // main memory in addition\n\t                        // to as flags in the PPU.\n\t                        // (not in the real NES)\n\t                        return this.nes.ppu.readStatusRegister();\n\t\n\t                    case 0x3:\n\t                        return 0;\n\t\n\t                    case 0x4:\n\t                        // 0x2004:\n\t                        // Sprite Memory read.\n\t                        return this.nes.ppu.sramLoad();\n\t                    case 0x5:\n\t                        return 0;\n\t\n\t                    case 0x6:\n\t                        return 0;\n\t\n\t                    case 0x7:\n\t                        // 0x2007:\n\t                        // VRAM read:\n\t                        return this.nes.ppu.vramLoad();\n\t                }\n\t                break;\n\t            case 4:\n\t                // Sound+Joypad registers\n\t                switch (address - 0x4015) {\n\t                    case 0:\n\t                        // 0x4015:\n\t                        // Sound channel enable, DMC Status\n\t                        return this.nes.papu.readReg(address);\n\t\n\t                    case 1:\n\t                        // 0x4016:\n\t                        // Joystick 1 + Strobe\n\t                        return this.joy1Read();\n\t\n\t                    case 2:\n\t                        // 0x4017:\n\t                        // Joystick 2 + Strobe\n\t                        if (this.mousePressed) {\n\t\n\t                            // Check for white pixel nearby:\n\t                            var sx = Math.max(0, this.mouseX - 4);\n\t                            var ex = Math.min(256, this.mouseX + 4);\n\t                            var sy = Math.max(0, this.mouseY - 4);\n\t                            var ey = Math.min(240, this.mouseY + 4);\n\t                            var w = 0;\n\t\n\t                            for (var y = sy; y < ey; y++) {\n\t                                for (var x = sx; x < ex; x++) {\n\t\n\t                                    if (this.nes.ppu.buffer[(y << 8) + x] == 0xFFFFFF) {\n\t                                        w |= 0x1 << 3;\n\t                                        console.debug(\"Clicked on white!\");\n\t                                        break;\n\t                                    }\n\t                                }\n\t                            }\n\t\n\t                            w |= this.mousePressed ? 0x1 << 4 : 0;\n\t                            return (this.joy2Read() | w) & 0xFFFF;\n\t                        } else {\n\t                            return this.joy2Read();\n\t                        }\n\t\n\t                }\n\t                break;\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    regWrite: function regWrite(address, value) {\n\t        switch (address) {\n\t            case 0x2000:\n\t                // PPU Control register 1\n\t                this.nes.cpu.mem[address] = value;\n\t                this.nes.ppu.updateControlReg1(value);\n\t                break;\n\t\n\t            case 0x2001:\n\t                // PPU Control register 2\n\t                this.nes.cpu.mem[address] = value;\n\t                this.nes.ppu.updateControlReg2(value);\n\t                break;\n\t\n\t            case 0x2003:\n\t                // Set Sprite RAM address:\n\t                this.nes.ppu.writeSRAMAddress(value);\n\t                break;\n\t\n\t            case 0x2004:\n\t                // Write to Sprite RAM:\n\t                this.nes.ppu.sramWrite(value);\n\t                break;\n\t\n\t            case 0x2005:\n\t                // Screen Scroll offsets:\n\t                this.nes.ppu.scrollWrite(value);\n\t                break;\n\t\n\t            case 0x2006:\n\t                // Set VRAM address:\n\t                this.nes.ppu.writeVRAMAddress(value);\n\t                break;\n\t\n\t            case 0x2007:\n\t                // Write to VRAM:\n\t                this.nes.ppu.vramWrite(value);\n\t                break;\n\t\n\t            case 0x4014:\n\t                // Sprite Memory DMA Access\n\t                this.nes.ppu.sramDMA(value);\n\t                break;\n\t\n\t            case 0x4015:\n\t                // Sound Channel Switch, DMC Status\n\t                this.nes.papu.writeReg(address, value);\n\t                break;\n\t\n\t            case 0x4016:\n\t                // Joystick 1 + Strobe\n\t                if ((value & 1) === 0 && (this.joypadLastWrite & 1) === 1) {\n\t                    this.joy1StrobeState = 0;\n\t                    this.joy2StrobeState = 0;\n\t                }\n\t                this.joypadLastWrite = value;\n\t                break;\n\t\n\t            case 0x4017:\n\t                // Sound channel frame sequencer:\n\t                this.nes.papu.writeReg(address, value);\n\t                break;\n\t\n\t            default:\n\t                // Sound registers\n\t                ////System.out.println(\"write to sound reg\");\n\t                if (address >= 0x4000 && address <= 0x4017) {\n\t                    this.nes.papu.writeReg(address, value);\n\t                }\n\t\n\t        }\n\t    },\n\t\n\t    joy1Read: function joy1Read() {\n\t        var ret;\n\t\n\t        switch (this.joy1StrobeState) {\n\t            case 0:\n\t            case 1:\n\t            case 2:\n\t            case 3:\n\t            case 4:\n\t            case 5:\n\t            case 6:\n\t            case 7:\n\t                ret = this.nes.keyboard.state1[this.joy1StrobeState];\n\t                break;\n\t            case 8:\n\t            case 9:\n\t            case 10:\n\t            case 11:\n\t            case 12:\n\t            case 13:\n\t            case 14:\n\t            case 15:\n\t            case 16:\n\t            case 17:\n\t            case 18:\n\t                ret = 0;\n\t                break;\n\t            case 19:\n\t                ret = 1;\n\t                break;\n\t            default:\n\t                ret = 0;\n\t        }\n\t\n\t        this.joy1StrobeState++;\n\t        if (this.joy1StrobeState == 24) {\n\t            this.joy1StrobeState = 0;\n\t        }\n\t\n\t        return ret;\n\t    },\n\t\n\t    joy2Read: function joy2Read() {\n\t        var ret;\n\t\n\t        switch (this.joy2StrobeState) {\n\t            case 0:\n\t            case 1:\n\t            case 2:\n\t            case 3:\n\t            case 4:\n\t            case 5:\n\t            case 6:\n\t            case 7:\n\t                ret = this.nes.keyboard.state2[this.joy2StrobeState];\n\t                break;\n\t            case 8:\n\t            case 9:\n\t            case 10:\n\t            case 11:\n\t            case 12:\n\t            case 13:\n\t            case 14:\n\t            case 15:\n\t            case 16:\n\t            case 17:\n\t            case 18:\n\t                ret = 0;\n\t                break;\n\t            case 19:\n\t                ret = 1;\n\t                break;\n\t            default:\n\t                ret = 0;\n\t        }\n\t\n\t        this.joy2StrobeState++;\n\t        if (this.joy2StrobeState == 24) {\n\t            this.joy2StrobeState = 0;\n\t        }\n\t\n\t        return ret;\n\t    },\n\t\n\t    loadROM: function loadROM() {\n\t        if (!this.nes.rom.valid || this.nes.rom.romCount < 1) {\n\t            alert(\"NoMapper: Invalid ROM! Unable to load.\");\n\t            return;\n\t        }\n\t\n\t        // Load ROM into memory:\n\t        this.loadPRGROM();\n\t\n\t        // Load CHR-ROM:\n\t        this.loadCHRROM();\n\t\n\t        // Load Battery RAM (if present):\n\t        this.loadBatteryRam();\n\t\n\t        // Reset IRQ:\n\t        //nes.getCpu().doResetInterrupt();\n\t        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n\t    },\n\t\n\t    loadPRGROM: function loadPRGROM() {\n\t        if (this.nes.rom.romCount > 1) {\n\t            // Load the two first banks into memory.\n\t            this.loadRomBank(0, 0x8000);\n\t            this.loadRomBank(1, 0xC000);\n\t        } else {\n\t            // Load the one bank into both memory locations:\n\t            this.loadRomBank(0, 0x8000);\n\t            this.loadRomBank(0, 0xC000);\n\t        }\n\t    },\n\t\n\t    loadCHRROM: function loadCHRROM() {\n\t        ////System.out.println(\"Loading CHR ROM..\");\n\t        if (this.nes.rom.vromCount > 0) {\n\t            if (this.nes.rom.vromCount == 1) {\n\t                this.loadVromBank(0, 0x0000);\n\t                this.loadVromBank(0, 0x1000);\n\t            } else {\n\t                this.loadVromBank(0, 0x0000);\n\t                this.loadVromBank(1, 0x1000);\n\t            }\n\t        } else {\n\t            //System.out.println(\"There aren't any CHR-ROM banks..\");\n\t        }\n\t    },\n\t\n\t    loadBatteryRam: function loadBatteryRam() {\n\t        if (this.nes.rom.batteryRam) {\n\t            var ram = this.nes.rom.batteryRam;\n\t            if (ram !== null && ram.length == 0x2000) {\n\t                // Load Battery RAM into memory:\n\t                _utils2.default.copyArrayElements(ram, 0, this.nes.cpu.mem, 0x6000, 0x2000);\n\t            }\n\t        }\n\t    },\n\t\n\t    loadRomBank: function loadRomBank(bank, address) {\n\t        // Loads a ROM bank into the specified address.\n\t        bank %= this.nes.rom.romCount;\n\t        //var data = this.nes.rom.rom[bank];\n\t        //cpuMem.write(address,data,data.length);\n\t        _utils2.default.copyArrayElements(this.nes.rom.rom[bank], 0, this.nes.cpu.mem, address, 16384);\n\t    },\n\t\n\t    loadVromBank: function loadVromBank(bank, address) {\n\t        if (this.nes.rom.vromCount === 0) {\n\t            return;\n\t        }\n\t        this.nes.ppu.triggerRendering();\n\t\n\t        _utils2.default.copyArrayElements(this.nes.rom.vrom[bank % this.nes.rom.vromCount], 0, this.nes.ppu.vramMem, address, 4096);\n\t\n\t        var vromTile = this.nes.rom.vromTile[bank % this.nes.rom.vromCount];\n\t        _utils2.default.copyArrayElements(vromTile, 0, this.nes.ppu.ptTile, address >> 4, 256);\n\t    },\n\t\n\t    load32kRomBank: function load32kRomBank(bank, address) {\n\t        this.loadRomBank(bank * 2 % this.nes.rom.romCount, address);\n\t        this.loadRomBank((bank * 2 + 1) % this.nes.rom.romCount, address + 16384);\n\t    },\n\t\n\t    load8kVromBank: function load8kVromBank(bank4kStart, address) {\n\t        if (this.nes.rom.vromCount === 0) {\n\t            return;\n\t        }\n\t        this.nes.ppu.triggerRendering();\n\t\n\t        this.loadVromBank(bank4kStart % this.nes.rom.vromCount, address);\n\t        this.loadVromBank((bank4kStart + 1) % this.nes.rom.vromCount, address + 4096);\n\t    },\n\t\n\t    load1kVromBank: function load1kVromBank(bank1k, address) {\n\t        if (this.nes.rom.vromCount === 0) {\n\t            return;\n\t        }\n\t        this.nes.ppu.triggerRendering();\n\t\n\t        var bank4k = Math.floor(bank1k / 4) % this.nes.rom.vromCount;\n\t        var bankoffset = bank1k % 4 * 1024;\n\t        _utils2.default.copyArrayElements(this.nes.rom.vrom[bank4k], 0, this.nes.ppu.vramMem, bankoffset, 1024);\n\t\n\t        // Update tiles:\n\t        var vromTile = this.nes.rom.vromTile[bank4k];\n\t        var baseIndex = address >> 4;\n\t        for (var i = 0; i < 64; i++) {\n\t            this.nes.ppu.ptTile[baseIndex + i] = vromTile[(bank1k % 4 << 6) + i];\n\t        }\n\t    },\n\t\n\t    load2kVromBank: function load2kVromBank(bank2k, address) {\n\t        if (this.nes.rom.vromCount === 0) {\n\t            return;\n\t        }\n\t        this.nes.ppu.triggerRendering();\n\t\n\t        var bank4k = Math.floor(bank2k / 2) % this.nes.rom.vromCount;\n\t        var bankoffset = bank2k % 2 * 2048;\n\t        _utils2.default.copyArrayElements(this.nes.rom.vrom[bank4k], bankoffset, this.nes.ppu.vramMem, address, 2048);\n\t\n\t        // Update tiles:\n\t        var vromTile = this.nes.rom.vromTile[bank4k];\n\t        var baseIndex = address >> 4;\n\t        for (var i = 0; i < 128; i++) {\n\t            this.nes.ppu.ptTile[baseIndex + i] = vromTile[(bank2k % 2 << 7) + i];\n\t        }\n\t    },\n\t\n\t    load8kRomBank: function load8kRomBank(bank8k, address) {\n\t        var bank16k = Math.floor(bank8k / 2) % this.nes.rom.romCount;\n\t        var offset = bank8k % 2 * 8192;\n\t\n\t        //this.nes.cpu.mem.write(address,this.nes.rom.rom[bank16k],offset,8192);\n\t        _utils2.default.copyArrayElements(this.nes.rom.rom[bank16k], offset, this.nes.cpu.mem, address, 8192);\n\t    },\n\t\n\t    clockIrqCounter: function clockIrqCounter() {\n\t        // Does nothing. This is used by the MMC3 mapper.\n\t    },\n\t\n\t    latchAccess: function latchAccess(address) {\n\t        // Does nothing. This is used by MMC2.\n\t    },\n\t\n\t    toJSON: function toJSON() {\n\t        return {\n\t            'joy1StrobeState': this.joy1StrobeState,\n\t            'joy2StrobeState': this.joy2StrobeState,\n\t            'joypadLastWrite': this.joypadLastWrite\n\t        };\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        this.joy1StrobeState = s.joy1StrobeState;\n\t        this.joy2StrobeState = s.joy2StrobeState;\n\t        this.joypadLastWrite = s.joypadLastWrite;\n\t    }\n\t};\n\t\n\tMappers[1] = function (nes) {\n\t    this.nes = nes;\n\t};\n\t\n\tMappers[1].prototype = new Mappers[0]();\n\t\n\tMappers[1].prototype.reset = function () {\n\t    Mappers[0].prototype.reset.apply(this);\n\t\n\t    // 5-bit buffer:\n\t    this.regBuffer = 0;\n\t    this.regBufferCounter = 0;\n\t\n\t    // Register 0:\n\t    this.mirroring = 0;\n\t    this.oneScreenMirroring = 0;\n\t    this.prgSwitchingArea = 1;\n\t    this.prgSwitchingSize = 1;\n\t    this.vromSwitchingSize = 0;\n\t\n\t    // Register 1:\n\t    this.romSelectionReg0 = 0;\n\t\n\t    // Register 2:\n\t    this.romSelectionReg1 = 0;\n\t\n\t    // Register 3:\n\t    this.romBankSelect = 0;\n\t};\n\t\n\tMappers[1].prototype.write = function (address, value) {\n\t    // Writes to addresses other than MMC registers are handled by NoMapper.\n\t    if (address < 0x8000) {\n\t        Mappers[0].prototype.write.apply(this, arguments);\n\t        return;\n\t    }\n\t\n\t    // See what should be done with the written value:\n\t    if ((value & 128) !== 0) {\n\t\n\t        // Reset buffering:\n\t        this.regBufferCounter = 0;\n\t        this.regBuffer = 0;\n\t\n\t        // Reset register:\n\t        if (this.getRegNumber(address) === 0) {\n\t\n\t            this.prgSwitchingArea = 1;\n\t            this.prgSwitchingSize = 1;\n\t        }\n\t    } else {\n\t\n\t        // Continue buffering:\n\t        //regBuffer = (regBuffer & (0xFF-(1<<regBufferCounter))) | ((value & (1<<regBufferCounter))<<regBufferCounter);\n\t        this.regBuffer = this.regBuffer & 0xFF - (1 << this.regBufferCounter) | (value & 1) << this.regBufferCounter;\n\t        this.regBufferCounter++;\n\t\n\t        if (this.regBufferCounter == 5) {\n\t            // Use the buffered value:\n\t            this.setReg(this.getRegNumber(address), this.regBuffer);\n\t\n\t            // Reset buffer:\n\t            this.regBuffer = 0;\n\t            this.regBufferCounter = 0;\n\t        }\n\t    }\n\t};\n\t\n\tMappers[1].prototype.setReg = function (reg, value) {\n\t    var tmp;\n\t\n\t    switch (reg) {\n\t        case 0:\n\t            // Mirroring:\n\t            tmp = value & 3;\n\t            if (tmp !== this.mirroring) {\n\t                // Set mirroring:\n\t                this.mirroring = tmp;\n\t                if ((this.mirroring & 2) === 0) {\n\t                    // SingleScreen mirroring overrides the other setting:\n\t                    this.nes.ppu.setMirroring(this.nes.rom.SINGLESCREEN_MIRRORING);\n\t                }\n\t                // Not overridden by SingleScreen mirroring.\n\t                else if ((this.mirroring & 1) !== 0) {\n\t                        this.nes.ppu.setMirroring(this.nes.rom.HORIZONTAL_MIRRORING);\n\t                    } else {\n\t                        this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n\t                    }\n\t            }\n\t\n\t            // PRG Switching Area;\n\t            this.prgSwitchingArea = value >> 2 & 1;\n\t\n\t            // PRG Switching Size:\n\t            this.prgSwitchingSize = value >> 3 & 1;\n\t\n\t            // VROM Switching Size:\n\t            this.vromSwitchingSize = value >> 4 & 1;\n\t\n\t            break;\n\t\n\t        case 1:\n\t            // ROM selection:\n\t            this.romSelectionReg0 = value >> 4 & 1;\n\t\n\t            // Check whether the cart has VROM:\n\t            if (this.nes.rom.vromCount > 0) {\n\t\n\t                // Select VROM bank at 0x0000:\n\t                if (this.vromSwitchingSize === 0) {\n\t\n\t                    // Swap 8kB VROM:\n\t                    if (this.romSelectionReg0 === 0) {\n\t                        this.load8kVromBank(value & 0xF, 0x0000);\n\t                    } else {\n\t                        this.load8kVromBank(Math.floor(this.nes.rom.vromCount / 2) + (value & 0xF), 0x0000);\n\t                    }\n\t                } else {\n\t                    // Swap 4kB VROM:\n\t                    if (this.romSelectionReg0 === 0) {\n\t                        this.loadVromBank(value & 0xF, 0x0000);\n\t                    } else {\n\t                        this.loadVromBank(Math.floor(this.nes.rom.vromCount / 2) + (value & 0xF), 0x0000);\n\t                    }\n\t                }\n\t            }\n\t\n\t            break;\n\t\n\t        case 2:\n\t            // ROM selection:\n\t            this.romSelectionReg1 = value >> 4 & 1;\n\t\n\t            // Check whether the cart has VROM:\n\t            if (this.nes.rom.vromCount > 0) {\n\t\n\t                // Select VROM bank at 0x1000:\n\t                if (this.vromSwitchingSize === 1) {\n\t                    // Swap 4kB of VROM:\n\t                    if (this.romSelectionReg1 === 0) {\n\t                        this.loadVromBank(value & 0xF, 0x1000);\n\t                    } else {\n\t                        this.loadVromBank(Math.floor(this.nes.rom.vromCount / 2) + (value & 0xF), 0x1000);\n\t                    }\n\t                }\n\t            }\n\t            break;\n\t\n\t        default:\n\t            // Select ROM bank:\n\t            // -------------------------\n\t            tmp = value & 0xF;\n\t            var bank;\n\t            var baseBank = 0;\n\t\n\t            if (this.nes.rom.romCount >= 32) {\n\t                // 1024 kB cart\n\t                if (this.vromSwitchingSize === 0) {\n\t                    if (this.romSelectionReg0 === 1) {\n\t                        baseBank = 16;\n\t                    }\n\t                } else {\n\t                    baseBank = (this.romSelectionReg0 | this.romSelectionReg1 << 1) << 3;\n\t                }\n\t            } else if (this.nes.rom.romCount >= 16) {\n\t                // 512 kB cart\n\t                if (this.romSelectionReg0 === 1) {\n\t                    baseBank = 8;\n\t                }\n\t            }\n\t\n\t            if (this.prgSwitchingSize === 0) {\n\t                // 32kB\n\t                bank = baseBank + (value & 0xF);\n\t                this.load32kRomBank(bank, 0x8000);\n\t            } else {\n\t                // 16kB\n\t                bank = baseBank * 2 + (value & 0xF);\n\t                if (this.prgSwitchingArea === 0) {\n\t                    this.loadRomBank(bank, 0xC000);\n\t                } else {\n\t                    this.loadRomBank(bank, 0x8000);\n\t                }\n\t            }\n\t    }\n\t};\n\t\n\t// Returns the register number from the address written to:\n\tMappers[1].prototype.getRegNumber = function (address) {\n\t    if (address >= 0x8000 && address <= 0x9FFF) {\n\t        return 0;\n\t    } else if (address >= 0xA000 && address <= 0xBFFF) {\n\t        return 1;\n\t    } else if (address >= 0xC000 && address <= 0xDFFF) {\n\t        return 2;\n\t    } else {\n\t        return 3;\n\t    }\n\t};\n\t\n\tMappers[1].prototype.loadROM = function (rom) {\n\t    if (!this.nes.rom.valid) {\n\t        alert(\"MMC1: Invalid ROM! Unable to load.\");\n\t        return;\n\t    }\n\t\n\t    // Load PRG-ROM:\n\t    this.loadRomBank(0, 0x8000); //   First ROM bank..\n\t    this.loadRomBank(this.nes.rom.romCount - 1, 0xC000); // ..and last ROM bank.\n\t\n\t    // Load CHR-ROM:\n\t    this.loadCHRROM();\n\t\n\t    // Load Battery RAM (if present):\n\t    this.loadBatteryRam();\n\t\n\t    // Do Reset-Interrupt:\n\t    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n\t};\n\t\n\tMappers[1].prototype.switchLowHighPrgRom = function (oldSetting) {\n\t    // not yet.\n\t};\n\t\n\tMappers[1].prototype.switch16to32 = function () {\n\t    // not yet.\n\t};\n\t\n\tMappers[1].prototype.switch32to16 = function () {\n\t    // not yet.\n\t};\n\t\n\tMappers[1].prototype.toJSON = function () {\n\t    var s = Mappers[0].prototype.toJSON.apply(this);\n\t    s.mirroring = this.mirroring;\n\t    s.oneScreenMirroring = this.oneScreenMirroring;\n\t    s.prgSwitchingArea = this.prgSwitchingArea;\n\t    s.prgSwitchingSize = this.prgSwitchingSize;\n\t    s.vromSwitchingSize = this.vromSwitchingSize;\n\t    s.romSelectionReg0 = this.romSelectionReg0;\n\t    s.romSelectionReg1 = this.romSelectionReg1;\n\t    s.romBankSelect = this.romBankSelect;\n\t    s.regBuffer = this.regBuffer;\n\t    s.regBufferCounter = this.regBufferCounter;\n\t    return s;\n\t};\n\t\n\tMappers[1].prototype.fromJSON = function (s) {\n\t    Mappers[0].prototype.fromJSON.apply(this, s);\n\t    this.mirroring = s.mirroring;\n\t    this.oneScreenMirroring = s.oneScreenMirroring;\n\t    this.prgSwitchingArea = s.prgSwitchingArea;\n\t    this.prgSwitchingSize = s.prgSwitchingSize;\n\t    this.vromSwitchingSize = s.vromSwitchingSize;\n\t    this.romSelectionReg0 = s.romSelectionReg0;\n\t    this.romSelectionReg1 = s.romSelectionReg1;\n\t    this.romBankSelect = s.romBankSelect;\n\t    this.regBuffer = s.regBuffer;\n\t    this.regBufferCounter = s.regBufferCounter;\n\t};\n\t\n\tMappers[2] = function (nes) {\n\t    this.nes = nes;\n\t};\n\t\n\tMappers[2].prototype = new Mappers[0]();\n\t\n\tMappers[2].prototype.write = function (address, value) {\n\t    // Writes to addresses other than MMC registers are handled by NoMapper.\n\t    if (address < 0x8000) {\n\t        Mappers[0].prototype.write.apply(this, arguments);\n\t        return;\n\t    } else {\n\t        // This is a ROM bank select command.\n\t        // Swap in the given ROM bank at 0x8000:\n\t        this.loadRomBank(value, 0x8000);\n\t    }\n\t};\n\t\n\tMappers[2].prototype.loadROM = function (rom) {\n\t    if (!this.nes.rom.valid) {\n\t        alert(\"UNROM: Invalid ROM! Unable to load.\");\n\t        return;\n\t    }\n\t\n\t    // Load PRG-ROM:\n\t    this.loadRomBank(0, 0x8000);\n\t    this.loadRomBank(this.nes.rom.romCount - 1, 0xC000);\n\t\n\t    // Load CHR-ROM:\n\t    this.loadCHRROM();\n\t\n\t    // Do Reset-Interrupt:\n\t    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n\t};\n\t\n\tMappers[4] = function (nes) {\n\t    this.nes = nes;\n\t\n\t    this.CMD_SEL_2_1K_VROM_0000 = 0;\n\t    this.CMD_SEL_2_1K_VROM_0800 = 1;\n\t    this.CMD_SEL_1K_VROM_1000 = 2;\n\t    this.CMD_SEL_1K_VROM_1400 = 3;\n\t    this.CMD_SEL_1K_VROM_1800 = 4;\n\t    this.CMD_SEL_1K_VROM_1C00 = 5;\n\t    this.CMD_SEL_ROM_PAGE1 = 6;\n\t    this.CMD_SEL_ROM_PAGE2 = 7;\n\t\n\t    this.command = null;\n\t    this.prgAddressSelect = null;\n\t    this.chrAddressSelect = null;\n\t    this.pageNumber = null;\n\t    this.irqCounter = null;\n\t    this.irqLatchValue = null;\n\t    this.irqEnable = null;\n\t    this.prgAddressChanged = false;\n\t};\n\t\n\tMappers[4].prototype = new Mappers[0]();\n\t\n\tMappers[4].prototype.write = function (address, value) {\n\t    // Writes to addresses other than MMC registers are handled by NoMapper.\n\t    if (address < 0x8000) {\n\t        Mappers[0].prototype.write.apply(this, arguments);\n\t        return;\n\t    }\n\t\n\t    switch (address) {\n\t        case 0x8000:\n\t            // Command/Address Select register\n\t            this.command = value & 7;\n\t            var tmp = value >> 6 & 1;\n\t            if (tmp != this.prgAddressSelect) {\n\t                this.prgAddressChanged = true;\n\t            }\n\t            this.prgAddressSelect = tmp;\n\t            this.chrAddressSelect = value >> 7 & 1;\n\t            break;\n\t\n\t        case 0x8001:\n\t            // Page number for command\n\t            this.executeCommand(this.command, value);\n\t            break;\n\t\n\t        case 0xA000:\n\t            // Mirroring select\n\t            if ((value & 1) !== 0) {\n\t                this.nes.ppu.setMirroring(this.nes.rom.HORIZONTAL_MIRRORING);\n\t            } else {\n\t                this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n\t            }\n\t            break;\n\t\n\t        case 0xA001:\n\t            // SaveRAM Toggle\n\t            // TODO\n\t            //nes.getRom().setSaveState((value&1)!=0);\n\t            break;\n\t\n\t        case 0xC000:\n\t            // IRQ Counter register\n\t            this.irqCounter = value;\n\t            //nes.ppu.mapperIrqCounter = 0;\n\t            break;\n\t\n\t        case 0xC001:\n\t            // IRQ Latch register\n\t            this.irqLatchValue = value;\n\t            break;\n\t\n\t        case 0xE000:\n\t            // IRQ Control Reg 0 (disable)\n\t            //irqCounter = irqLatchValue;\n\t            this.irqEnable = 0;\n\t            break;\n\t\n\t        case 0xE001:\n\t            // IRQ Control Reg 1 (enable)\n\t            this.irqEnable = 1;\n\t            break;\n\t\n\t        default:\n\t        // Not a MMC3 register.\n\t        // The game has probably crashed,\n\t        // since it tries to write to ROM..\n\t        // IGNORE.\n\t    }\n\t};\n\t\n\tMappers[4].prototype.executeCommand = function (cmd, arg) {\n\t    switch (cmd) {\n\t        case this.CMD_SEL_2_1K_VROM_0000:\n\t            // Select 2 1KB VROM pages at 0x0000:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x0000);\n\t                this.load1kVromBank(arg + 1, 0x0400);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x1000);\n\t                this.load1kVromBank(arg + 1, 0x1400);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_2_1K_VROM_0800:\n\t            // Select 2 1KB VROM pages at 0x0800:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x0800);\n\t                this.load1kVromBank(arg + 1, 0x0C00);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x1800);\n\t                this.load1kVromBank(arg + 1, 0x1C00);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_1K_VROM_1000:\n\t            // Select 1K VROM Page at 0x1000:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x1000);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x0000);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_1K_VROM_1400:\n\t            // Select 1K VROM Page at 0x1400:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x1400);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x0400);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_1K_VROM_1800:\n\t            // Select 1K VROM Page at 0x1800:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x1800);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x0800);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_1K_VROM_1C00:\n\t            // Select 1K VROM Page at 0x1C00:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x1C00);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x0C00);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_ROM_PAGE1:\n\t            if (this.prgAddressChanged) {\n\t                // Load the two hardwired banks:\n\t                if (this.prgAddressSelect === 0) {\n\t                    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xC000);\n\t                } else {\n\t                    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0x8000);\n\t                }\n\t                this.prgAddressChanged = false;\n\t            }\n\t\n\t            // Select first switchable ROM page:\n\t            if (this.prgAddressSelect === 0) {\n\t                this.load8kRomBank(arg, 0x8000);\n\t            } else {\n\t                this.load8kRomBank(arg, 0xC000);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_ROM_PAGE2:\n\t            // Select second switchable ROM page:\n\t            this.load8kRomBank(arg, 0xA000);\n\t\n\t            // hardwire appropriate bank:\n\t            if (this.prgAddressChanged) {\n\t                // Load the two hardwired banks:\n\t                if (this.prgAddressSelect === 0) {\n\t                    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xC000);\n\t                } else {\n\t                    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0x8000);\n\t                }\n\t                this.prgAddressChanged = false;\n\t            }\n\t    }\n\t};\n\t\n\tMappers[4].prototype.loadROM = function (rom) {\n\t    if (!this.nes.rom.valid) {\n\t        alert(\"MMC3: Invalid ROM! Unable to load.\");\n\t        return;\n\t    }\n\t\n\t    // Load hardwired PRG banks (0xC000 and 0xE000):\n\t    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xC000);\n\t    this.load8kRomBank((this.nes.rom.romCount - 1) * 2 + 1, 0xE000);\n\t\n\t    // Load swappable PRG banks (0x8000 and 0xA000):\n\t    this.load8kRomBank(0, 0x8000);\n\t    this.load8kRomBank(1, 0xA000);\n\t\n\t    // Load CHR-ROM:\n\t    this.loadCHRROM();\n\t\n\t    // Load Battery RAM (if present):\n\t    this.loadBatteryRam();\n\t\n\t    // Do Reset-Interrupt:\n\t    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n\t};\n\t\n\tMappers[4].prototype.clockIrqCounter = function () {\n\t    if (this.irqEnable == 1) {\n\t        this.irqCounter--;\n\t        if (this.irqCounter < 0) {\n\t            // Trigger IRQ:\n\t            //nes.getCpu().doIrq();\n\t            this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n\t            this.irqCounter = this.irqLatchValue;\n\t        }\n\t    }\n\t};\n\t\n\tMappers[4].prototype.toJSON = function () {\n\t    var s = Mappers[0].prototype.toJSON.apply(this);\n\t    s.command = this.command;\n\t    s.prgAddressSelect = this.prgAddressSelect;\n\t    s.chrAddressSelect = this.chrAddressSelect;\n\t    s.pageNumber = this.pageNumber;\n\t    s.irqCounter = this.irqCounter;\n\t    s.irqLatchValue = this.irqLatchValue;\n\t    s.irqEnable = this.irqEnable;\n\t    s.prgAddressChanged = this.prgAddressChanged;\n\t    return s;\n\t};\n\t\n\tMappers[4].prototype.fromJSON = function (s) {\n\t    Mappers[0].prototype.fromJSON.apply(this, s);\n\t    this.command = s.command;\n\t    this.prgAddressSelect = s.prgAddressSelect;\n\t    this.chrAddressSelect = s.chrAddressSelect;\n\t    this.pageNumber = s.pageNumber;\n\t    this.irqCounter = s.irqCounter;\n\t    this.irqLatchValue = s.irqLatchValue;\n\t    this.irqEnable = s.irqEnable;\n\t    this.prgAddressChanged = s.prgAddressChanged;\n\t};\n\t\n\texports.default = Mappers;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\t// Keyboard events are bound in the UI\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar Keyboard = function Keyboard() {\n\t    var i;\n\t\n\t    this.keys = {\n\t        KEY_A: 0,\n\t        KEY_B: 1,\n\t        KEY_SELECT: 2,\n\t        KEY_START: 3,\n\t        KEY_UP: 4,\n\t        KEY_DOWN: 5,\n\t        KEY_LEFT: 6,\n\t        KEY_RIGHT: 7\n\t    };\n\t\n\t    this.state1 = new Array(8);\n\t    for (i = 0; i < this.state1.length; i++) {\n\t        this.state1[i] = 0x40;\n\t    }\n\t    this.state2 = new Array(8);\n\t    for (i = 0; i < this.state2.length; i++) {\n\t        this.state2[i] = 0x40;\n\t    }\n\t};\n\t\n\tKeyboard.prototype = {\n\t    setKey: function setKey(key, value) {\n\t        switch (key) {\n\t            case 88:\n\t                this.state1[this.keys.KEY_A] = value;break; // X\n\t            case 89:\n\t                this.state1[this.keys.KEY_B] = value;break; // Y (Central European keyboard)\n\t            case 90:\n\t                this.state1[this.keys.KEY_B] = value;break; // Z\n\t            case 17:\n\t                this.state1[this.keys.KEY_SELECT] = value;break; // Right Ctrl\n\t            case 13:\n\t                this.state1[this.keys.KEY_START] = value;break; // Enter\n\t            case 38:\n\t                this.state1[this.keys.KEY_UP] = value;break; // Up\n\t            case 40:\n\t                this.state1[this.keys.KEY_DOWN] = value;break; // Down\n\t            case 37:\n\t                this.state1[this.keys.KEY_LEFT] = value;break; // Left\n\t            case 39:\n\t                this.state1[this.keys.KEY_RIGHT] = value;break; // Right\n\t\n\t            case 103:\n\t                this.state2[this.keys.KEY_A] = value;break; // Num-7\n\t            case 105:\n\t                this.state2[this.keys.KEY_B] = value;break; // Num-9\n\t            case 99:\n\t                this.state2[this.keys.KEY_SELECT] = value;break; // Num-3\n\t            case 97:\n\t                this.state2[this.keys.KEY_START] = value;break; // Num-1\n\t            case 104:\n\t                this.state2[this.keys.KEY_UP] = value;break; // Num-8\n\t            case 98:\n\t                this.state2[this.keys.KEY_DOWN] = value;break; // Num-2\n\t            case 100:\n\t                this.state2[this.keys.KEY_LEFT] = value;break; // Num-4\n\t            case 102:\n\t                this.state2[this.keys.KEY_RIGHT] = value;break; // Num-6\n\t            default:\n\t                return true;\n\t        }\n\t        return false; // preventDefault\n\t    },\n\t\n\t    keyDown: function keyDown(evt) {\n\t        if (!this.setKey(evt.keyCode, 0x41) && evt.preventDefault) {\n\t            evt.preventDefault();\n\t        }\n\t    },\n\t\n\t    keyUp: function keyUp(evt) {\n\t        if (!this.setKey(evt.keyCode, 0x40) && evt.preventDefault) {\n\t            evt.preventDefault();\n\t        }\n\t    },\n\t\n\t    keyPress: function keyPress(evt) {\n\t        evt.preventDefault();\n\t    }\n\t};\n\t\n\texports.default = Keyboard;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** jsnes.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 52b5458688cdbb005394\n **/","'use strict';\n\nimport JSNES from './source/nes';\n\nexport const create = function(opts) {\n  return new JSNES(opts);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","'use strict';\n\n/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport CPU from './cpu';\nimport PPU from './ppu';\nimport PAPU from './papu';\nimport ROM from './rom';\nimport Keyboard from './keyboard';\n\nconst DummyUI = function(nes) {\n    this.nes = nes;\n    this.enable = function() {};\n    this.updateStatus = function() {};\n    this.writeAudio = function() {};\n    this.writeFrame = function() {};\n};\n\nconst JSNES = function(opts) {\n    this.opts = {\n        ui: DummyUI,\n        swfPath: 'lib/',\n\n        preferredFrameRate: 60,\n        fpsInterval: 500, // Time between updating FPS in ms\n        showDisplay: true,\n\n        emulateSound: false,\n        sampleRate: 44100, // Sound sample rate in hz\n\n        CPU_FREQ_NTSC: 1789772.5, //1789772.72727272d;\n        CPU_FREQ_PAL: 1773447.4\n    };\n    if (typeof opts != 'undefined') {\n        var key;\n        for (key in this.opts) {\n            if (typeof opts[key] != 'undefined') {\n                this.opts[key] = opts[key];\n            }\n        }\n    }\n\n    this.frameTime = 1000 / this.opts.preferredFrameRate;\n\n    this.ui = new this.opts.ui(this);\n    this.cpu = new CPU(this);\n    this.ppu = new PPU(this);\n    this.papu = new PAPU(this);\n    this.mmap = null; // set in loadRom()\n    this.keyboard = new Keyboard();\n\n    this.ui.updateStatus(\"Ready to load a ROM.\");\n\n    return this;\n};\n\nJSNES.VERSION = \"<%= version %>\";\n\nJSNES.prototype = {\n    isRunning: false,\n    fpsFrameCount: 0,\n    romData: null,\n\n    // Resets the system\n    reset: function() {\n        if (this.mmap !== null) {\n            this.mmap.reset();\n        }\n\n        this.cpu.reset();\n        this.ppu.reset();\n        this.papu.reset();\n    },\n\n    start: function() {\n        var self = this;\n\n        if (this.rom !== null && this.rom.valid) {\n            if (!this.isRunning) {\n                this.isRunning = true;\n\n                this.frameInterval = setInterval(function() {\n                    self.frame();\n                }, this.frameTime);\n                this.resetFps();\n                this.printFps();\n                this.fpsInterval = setInterval(function() {\n                    self.printFps();\n                }, this.opts.fpsInterval);\n            }\n        }\n        else {\n            this.ui.updateStatus(\"There is no ROM loaded, or it is invalid.\");\n        }\n    },\n\n    frame: function() {\n        this.ppu.startFrame();\n        var cycles = 0;\n        var emulateSound = this.opts.emulateSound;\n        var cpu = this.cpu;\n        var ppu = this.ppu;\n        var papu = this.papu;\n        FRAMELOOP: for (;;) {\n            if (cpu.cyclesToHalt === 0) {\n                // Execute a CPU instruction\n                cycles = cpu.emulate();\n                if (emulateSound) {\n                    papu.clockFrameCounter(cycles);\n                }\n                cycles *= 3;\n            }\n            else {\n                if (cpu.cyclesToHalt > 8) {\n                    cycles = 24;\n                    if (emulateSound) {\n                        papu.clockFrameCounter(8);\n                    }\n                    cpu.cyclesToHalt -= 8;\n                }\n                else {\n                    cycles = cpu.cyclesToHalt * 3;\n                    if (emulateSound) {\n                        papu.clockFrameCounter(cpu.cyclesToHalt);\n                    }\n                    cpu.cyclesToHalt = 0;\n                }\n            }\n\n            for (; cycles > 0; cycles--) {\n                if(ppu.curX === ppu.spr0HitX &&\n                        ppu.f_spVisibility === 1 &&\n                        ppu.scanline - 21 === ppu.spr0HitY) {\n                    // Set sprite 0 hit flag:\n                    ppu.setStatusFlag(ppu.STATUS_SPRITE0HIT, true);\n                }\n\n                if (ppu.requestEndFrame) {\n                    ppu.nmiCounter--;\n                    if (ppu.nmiCounter === 0) {\n                        ppu.requestEndFrame = false;\n                        ppu.startVBlank();\n                        break FRAMELOOP;\n                    }\n                }\n\n                ppu.curX++;\n                if (ppu.curX === 341) {\n                    ppu.curX = 0;\n                    ppu.endScanline();\n                }\n            }\n        }\n        this.fpsFrameCount++;\n    },\n\n    printFps: function() {\n        var now = +new Date();\n        var s = 'Running';\n        if (this.lastFpsTime) {\n            s += ': '+(\n                this.fpsFrameCount / ((now - this.lastFpsTime) / 1000)\n            ).toFixed(2)+' FPS';\n        }\n        this.ui.updateStatus(s);\n        this.fpsFrameCount = 0;\n        this.lastFpsTime = now;\n    },\n\n    stop: function() {\n        clearInterval(this.frameInterval);\n        clearInterval(this.fpsInterval);\n        this.isRunning = false;\n    },\n\n    reloadRom: function() {\n        if (this.romData !== null) {\n            this.loadRom(this.romData);\n        }\n    },\n\n    // Loads a ROM file into the CPU and PPU.\n    // The ROM file is validated first.\n    loadRom: function(data) {\n        if (this.isRunning) {\n            this.stop();\n        }\n\n        this.ui.updateStatus(\"Loading ROM...\");\n\n        // Load ROM file:\n        this.rom = new ROM(this);\n        this.rom.load(data);\n\n        if (this.rom.valid) {\n            this.reset();\n            this.mmap = this.rom.createMapper();\n            if (!this.mmap) {\n                return;\n            }\n            this.mmap.loadROM();\n            this.ppu.setMirroring(this.rom.getMirroringType());\n            this.romData = data;\n\n            this.ui.updateStatus(\"Successfully loaded. Ready to be started.\");\n        }\n        else {\n            this.ui.updateStatus(\"Invalid ROM!\");\n        }\n        return this.rom.valid;\n    },\n\n    resetFps: function() {\n        this.lastFpsTime = null;\n        this.fpsFrameCount = 0;\n    },\n\n    setFramerate: function(rate){\n        this.opts.preferredFrameRate = rate;\n        this.frameTime = 1000 / rate;\n        this.papu.setSampleRate(this.opts.sampleRate, false);\n    },\n\n    toJSON: function() {\n        return {\n            'romData': this.romData,\n            'cpu': this.cpu.toJSON(),\n            'mmap': this.mmap.toJSON(),\n            'ppu': this.ppu.toJSON()\n        };\n    },\n\n    fromJSON: function(s) {\n        this.loadRom(s.romData);\n        this.cpu.fromJSON(s.cpu);\n        this.mmap.fromJSON(s.mmap);\n        this.ppu.fromJSON(s.ppu);\n    }\n};\n\nexport default JSNES;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/nes.js\n **/","'use strict';\n\n/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport utils from './utils';\n\nconst CPU = function(nes) {\n    this.nes = nes;\n\n    // Keep Chrome happy\n    this.mem = null;\n    this.REG_ACC = null;\n    this.REG_X = null;\n    this.REG_Y = null;\n    this.REG_SP = null;\n    this.REG_PC = null;\n    this.REG_PC_NEW = null;\n    this.REG_STATUS = null;\n    this.F_CARRY = null;\n    this.F_DECIMAL = null;\n    this.F_INTERRUPT = null;\n    this.F_INTERRUPT_NEW = null;\n    this.F_OVERFLOW = null;\n    this.F_SIGN = null;\n    this.F_ZERO = null;\n    this.F_NOTUSED = null;\n    this.F_NOTUSED_NEW = null;\n    this.F_BRK = null;\n    this.F_BRK_NEW = null;\n    this.opdata = null;\n    this.cyclesToHalt = null;\n    this.crash = null;\n    this.irqRequested = null;\n    this.irqType = null;\n\n    this.reset();\n};\n\nCPU.prototype = {\n    // IRQ Types\n    IRQ_NORMAL: 0,\n    IRQ_NMI: 1,\n    IRQ_RESET: 2,\n\n    reset: function() {\n        // Main memory\n        this.mem = new Array(0x10000);\n\n        for (var i=0; i < 0x2000; i++) {\n            this.mem[i] = 0xFF;\n        }\n        for (var p=0; p < 4; p++) {\n            var i = p*0x800;\n            this.mem[i+0x008] = 0xF7;\n            this.mem[i+0x009] = 0xEF;\n            this.mem[i+0x00A] = 0xDF;\n            this.mem[i+0x00F] = 0xBF;\n        }\n        for (var i=0x2001; i < this.mem.length; i++) {\n            this.mem[i] = 0;\n        }\n\n        // CPU Registers:\n        this.REG_ACC = 0;\n        this.REG_X = 0;\n        this.REG_Y = 0;\n        // Reset Stack pointer:\n        this.REG_SP = 0x01FF;\n        // Reset Program counter:\n        this.REG_PC = 0x8000-1;\n        this.REG_PC_NEW = 0x8000-1;\n        // Reset Status register:\n        this.REG_STATUS = 0x28;\n\n        this.setStatus(0x28);\n\n        // Set flags:\n        this.F_CARRY = 0;\n        this.F_DECIMAL = 0;\n        this.F_INTERRUPT = 1;\n        this.F_INTERRUPT_NEW = 1;\n        this.F_OVERFLOW = 0;\n        this.F_SIGN = 0;\n        this.F_ZERO = 1;\n\n        this.F_NOTUSED = 1;\n        this.F_NOTUSED_NEW = 1;\n        this.F_BRK = 1;\n        this.F_BRK_NEW = 1;\n\n        this.opdata = new CPU.OpData().opdata;\n        this.cyclesToHalt = 0;\n\n        // Reset crash flag:\n        this.crash = false;\n\n        // Interrupt notification:\n        this.irqRequested = false;\n        this.irqType = null;\n\n    },\n\n    // Emulates a single CPU instruction, returns the number of cycles\n    emulate: function() {\n        var temp;\n        var add;\n\n        // Check interrupts:\n        if(this.irqRequested){\n            temp =\n                (this.F_CARRY)|\n                ((this.F_ZERO===0?1:0)<<1)|\n                (this.F_INTERRUPT<<2)|\n                (this.F_DECIMAL<<3)|\n                (this.F_BRK<<4)|\n                (this.F_NOTUSED<<5)|\n                (this.F_OVERFLOW<<6)|\n                (this.F_SIGN<<7);\n\n            this.REG_PC_NEW = this.REG_PC;\n            this.F_INTERRUPT_NEW = this.F_INTERRUPT;\n            switch(this.irqType){\n                case 0: {\n                    // Normal IRQ:\n                    if(this.F_INTERRUPT!=0){\n                        ////System.out.println(\"Interrupt was masked.\");\n                        break;\n                    }\n                    this.doIrq(temp);\n                    ////System.out.println(\"Did normal IRQ. I=\"+this.F_INTERRUPT);\n                    break;\n                }case 1:{\n                    // NMI:\n                    this.doNonMaskableInterrupt(temp);\n                    break;\n\n                }case 2:{\n                    // Reset:\n                    this.doResetInterrupt();\n                    break;\n                }\n            }\n\n            this.REG_PC = this.REG_PC_NEW;\n            this.F_INTERRUPT = this.F_INTERRUPT_NEW;\n            this.F_BRK = this.F_BRK_NEW;\n            this.irqRequested = false;\n        }\n\n        var opinf = this.opdata[this.nes.mmap.load(this.REG_PC+1)];\n        var cycleCount = (opinf>>24);\n        var cycleAdd = 0;\n\n        // Find address mode:\n        var addrMode = (opinf >> 8) & 0xFF;\n\n        // Increment PC by number of op bytes:\n        var opaddr = this.REG_PC;\n        this.REG_PC += ((opinf >> 16) & 0xFF);\n\n        var addr = 0;\n        switch(addrMode){\n            case 0:{\n                // Zero Page mode. Use the address given after the opcode,\n                // but without high byte.\n                addr = this.load(opaddr+2);\n                break;\n\n            }case 1:{\n                // Relative mode.\n                addr = this.load(opaddr+2);\n                if(addr<0x80){\n                    addr += this.REG_PC;\n                }else{\n                    addr += this.REG_PC-256;\n                }\n                break;\n            }case 2:{\n                // Ignore. Address is implied in instruction.\n                break;\n            }case 3:{\n                // Absolute mode. Use the two bytes following the opcode as\n                // an address.\n                addr = this.load16bit(opaddr+2);\n                break;\n            }case 4:{\n                // Accumulator mode. The address is in the accumulator\n                // register.\n                addr = this.REG_ACC;\n                break;\n            }case 5:{\n                // Immediate mode. The value is given after the opcode.\n                addr = this.REG_PC;\n                break;\n            }case 6:{\n                // Zero Page Indexed mode, X as index. Use the address given\n                // after the opcode, then add the\n                // X register to it to get the final address.\n                addr = (this.load(opaddr+2)+this.REG_X)&0xFF;\n                break;\n            }case 7:{\n                // Zero Page Indexed mode, Y as index. Use the address given\n                // after the opcode, then add the\n                // Y register to it to get the final address.\n                addr = (this.load(opaddr+2)+this.REG_Y)&0xFF;\n                break;\n            }case 8:{\n                // Absolute Indexed Mode, X as index. Same as zero page\n                // indexed, but with the high byte.\n                addr = this.load16bit(opaddr+2);\n                if((addr&0xFF00)!=((addr+this.REG_X)&0xFF00)){\n                    cycleAdd = 1;\n                }\n                addr+=this.REG_X;\n                break;\n            }case 9:{\n                // Absolute Indexed Mode, Y as index. Same as zero page\n                // indexed, but with the high byte.\n                addr = this.load16bit(opaddr+2);\n                if((addr&0xFF00)!=((addr+this.REG_Y)&0xFF00)){\n                    cycleAdd = 1;\n                }\n                addr+=this.REG_Y;\n                break;\n            }case 10:{\n                // Pre-indexed Indirect mode. Find the 16-bit address\n                // starting at the given location plus\n                // the current X register. The value is the contents of that\n                // address.\n                addr = this.load(opaddr+2);\n                if((addr&0xFF00)!=((addr+this.REG_X)&0xFF00)){\n                    cycleAdd = 1;\n                }\n                addr+=this.REG_X;\n                addr&=0xFF;\n                addr = this.load16bit(addr);\n                break;\n            }case 11:{\n                // Post-indexed Indirect mode. Find the 16-bit address\n                // contained in the given location\n                // (and the one following). Add to that address the contents\n                // of the Y register. Fetch the value\n                // stored at that adress.\n                addr = this.load16bit(this.load(opaddr+2));\n                if((addr&0xFF00)!=((addr+this.REG_Y)&0xFF00)){\n                    cycleAdd = 1;\n                }\n                addr+=this.REG_Y;\n                break;\n            }case 12:{\n                // Indirect Absolute mode. Find the 16-bit address contained\n                // at the given location.\n                addr = this.load16bit(opaddr+2);// Find op\n                if(addr < 0x1FFF) {\n                    addr = this.mem[addr] + (this.mem[(addr & 0xFF00) | (((addr & 0xFF) + 1) & 0xFF)] << 8);// Read from address given in op\n                }\n                else{\n                    addr = this.nes.mmap.load(addr) + (this.nes.mmap.load((addr & 0xFF00) | (((addr & 0xFF) + 1) & 0xFF)) << 8);\n                }\n                break;\n\n            }\n\n        }\n        // Wrap around for addresses above 0xFFFF:\n        addr&=0xFFFF;\n\n        // ----------------------------------------------------------------------------------------------------\n        // Decode & execute instruction:\n        // ----------------------------------------------------------------------------------------------------\n\n        // This should be compiled to a jump table.\n        switch(opinf&0xFF){\n            case 0:{\n                // *******\n                // * ADC *\n                // *******\n\n                // Add with carry.\n                temp = this.REG_ACC + this.load(addr) + this.F_CARRY;\n                this.F_OVERFLOW = ((!(((this.REG_ACC ^ this.load(addr)) & 0x80)!=0) && (((this.REG_ACC ^ temp) & 0x80))!=0)?1:0);\n                this.F_CARRY = (temp>255?1:0);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                this.REG_ACC = (temp&255);\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 1:{\n                // *******\n                // * AND *\n                // *******\n\n                // AND memory with accumulator.\n                this.REG_ACC = this.REG_ACC & this.load(addr);\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                //this.REG_ACC = temp;\n                if(addrMode!=11)cycleCount+=cycleAdd; // PostIdxInd = 11\n                break;\n            }case 2:{\n                // *******\n                // * ASL *\n                // *******\n\n                // Shift left one bit\n                if(addrMode == 4){ // ADDR_ACC = 4\n\n                    this.F_CARRY = (this.REG_ACC>>7)&1;\n                    this.REG_ACC = (this.REG_ACC<<1)&255;\n                    this.F_SIGN = (this.REG_ACC>>7)&1;\n                    this.F_ZERO = this.REG_ACC;\n\n                }else{\n\n                    temp = this.load(addr);\n                    this.F_CARRY = (temp>>7)&1;\n                    temp = (temp<<1)&255;\n                    this.F_SIGN = (temp>>7)&1;\n                    this.F_ZERO = temp;\n                    this.write(addr, temp);\n\n                }\n                break;\n\n            }case 3:{\n\n                // *******\n                // * BCC *\n                // *******\n\n                // Branch on carry clear\n                if(this.F_CARRY == 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 4:{\n\n                // *******\n                // * BCS *\n                // *******\n\n                // Branch on carry set\n                if(this.F_CARRY == 1){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 5:{\n\n                // *******\n                // * BEQ *\n                // *******\n\n                // Branch on zero\n                if(this.F_ZERO == 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 6:{\n\n                // *******\n                // * BIT *\n                // *******\n\n                temp = this.load(addr);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_OVERFLOW = (temp>>6)&1;\n                temp &= this.REG_ACC;\n                this.F_ZERO = temp;\n                break;\n\n            }case 7:{\n\n                // *******\n                // * BMI *\n                // *******\n\n                // Branch on negative result\n                if(this.F_SIGN == 1){\n                    cycleCount++;\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 8:{\n\n                // *******\n                // * BNE *\n                // *******\n\n                // Branch on not zero\n                if(this.F_ZERO != 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 9:{\n\n                // *******\n                // * BPL *\n                // *******\n\n                // Branch on positive result\n                if(this.F_SIGN == 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 10:{\n\n                // *******\n                // * BRK *\n                // *******\n\n                this.REG_PC+=2;\n                this.push((this.REG_PC>>8)&255);\n                this.push(this.REG_PC&255);\n                this.F_BRK = 1;\n\n                this.push(\n                    (this.F_CARRY)|\n                    ((this.F_ZERO==0?1:0)<<1)|\n                    (this.F_INTERRUPT<<2)|\n                    (this.F_DECIMAL<<3)|\n                    (this.F_BRK<<4)|\n                    (this.F_NOTUSED<<5)|\n                    (this.F_OVERFLOW<<6)|\n                    (this.F_SIGN<<7)\n                );\n\n                this.F_INTERRUPT = 1;\n                //this.REG_PC = load(0xFFFE) | (load(0xFFFF) << 8);\n                this.REG_PC = this.load16bit(0xFFFE);\n                this.REG_PC--;\n                break;\n\n            }case 11:{\n\n                // *******\n                // * BVC *\n                // *******\n\n                // Branch on overflow clear\n                if(this.F_OVERFLOW == 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 12:{\n\n                // *******\n                // * BVS *\n                // *******\n\n                // Branch on overflow set\n                if(this.F_OVERFLOW == 1){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 13:{\n\n                // *******\n                // * CLC *\n                // *******\n\n                // Clear carry flag\n                this.F_CARRY = 0;\n                break;\n\n            }case 14:{\n\n                // *******\n                // * CLD *\n                // *******\n\n                // Clear decimal flag\n                this.F_DECIMAL = 0;\n                break;\n\n            }case 15:{\n\n                // *******\n                // * CLI *\n                // *******\n\n                // Clear interrupt flag\n                this.F_INTERRUPT = 0;\n                break;\n\n            }case 16:{\n\n                // *******\n                // * CLV *\n                // *******\n\n                // Clear overflow flag\n                this.F_OVERFLOW = 0;\n                break;\n\n            }case 17:{\n\n                // *******\n                // * CMP *\n                // *******\n\n                // Compare memory and accumulator:\n                temp = this.REG_ACC - this.load(addr);\n                this.F_CARRY = (temp>=0?1:0);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 18:{\n\n                // *******\n                // * CPX *\n                // *******\n\n                // Compare memory and index X:\n                temp = this.REG_X - this.load(addr);\n                this.F_CARRY = (temp>=0?1:0);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                break;\n\n            }case 19:{\n\n                // *******\n                // * CPY *\n                // *******\n\n                // Compare memory and index Y:\n                temp = this.REG_Y - this.load(addr);\n                this.F_CARRY = (temp>=0?1:0);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                break;\n\n            }case 20:{\n\n                // *******\n                // * DEC *\n                // *******\n\n                // Decrement memory by one:\n                temp = (this.load(addr)-1)&0xFF;\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                this.write(addr, temp);\n                break;\n\n            }case 21:{\n\n                // *******\n                // * DEX *\n                // *******\n\n                // Decrement index X by one:\n                this.REG_X = (this.REG_X-1)&0xFF;\n                this.F_SIGN = (this.REG_X>>7)&1;\n                this.F_ZERO = this.REG_X;\n                break;\n\n            }case 22:{\n\n                // *******\n                // * DEY *\n                // *******\n\n                // Decrement index Y by one:\n                this.REG_Y = (this.REG_Y-1)&0xFF;\n                this.F_SIGN = (this.REG_Y>>7)&1;\n                this.F_ZERO = this.REG_Y;\n                break;\n\n            }case 23:{\n\n                // *******\n                // * EOR *\n                // *******\n\n                // XOR Memory with accumulator, store in accumulator:\n                this.REG_ACC = (this.load(addr)^this.REG_ACC)&0xFF;\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 24:{\n\n                // *******\n                // * INC *\n                // *******\n\n                // Increment memory by one:\n                temp = (this.load(addr)+1)&0xFF;\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                this.write(addr, temp&0xFF);\n                break;\n\n            }case 25:{\n\n                // *******\n                // * INX *\n                // *******\n\n                // Increment index X by one:\n                this.REG_X = (this.REG_X+1)&0xFF;\n                this.F_SIGN = (this.REG_X>>7)&1;\n                this.F_ZERO = this.REG_X;\n                break;\n\n            }case 26:{\n\n                // *******\n                // * INY *\n                // *******\n\n                // Increment index Y by one:\n                this.REG_Y++;\n                this.REG_Y &= 0xFF;\n                this.F_SIGN = (this.REG_Y>>7)&1;\n                this.F_ZERO = this.REG_Y;\n                break;\n\n            }case 27:{\n\n                // *******\n                // * JMP *\n                // *******\n\n                // Jump to new location:\n                this.REG_PC = addr-1;\n                break;\n\n            }case 28:{\n\n                // *******\n                // * JSR *\n                // *******\n\n                // Jump to new location, saving return address.\n                // Push return address on stack:\n                this.push((this.REG_PC>>8)&255);\n                this.push(this.REG_PC&255);\n                this.REG_PC = addr-1;\n                break;\n\n            }case 29:{\n\n                // *******\n                // * LDA *\n                // *******\n\n                // Load accumulator with memory:\n                this.REG_ACC = this.load(addr);\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 30:{\n\n                // *******\n                // * LDX *\n                // *******\n\n                // Load index X with memory:\n                this.REG_X = this.load(addr);\n                this.F_SIGN = (this.REG_X>>7)&1;\n                this.F_ZERO = this.REG_X;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 31:{\n\n                // *******\n                // * LDY *\n                // *******\n\n                // Load index Y with memory:\n                this.REG_Y = this.load(addr);\n                this.F_SIGN = (this.REG_Y>>7)&1;\n                this.F_ZERO = this.REG_Y;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 32:{\n\n                // *******\n                // * LSR *\n                // *******\n\n                // Shift right one bit:\n                if(addrMode == 4){ // ADDR_ACC\n\n                    temp = (this.REG_ACC & 0xFF);\n                    this.F_CARRY = temp&1;\n                    temp >>= 1;\n                    this.REG_ACC = temp;\n\n                }else{\n\n                    temp = this.load(addr) & 0xFF;\n                    this.F_CARRY = temp&1;\n                    temp >>= 1;\n                    this.write(addr, temp);\n\n                }\n                this.F_SIGN = 0;\n                this.F_ZERO = temp;\n                break;\n\n            }case 33:{\n\n                // *******\n                // * NOP *\n                // *******\n\n                // No OPeration.\n                // Ignore.\n                break;\n\n            }case 34:{\n\n                // *******\n                // * ORA *\n                // *******\n\n                // OR memory with accumulator, store in accumulator.\n                temp = (this.load(addr)|this.REG_ACC)&255;\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                this.REG_ACC = temp;\n                if(addrMode!=11)cycleCount+=cycleAdd; // PostIdxInd = 11\n                break;\n\n            }case 35:{\n\n                // *******\n                // * PHA *\n                // *******\n\n                // Push accumulator on stack\n                this.push(this.REG_ACC);\n                break;\n\n            }case 36:{\n\n                // *******\n                // * PHP *\n                // *******\n\n                // Push processor status on stack\n                this.F_BRK = 1;\n                this.push(\n                    (this.F_CARRY)|\n                    ((this.F_ZERO==0?1:0)<<1)|\n                    (this.F_INTERRUPT<<2)|\n                    (this.F_DECIMAL<<3)|\n                    (this.F_BRK<<4)|\n                    (this.F_NOTUSED<<5)|\n                    (this.F_OVERFLOW<<6)|\n                    (this.F_SIGN<<7)\n                );\n                break;\n\n            }case 37:{\n\n                // *******\n                // * PLA *\n                // *******\n\n                // Pull accumulator from stack\n                this.REG_ACC = this.pull();\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                break;\n\n            }case 38:{\n\n                // *******\n                // * PLP *\n                // *******\n\n                // Pull processor status from stack\n                temp = this.pull();\n                this.F_CARRY     = (temp   )&1;\n                this.F_ZERO      = (((temp>>1)&1)==1)?0:1;\n                this.F_INTERRUPT = (temp>>2)&1;\n                this.F_DECIMAL   = (temp>>3)&1;\n                this.F_BRK       = (temp>>4)&1;\n                this.F_NOTUSED   = (temp>>5)&1;\n                this.F_OVERFLOW  = (temp>>6)&1;\n                this.F_SIGN      = (temp>>7)&1;\n\n                this.F_NOTUSED = 1;\n                break;\n\n            }case 39:{\n\n                // *******\n                // * ROL *\n                // *******\n\n                // Rotate one bit left\n                if(addrMode == 4){ // ADDR_ACC = 4\n\n                    temp = this.REG_ACC;\n                    add = this.F_CARRY;\n                    this.F_CARRY = (temp>>7)&1;\n                    temp = ((temp<<1)&0xFF)+add;\n                    this.REG_ACC = temp;\n\n                }else{\n\n                    temp = this.load(addr);\n                    add = this.F_CARRY;\n                    this.F_CARRY = (temp>>7)&1;\n                    temp = ((temp<<1)&0xFF)+add;\n                    this.write(addr, temp);\n\n                }\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                break;\n\n            }case 40:{\n\n                // *******\n                // * ROR *\n                // *******\n\n                // Rotate one bit right\n                if(addrMode == 4){ // ADDR_ACC = 4\n\n                    add = this.F_CARRY<<7;\n                    this.F_CARRY = this.REG_ACC&1;\n                    temp = (this.REG_ACC>>1)+add;\n                    this.REG_ACC = temp;\n\n                }else{\n\n                    temp = this.load(addr);\n                    add = this.F_CARRY<<7;\n                    this.F_CARRY = temp&1;\n                    temp = (temp>>1)+add;\n                    this.write(addr, temp);\n\n                }\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                break;\n\n            }case 41:{\n\n                // *******\n                // * RTI *\n                // *******\n\n                // Return from interrupt. Pull status and PC from stack.\n\n                temp = this.pull();\n                this.F_CARRY     = (temp   )&1;\n                this.F_ZERO      = ((temp>>1)&1)==0?1:0;\n                this.F_INTERRUPT = (temp>>2)&1;\n                this.F_DECIMAL   = (temp>>3)&1;\n                this.F_BRK       = (temp>>4)&1;\n                this.F_NOTUSED   = (temp>>5)&1;\n                this.F_OVERFLOW  = (temp>>6)&1;\n                this.F_SIGN      = (temp>>7)&1;\n\n                this.REG_PC = this.pull();\n                this.REG_PC += (this.pull()<<8);\n                if(this.REG_PC==0xFFFF){\n                    return;\n                }\n                this.REG_PC--;\n                this.F_NOTUSED = 1;\n                break;\n\n            }case 42:{\n\n                // *******\n                // * RTS *\n                // *******\n\n                // Return from subroutine. Pull PC from stack.\n\n                this.REG_PC = this.pull();\n                this.REG_PC += (this.pull()<<8);\n\n                if(this.REG_PC==0xFFFF){\n                    return; // return from NSF play routine:\n                }\n                break;\n\n            }case 43:{\n\n                // *******\n                // * SBC *\n                // *******\n\n                temp = this.REG_ACC-this.load(addr)-(1-this.F_CARRY);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                this.F_OVERFLOW = ((((this.REG_ACC^temp)&0x80)!=0 && ((this.REG_ACC^this.load(addr))&0x80)!=0)?1:0);\n                this.F_CARRY = (temp<0?0:1);\n                this.REG_ACC = (temp&0xFF);\n                if(addrMode!=11)cycleCount+=cycleAdd; // PostIdxInd = 11\n                break;\n\n            }case 44:{\n\n                // *******\n                // * SEC *\n                // *******\n\n                // Set carry flag\n                this.F_CARRY = 1;\n                break;\n\n            }case 45:{\n\n                // *******\n                // * SED *\n                // *******\n\n                // Set decimal mode\n                this.F_DECIMAL = 1;\n                break;\n\n            }case 46:{\n\n                // *******\n                // * SEI *\n                // *******\n\n                // Set interrupt disable status\n                this.F_INTERRUPT = 1;\n                break;\n\n            }case 47:{\n\n                // *******\n                // * STA *\n                // *******\n\n                // Store accumulator in memory\n                this.write(addr, this.REG_ACC);\n                break;\n\n            }case 48:{\n\n                // *******\n                // * STX *\n                // *******\n\n                // Store index X in memory\n                this.write(addr, this.REG_X);\n                break;\n\n            }case 49:{\n\n                // *******\n                // * STY *\n                // *******\n\n                // Store index Y in memory:\n                this.write(addr, this.REG_Y);\n                break;\n\n            }case 50:{\n\n                // *******\n                // * TAX *\n                // *******\n\n                // Transfer accumulator to index X:\n                this.REG_X = this.REG_ACC;\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                break;\n\n            }case 51:{\n\n                // *******\n                // * TAY *\n                // *******\n\n                // Transfer accumulator to index Y:\n                this.REG_Y = this.REG_ACC;\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                break;\n\n            }case 52:{\n\n                // *******\n                // * TSX *\n                // *******\n\n                // Transfer stack pointer to index X:\n                this.REG_X = (this.REG_SP-0x0100);\n                this.F_SIGN = (this.REG_SP>>7)&1;\n                this.F_ZERO = this.REG_X;\n                break;\n\n            }case 53:{\n\n                // *******\n                // * TXA *\n                // *******\n\n                // Transfer index X to accumulator:\n                this.REG_ACC = this.REG_X;\n                this.F_SIGN = (this.REG_X>>7)&1;\n                this.F_ZERO = this.REG_X;\n                break;\n\n            }case 54:{\n\n                // *******\n                // * TXS *\n                // *******\n\n                // Transfer index X to stack pointer:\n                this.REG_SP = (this.REG_X+0x0100);\n                this.stackWrap();\n                break;\n\n            }case 55:{\n\n                // *******\n                // * TYA *\n                // *******\n\n                // Transfer index Y to accumulator:\n                this.REG_ACC = this.REG_Y;\n                this.F_SIGN = (this.REG_Y>>7)&1;\n                this.F_ZERO = this.REG_Y;\n                break;\n\n            }default:{\n\n                // *******\n                // * ??? *\n                // *******\n\n                this.nes.stop();\n                this.nes.crashMessage = \"Game crashed, invalid opcode at address $\"+opaddr.toString(16);\n                break;\n\n            }\n\n        }// end of switch\n\n        return cycleCount;\n\n    },\n\n    load: function(addr){\n        if (addr < 0x2000) {\n            return this.mem[addr & 0x7FF];\n        }\n        else {\n            return this.nes.mmap.load(addr);\n        }\n    },\n\n    load16bit: function(addr){\n        if (addr < 0x1FFF) {\n            return this.mem[addr&0x7FF]\n                | (this.mem[(addr+1)&0x7FF]<<8);\n        }\n        else {\n            return this.nes.mmap.load(addr) | (this.nes.mmap.load(addr+1) << 8);\n        }\n    },\n\n    write: function(addr, val){\n        if(addr < 0x2000) {\n            this.mem[addr&0x7FF] = val;\n        }\n        else {\n            this.nes.mmap.write(addr,val);\n        }\n    },\n\n    requestIrq: function(type){\n        if(this.irqRequested){\n            if(type == this.IRQ_NORMAL){\n                return;\n            }\n            ////System.out.println(\"too fast irqs. type=\"+type);\n        }\n        this.irqRequested = true;\n        this.irqType = type;\n    },\n\n    push: function(value){\n        this.nes.mmap.write(this.REG_SP, value);\n        this.REG_SP--;\n        this.REG_SP = 0x0100 | (this.REG_SP&0xFF);\n    },\n\n    stackWrap: function(){\n        this.REG_SP = 0x0100 | (this.REG_SP&0xFF);\n    },\n\n    pull: function(){\n        this.REG_SP++;\n        this.REG_SP = 0x0100 | (this.REG_SP&0xFF);\n        return this.nes.mmap.load(this.REG_SP);\n    },\n\n    pageCrossed: function(addr1, addr2){\n        return ((addr1&0xFF00) != (addr2&0xFF00));\n    },\n\n    haltCycles: function(cycles){\n        this.cyclesToHalt += cycles;\n    },\n\n    doNonMaskableInterrupt: function(status){\n        if((this.nes.mmap.load(0x2000) & 128) != 0) { // Check whether VBlank Interrupts are enabled\n\n            this.REG_PC_NEW++;\n            this.push((this.REG_PC_NEW>>8)&0xFF);\n            this.push(this.REG_PC_NEW&0xFF);\n            //this.F_INTERRUPT_NEW = 1;\n            this.push(status);\n\n            this.REG_PC_NEW = this.nes.mmap.load(0xFFFA) | (this.nes.mmap.load(0xFFFB) << 8);\n            this.REG_PC_NEW--;\n        }\n    },\n\n    doResetInterrupt: function(){\n        this.REG_PC_NEW = this.nes.mmap.load(0xFFFC) | (this.nes.mmap.load(0xFFFD) << 8);\n        this.REG_PC_NEW--;\n    },\n\n    doIrq: function(status){\n        this.REG_PC_NEW++;\n        this.push((this.REG_PC_NEW>>8)&0xFF);\n        this.push(this.REG_PC_NEW&0xFF);\n        this.push(status);\n        this.F_INTERRUPT_NEW = 1;\n        this.F_BRK_NEW = 0;\n\n        this.REG_PC_NEW = this.nes.mmap.load(0xFFFE) | (this.nes.mmap.load(0xFFFF) << 8);\n        this.REG_PC_NEW--;\n    },\n\n    getStatus: function(){\n        return (this.F_CARRY)\n                |(this.F_ZERO<<1)\n                |(this.F_INTERRUPT<<2)\n                |(this.F_DECIMAL<<3)\n                |(this.F_BRK<<4)\n                |(this.F_NOTUSED<<5)\n                |(this.F_OVERFLOW<<6)\n                |(this.F_SIGN<<7);\n    },\n\n    setStatus: function(st){\n        this.F_CARRY     = (st   )&1;\n        this.F_ZERO      = (st>>1)&1;\n        this.F_INTERRUPT = (st>>2)&1;\n        this.F_DECIMAL   = (st>>3)&1;\n        this.F_BRK       = (st>>4)&1;\n        this.F_NOTUSED   = (st>>5)&1;\n        this.F_OVERFLOW  = (st>>6)&1;\n        this.F_SIGN      = (st>>7)&1;\n    },\n\n    JSON_PROPERTIES: [\n        'mem', 'cyclesToHalt', 'irqRequested', 'irqType',\n        // Registers\n        'REG_ACC', 'REG_X', 'REG_Y', 'REG_SP', 'REG_PC', 'REG_PC_NEW',\n        'REG_STATUS',\n        // Status\n        'F_CARRY', 'F_DECIMAL', 'F_INTERRUPT', 'F_INTERRUPT_NEW', 'F_OVERFLOW',\n        'F_SIGN', 'F_ZERO', 'F_NOTUSED', 'F_NOTUSED_NEW', 'F_BRK', 'F_BRK_NEW'\n    ],\n\n    toJSON: function() {\n        return utils.toJSON(this);\n    },\n\n    fromJSON: function(s) {\n        utils.fromJSON(this, s);\n    }\n}\n\n    // Generates and provides an array of details about instructions\n    CPU.OpData = function() {\n    this.opdata = new Array(256);\n\n    // Set all to invalid instruction (to detect crashes):\n    for(var i=0;i<256;i++) this.opdata[i]=0xFF;\n\n    // Now fill in all valid opcodes:\n\n    // ADC:\n    this.setOp(this.INS_ADC,0x69,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_ADC,0x65,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_ADC,0x75,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_ADC,0x6D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_ADC,0x7D,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_ADC,0x79,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_ADC,0x61,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_ADC,0x71,this.ADDR_POSTIDXIND,2,5);\n\n    // AND:\n    this.setOp(this.INS_AND,0x29,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_AND,0x25,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_AND,0x35,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_AND,0x2D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_AND,0x3D,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_AND,0x39,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_AND,0x21,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_AND,0x31,this.ADDR_POSTIDXIND,2,5);\n\n    // ASL:\n    this.setOp(this.INS_ASL,0x0A,this.ADDR_ACC,1,2);\n    this.setOp(this.INS_ASL,0x06,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_ASL,0x16,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_ASL,0x0E,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_ASL,0x1E,this.ADDR_ABSX,3,7);\n\n    // BCC:\n    this.setOp(this.INS_BCC,0x90,this.ADDR_REL,2,2);\n\n    // BCS:\n    this.setOp(this.INS_BCS,0xB0,this.ADDR_REL,2,2);\n\n    // BEQ:\n    this.setOp(this.INS_BEQ,0xF0,this.ADDR_REL,2,2);\n\n    // BIT:\n    this.setOp(this.INS_BIT,0x24,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_BIT,0x2C,this.ADDR_ABS,3,4);\n\n    // BMI:\n    this.setOp(this.INS_BMI,0x30,this.ADDR_REL,2,2);\n\n    // BNE:\n    this.setOp(this.INS_BNE,0xD0,this.ADDR_REL,2,2);\n\n    // BPL:\n    this.setOp(this.INS_BPL,0x10,this.ADDR_REL,2,2);\n\n    // BRK:\n    this.setOp(this.INS_BRK,0x00,this.ADDR_IMP,1,7);\n\n    // BVC:\n    this.setOp(this.INS_BVC,0x50,this.ADDR_REL,2,2);\n\n    // BVS:\n    this.setOp(this.INS_BVS,0x70,this.ADDR_REL,2,2);\n\n    // CLC:\n    this.setOp(this.INS_CLC,0x18,this.ADDR_IMP,1,2);\n\n    // CLD:\n    this.setOp(this.INS_CLD,0xD8,this.ADDR_IMP,1,2);\n\n    // CLI:\n    this.setOp(this.INS_CLI,0x58,this.ADDR_IMP,1,2);\n\n    // CLV:\n    this.setOp(this.INS_CLV,0xB8,this.ADDR_IMP,1,2);\n\n    // CMP:\n    this.setOp(this.INS_CMP,0xC9,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_CMP,0xC5,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_CMP,0xD5,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_CMP,0xCD,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_CMP,0xDD,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_CMP,0xD9,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_CMP,0xC1,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_CMP,0xD1,this.ADDR_POSTIDXIND,2,5);\n\n    // CPX:\n    this.setOp(this.INS_CPX,0xE0,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_CPX,0xE4,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_CPX,0xEC,this.ADDR_ABS,3,4);\n\n    // CPY:\n    this.setOp(this.INS_CPY,0xC0,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_CPY,0xC4,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_CPY,0xCC,this.ADDR_ABS,3,4);\n\n    // DEC:\n    this.setOp(this.INS_DEC,0xC6,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_DEC,0xD6,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_DEC,0xCE,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_DEC,0xDE,this.ADDR_ABSX,3,7);\n\n    // DEX:\n    this.setOp(this.INS_DEX,0xCA,this.ADDR_IMP,1,2);\n\n    // DEY:\n    this.setOp(this.INS_DEY,0x88,this.ADDR_IMP,1,2);\n\n    // EOR:\n    this.setOp(this.INS_EOR,0x49,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_EOR,0x45,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_EOR,0x55,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_EOR,0x4D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_EOR,0x5D,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_EOR,0x59,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_EOR,0x41,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_EOR,0x51,this.ADDR_POSTIDXIND,2,5);\n\n    // INC:\n    this.setOp(this.INS_INC,0xE6,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_INC,0xF6,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_INC,0xEE,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_INC,0xFE,this.ADDR_ABSX,3,7);\n\n    // INX:\n    this.setOp(this.INS_INX,0xE8,this.ADDR_IMP,1,2);\n\n    // INY:\n    this.setOp(this.INS_INY,0xC8,this.ADDR_IMP,1,2);\n\n    // JMP:\n    this.setOp(this.INS_JMP,0x4C,this.ADDR_ABS,3,3);\n    this.setOp(this.INS_JMP,0x6C,this.ADDR_INDABS,3,5);\n\n    // JSR:\n    this.setOp(this.INS_JSR,0x20,this.ADDR_ABS,3,6);\n\n    // LDA:\n    this.setOp(this.INS_LDA,0xA9,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_LDA,0xA5,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_LDA,0xB5,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_LDA,0xAD,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_LDA,0xBD,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_LDA,0xB9,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_LDA,0xA1,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_LDA,0xB1,this.ADDR_POSTIDXIND,2,5);\n\n\n    // LDX:\n    this.setOp(this.INS_LDX,0xA2,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_LDX,0xA6,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_LDX,0xB6,this.ADDR_ZPY,2,4);\n    this.setOp(this.INS_LDX,0xAE,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_LDX,0xBE,this.ADDR_ABSY,3,4);\n\n    // LDY:\n    this.setOp(this.INS_LDY,0xA0,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_LDY,0xA4,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_LDY,0xB4,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_LDY,0xAC,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_LDY,0xBC,this.ADDR_ABSX,3,4);\n\n    // LSR:\n    this.setOp(this.INS_LSR,0x4A,this.ADDR_ACC,1,2);\n    this.setOp(this.INS_LSR,0x46,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_LSR,0x56,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_LSR,0x4E,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_LSR,0x5E,this.ADDR_ABSX,3,7);\n\n    // NOP:\n    this.setOp(this.INS_NOP,0xEA,this.ADDR_IMP,1,2);\n\n    // ORA:\n    this.setOp(this.INS_ORA,0x09,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_ORA,0x05,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_ORA,0x15,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_ORA,0x0D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_ORA,0x1D,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_ORA,0x19,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_ORA,0x01,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_ORA,0x11,this.ADDR_POSTIDXIND,2,5);\n\n    // PHA:\n    this.setOp(this.INS_PHA,0x48,this.ADDR_IMP,1,3);\n\n    // PHP:\n    this.setOp(this.INS_PHP,0x08,this.ADDR_IMP,1,3);\n\n    // PLA:\n    this.setOp(this.INS_PLA,0x68,this.ADDR_IMP,1,4);\n\n    // PLP:\n    this.setOp(this.INS_PLP,0x28,this.ADDR_IMP,1,4);\n\n    // ROL:\n    this.setOp(this.INS_ROL,0x2A,this.ADDR_ACC,1,2);\n    this.setOp(this.INS_ROL,0x26,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_ROL,0x36,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_ROL,0x2E,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_ROL,0x3E,this.ADDR_ABSX,3,7);\n\n    // ROR:\n    this.setOp(this.INS_ROR,0x6A,this.ADDR_ACC,1,2);\n    this.setOp(this.INS_ROR,0x66,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_ROR,0x76,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_ROR,0x6E,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_ROR,0x7E,this.ADDR_ABSX,3,7);\n\n    // RTI:\n    this.setOp(this.INS_RTI,0x40,this.ADDR_IMP,1,6);\n\n    // RTS:\n    this.setOp(this.INS_RTS,0x60,this.ADDR_IMP,1,6);\n\n    // SBC:\n    this.setOp(this.INS_SBC,0xE9,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_SBC,0xE5,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_SBC,0xF5,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_SBC,0xED,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_SBC,0xFD,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_SBC,0xF9,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_SBC,0xE1,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_SBC,0xF1,this.ADDR_POSTIDXIND,2,5);\n\n    // SEC:\n    this.setOp(this.INS_SEC,0x38,this.ADDR_IMP,1,2);\n\n    // SED:\n    this.setOp(this.INS_SED,0xF8,this.ADDR_IMP,1,2);\n\n    // SEI:\n    this.setOp(this.INS_SEI,0x78,this.ADDR_IMP,1,2);\n\n    // STA:\n    this.setOp(this.INS_STA,0x85,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_STA,0x95,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_STA,0x8D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_STA,0x9D,this.ADDR_ABSX,3,5);\n    this.setOp(this.INS_STA,0x99,this.ADDR_ABSY,3,5);\n    this.setOp(this.INS_STA,0x81,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_STA,0x91,this.ADDR_POSTIDXIND,2,6);\n\n    // STX:\n    this.setOp(this.INS_STX,0x86,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_STX,0x96,this.ADDR_ZPY,2,4);\n    this.setOp(this.INS_STX,0x8E,this.ADDR_ABS,3,4);\n\n    // STY:\n    this.setOp(this.INS_STY,0x84,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_STY,0x94,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_STY,0x8C,this.ADDR_ABS,3,4);\n\n    // TAX:\n    this.setOp(this.INS_TAX,0xAA,this.ADDR_IMP,1,2);\n\n    // TAY:\n    this.setOp(this.INS_TAY,0xA8,this.ADDR_IMP,1,2);\n\n    // TSX:\n    this.setOp(this.INS_TSX,0xBA,this.ADDR_IMP,1,2);\n\n    // TXA:\n    this.setOp(this.INS_TXA,0x8A,this.ADDR_IMP,1,2);\n\n    // TXS:\n    this.setOp(this.INS_TXS,0x9A,this.ADDR_IMP,1,2);\n\n    // TYA:\n    this.setOp(this.INS_TYA,0x98,this.ADDR_IMP,1,2);\n\n    this.cycTable = new Array(\n    /*0x00*/ 7,6,2,8,3,3,5,5,3,2,2,2,4,4,6,6,\n    /*0x10*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x20*/ 6,6,2,8,3,3,5,5,4,2,2,2,4,4,6,6,\n    /*0x30*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x40*/ 6,6,2,8,3,3,5,5,3,2,2,2,3,4,6,6,\n    /*0x50*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x60*/ 6,6,2,8,3,3,5,5,4,2,2,2,5,4,6,6,\n    /*0x70*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x80*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,\n    /*0x90*/ 2,6,2,6,4,4,4,4,2,5,2,5,5,5,5,5,\n    /*0xA0*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,\n    /*0xB0*/ 2,5,2,5,4,4,4,4,2,4,2,4,4,4,4,4,\n    /*0xC0*/ 2,6,2,8,3,3,5,5,2,2,2,2,4,4,6,6,\n    /*0xD0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0xE0*/ 2,6,3,8,3,3,5,5,2,2,2,2,4,4,6,6,\n    /*0xF0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7\n    );\n\n\n    this.instname = new Array(56);\n\n    // Instruction Names:\n    this.instname[ 0] = \"ADC\";\n    this.instname[ 1] = \"AND\";\n    this.instname[ 2] = \"ASL\";\n    this.instname[ 3] = \"BCC\";\n    this.instname[ 4] = \"BCS\";\n    this.instname[ 5] = \"BEQ\";\n    this.instname[ 6] = \"BIT\";\n    this.instname[ 7] = \"BMI\";\n    this.instname[ 8] = \"BNE\";\n    this.instname[ 9] = \"BPL\";\n    this.instname[10] = \"BRK\";\n    this.instname[11] = \"BVC\";\n    this.instname[12] = \"BVS\";\n    this.instname[13] = \"CLC\";\n    this.instname[14] = \"CLD\";\n    this.instname[15] = \"CLI\";\n    this.instname[16] = \"CLV\";\n    this.instname[17] = \"CMP\";\n    this.instname[18] = \"CPX\";\n    this.instname[19] = \"CPY\";\n    this.instname[20] = \"DEC\";\n    this.instname[21] = \"DEX\";\n    this.instname[22] = \"DEY\";\n    this.instname[23] = \"EOR\";\n    this.instname[24] = \"INC\";\n    this.instname[25] = \"INX\";\n    this.instname[26] = \"INY\";\n    this.instname[27] = \"JMP\";\n    this.instname[28] = \"JSR\";\n    this.instname[29] = \"LDA\";\n    this.instname[30] = \"LDX\";\n    this.instname[31] = \"LDY\";\n    this.instname[32] = \"LSR\";\n    this.instname[33] = \"NOP\";\n    this.instname[34] = \"ORA\";\n    this.instname[35] = \"PHA\";\n    this.instname[36] = \"PHP\";\n    this.instname[37] = \"PLA\";\n    this.instname[38] = \"PLP\";\n    this.instname[39] = \"ROL\";\n    this.instname[40] = \"ROR\";\n    this.instname[41] = \"RTI\";\n    this.instname[42] = \"RTS\";\n    this.instname[43] = \"SBC\";\n    this.instname[44] = \"SEC\";\n    this.instname[45] = \"SED\";\n    this.instname[46] = \"SEI\";\n    this.instname[47] = \"STA\";\n    this.instname[48] = \"STX\";\n    this.instname[49] = \"STY\";\n    this.instname[50] = \"TAX\";\n    this.instname[51] = \"TAY\";\n    this.instname[52] = \"TSX\";\n    this.instname[53] = \"TXA\";\n    this.instname[54] = \"TXS\";\n    this.instname[55] = \"TYA\";\n\n    this.addrDesc = new Array(\n        \"Zero Page           \",\n        \"Relative            \",\n        \"Implied             \",\n        \"Absolute            \",\n        \"Accumulator         \",\n        \"Immediate           \",\n        \"Zero Page,X         \",\n        \"Zero Page,Y         \",\n        \"Absolute,X          \",\n        \"Absolute,Y          \",\n        \"Preindexed Indirect \",\n        \"Postindexed Indirect\",\n        \"Indirect Absolute   \"\n    );\n}\n\nCPU.OpData.prototype = {\n    INS_ADC: 0,\n    INS_AND: 1,\n    INS_ASL: 2,\n\n    INS_BCC: 3,\n    INS_BCS: 4,\n    INS_BEQ: 5,\n    INS_BIT: 6,\n    INS_BMI: 7,\n    INS_BNE: 8,\n    INS_BPL: 9,\n    INS_BRK: 10,\n    INS_BVC: 11,\n    INS_BVS: 12,\n\n    INS_CLC: 13,\n    INS_CLD: 14,\n    INS_CLI: 15,\n    INS_CLV: 16,\n    INS_CMP: 17,\n    INS_CPX: 18,\n    INS_CPY: 19,\n\n    INS_DEC: 20,\n    INS_DEX: 21,\n    INS_DEY: 22,\n\n    INS_EOR: 23,\n\n    INS_INC: 24,\n    INS_INX: 25,\n    INS_INY: 26,\n\n    INS_JMP: 27,\n    INS_JSR: 28,\n\n    INS_LDA: 29,\n    INS_LDX: 30,\n    INS_LDY: 31,\n    INS_LSR: 32,\n\n    INS_NOP: 33,\n\n    INS_ORA: 34,\n\n    INS_PHA: 35,\n    INS_PHP: 36,\n    INS_PLA: 37,\n    INS_PLP: 38,\n\n    INS_ROL: 39,\n    INS_ROR: 40,\n    INS_RTI: 41,\n    INS_RTS: 42,\n\n    INS_SBC: 43,\n    INS_SEC: 44,\n    INS_SED: 45,\n    INS_SEI: 46,\n    INS_STA: 47,\n    INS_STX: 48,\n    INS_STY: 49,\n\n    INS_TAX: 50,\n    INS_TAY: 51,\n    INS_TSX: 52,\n    INS_TXA: 53,\n    INS_TXS: 54,\n    INS_TYA: 55,\n\n    INS_DUMMY: 56, // dummy instruction used for 'halting' the processor some cycles\n\n    // -------------------------------- //\n\n    // Addressing modes:\n    ADDR_ZP        : 0,\n    ADDR_REL       : 1,\n    ADDR_IMP       : 2,\n    ADDR_ABS       : 3,\n    ADDR_ACC       : 4,\n    ADDR_IMM       : 5,\n    ADDR_ZPX       : 6,\n    ADDR_ZPY       : 7,\n    ADDR_ABSX      : 8,\n    ADDR_ABSY      : 9,\n    ADDR_PREIDXIND : 10,\n    ADDR_POSTIDXIND: 11,\n    ADDR_INDABS    : 12,\n\n    setOp: function(inst, op, addr, size, cycles){\n        this.opdata[op] =\n            ((inst  &0xFF)    )|\n            ((addr  &0xFF)<< 8)|\n            ((size  &0xFF)<<16)|\n            ((cycles&0xFF)<<24);\n    }\n};\n\nexport default CPU;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/cpu.js\n **/","'use strict';\n\n/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst utils = {\n    copyArrayElements: function(src, srcPos, dest, destPos, length) {\n        for (var i = 0; i < length; ++i) {\n            dest[destPos + i] = src[srcPos + i];\n        }\n    },\n\n    copyArray: function(src) {\n        var dest = new Array(src.length);\n        for (var i = 0; i < src.length; i++) {\n            dest[i] = src[i];\n        }\n        return dest;\n    },\n\n    fromJSON: function(obj, state) {\n        for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n            obj[obj.JSON_PROPERTIES[i]] = state[obj.JSON_PROPERTIES[i]];\n        }\n    },\n\n    toJSON: function(obj) {\n        var state = {};\n        for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n            state[obj.JSON_PROPERTIES[i]] = obj[obj.JSON_PROPERTIES[i]];\n        }\n        return state;\n    },\n\n    isIE: function() {\n        return (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent));\n    }\n};\n\nexport default utils;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/utils.js\n **/","/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport utils from './utils';\n\nconst PPU = function(nes) {\n    this.nes = nes;\n\n    // Keep Chrome happy\n    this.vramMem = null;\n    this.spriteMem = null;\n    this.vramAddress = null;\n    this.vramTmpAddress = null;\n    this.vramBufferedReadValue = null;\n    this.firstWrite = null;\n    this.sramAddress = null;\n    this.currentMirroring = null;\n    this.requestEndFrame = null;\n    this.nmiOk = null;\n    this.dummyCycleToggle = null;\n    this.validTileData = null;\n    this.nmiCounter = null;\n    this.scanlineAlreadyRendered = null;\n    this.f_nmiOnVblank = null;\n    this.f_spriteSize = null;\n    this.f_bgPatternTable = null;\n    this.f_spPatternTable = null;\n    this.f_addrInc = null;\n    this.f_nTblAddress = null;\n    this.f_color = null;\n    this.f_spVisibility = null;\n    this.f_bgVisibility = null;\n    this.f_spClipping = null;\n    this.f_bgClipping = null;\n    this.f_dispType = null;\n    this.cntFV = null;\n    this.cntV = null;\n    this.cntH = null;\n    this.cntVT = null;\n    this.cntHT = null;\n    this.regFV = null;\n    this.regV = null;\n    this.regH = null;\n    this.regVT = null;\n    this.regHT = null;\n    this.regFH = null;\n    this.regS = null;\n    this.curNt = null;\n    this.attrib = null;\n    this.buffer = null;\n    this.prevBuffer = null;\n    this.bgbuffer = null;\n    this.pixrendered = null;\n\n    this.validTileData = null;\n    this.scantile = null;\n    this.scanline = null;\n    this.lastRenderedScanline = null;\n    this.curX = null;\n    this.sprX = null;\n    this.sprY = null;\n    this.sprTile = null;\n    this.sprCol = null;\n    this.vertFlip = null;\n    this.horiFlip = null;\n    this.bgPriority = null;\n    this.spr0HitX = null;\n    this.spr0HitY = null;\n    this.hitSpr0 = null;\n    this.sprPalette = null;\n    this.imgPalette = null;\n    this.ptTile = null;\n    this.ntable1 = null;\n    this.currentMirroring = null;\n    this.nameTable = null;\n    this.vramMirrorTable = null;\n    this.palTable = null;\n\n\n    // Rendering Options:\n    this.showSpr0Hit = false;\n    this.clipToTvSize = true;\n\n    this.reset();\n};\n\nPPU.prototype = {\n    // Status flags:\n    STATUS_VRAMWRITE: 4,\n    STATUS_SLSPRITECOUNT: 5,\n    STATUS_SPRITE0HIT: 6,\n    STATUS_VBLANK: 7,\n\n    reset: function() {\n        var i;\n\n        // Memory\n        this.vramMem = new Array(0x8000);\n        this.spriteMem = new Array(0x100);\n        for (i=0; i<this.vramMem.length; i++) {\n            this.vramMem[i] = 0;\n        }\n        for (i=0; i<this.spriteMem.length; i++) {\n            this.spriteMem[i] = 0;\n        }\n\n        // VRAM I/O:\n        this.vramAddress = null;\n        this.vramTmpAddress = null;\n        this.vramBufferedReadValue = 0;\n        this.firstWrite = true;       // VRAM/Scroll Hi/Lo latch\n\n        // SPR-RAM I/O:\n        this.sramAddress = 0; // 8-bit only.\n\n        this.currentMirroring = -1;\n        this.requestEndFrame = false;\n        this.nmiOk = false;\n        this.dummyCycleToggle = false;\n        this.validTileData = false;\n        this.nmiCounter = 0;\n        this.scanlineAlreadyRendered = null;\n\n        // Control Flags Register 1:\n        this.f_nmiOnVblank = 0;    // NMI on VBlank. 0=disable, 1=enable\n        this.f_spriteSize = 0;     // Sprite size. 0=8x8, 1=8x16\n        this.f_bgPatternTable = 0; // Background Pattern Table address. 0=0x0000,1=0x1000\n        this.f_spPatternTable = 0; // Sprite Pattern Table address. 0=0x0000,1=0x1000\n        this.f_addrInc = 0;        // PPU Address Increment. 0=1,1=32\n        this.f_nTblAddress = 0;    // Name Table Address. 0=0x2000,1=0x2400,2=0x2800,3=0x2C00\n\n        // Control Flags Register 2:\n        this.f_color = 0;         // Background color. 0=black, 1=blue, 2=green, 4=red\n        this.f_spVisibility = 0;   // Sprite visibility. 0=not displayed,1=displayed\n        this.f_bgVisibility = 0;   // Background visibility. 0=Not Displayed,1=displayed\n        this.f_spClipping = 0;     // Sprite clipping. 0=Sprites invisible in left 8-pixel column,1=No clipping\n        this.f_bgClipping = 0;     // Background clipping. 0=BG invisible in left 8-pixel column, 1=No clipping\n        this.f_dispType = 0;       // Display type. 0=color, 1=monochrome\n\n        // Counters:\n        this.cntFV = 0;\n        this.cntV = 0;\n        this.cntH = 0;\n        this.cntVT = 0;\n        this.cntHT = 0;\n\n        // Registers:\n        this.regFV = 0;\n        this.regV = 0;\n        this.regH = 0;\n        this.regVT = 0;\n        this.regHT = 0;\n        this.regFH = 0;\n        this.regS = 0;\n\n        // These are temporary variables used in rendering and sound procedures.\n        // Their states outside of those procedures can be ignored.\n        // TODO: the use of this is a bit weird, investigate\n        this.curNt = null;\n\n        // Variables used when rendering:\n        this.attrib = new Array(32);\n        this.buffer = new Array(256*240);\n        this.prevBuffer = new Array(256*240);\n        this.bgbuffer = new Array(256*240);\n        this.pixrendered = new Array(256*240);\n\n        this.validTileData = null;\n\n        this.scantile = new Array(32);\n\n        // Initialize misc vars:\n        this.scanline = 0;\n        this.lastRenderedScanline = -1;\n        this.curX = 0;\n\n        // Sprite data:\n        this.sprX = new Array(64); // X coordinate\n        this.sprY = new Array(64); // Y coordinate\n        this.sprTile = new Array(64); // Tile Index (into pattern table)\n        this.sprCol = new Array(64); // Upper two bits of color\n        this.vertFlip = new Array(64); // Vertical Flip\n        this.horiFlip = new Array(64); // Horizontal Flip\n        this.bgPriority = new Array(64); // Background priority\n        this.spr0HitX = 0; // Sprite #0 hit X coordinate\n        this.spr0HitY = 0; // Sprite #0 hit Y coordinate\n        this.hitSpr0 = false;\n\n        // Palette data:\n        this.sprPalette = new Array(16);\n        this.imgPalette = new Array(16);\n\n        // Create pattern table tile buffers:\n        this.ptTile = new Array(512);\n        for (i=0; i<512; i++) {\n            this.ptTile[i] = new PPU.Tile();\n        }\n\n        // Create nametable buffers:\n        // Name table data:\n        this.ntable1 = new Array(4);\n        this.currentMirroring = -1;\n        this.nameTable = new Array(4);\n        for (i=0; i<4; i++) {\n            this.nameTable[i] = new PPU.NameTable(32, 32, \"Nt\"+i);\n        }\n\n        // Initialize mirroring lookup table:\n        this.vramMirrorTable = new Array(0x8000);\n        for (i=0; i<0x8000; i++) {\n            this.vramMirrorTable[i] = i;\n        }\n\n        this.palTable = new PPU.PaletteTable();\n        this.palTable.loadNTSCPalette();\n        //this.palTable.loadDefaultPalette();\n\n        this.updateControlReg1(0);\n        this.updateControlReg2(0);\n    },\n\n    // Sets Nametable mirroring.\n    setMirroring: function(mirroring){\n\n        if (mirroring == this.currentMirroring) {\n            return;\n        }\n\n        this.currentMirroring = mirroring;\n        this.triggerRendering();\n\n        // Remove mirroring:\n        if (this.vramMirrorTable === null) {\n            this.vramMirrorTable = new Array(0x8000);\n        }\n        for (var i=0; i<0x8000; i++) {\n            this.vramMirrorTable[i] = i;\n        }\n\n        // Palette mirroring:\n        this.defineMirrorRegion(0x3f20,0x3f00,0x20);\n        this.defineMirrorRegion(0x3f40,0x3f00,0x20);\n        this.defineMirrorRegion(0x3f80,0x3f00,0x20);\n        this.defineMirrorRegion(0x3fc0,0x3f00,0x20);\n\n        // Additional mirroring:\n        this.defineMirrorRegion(0x3000,0x2000,0xf00);\n        this.defineMirrorRegion(0x4000,0x0000,0x4000);\n\n        if (mirroring == this.nes.rom.HORIZONTAL_MIRRORING) {\n            // Horizontal mirroring.\n\n            this.ntable1[0] = 0;\n            this.ntable1[1] = 0;\n            this.ntable1[2] = 1;\n            this.ntable1[3] = 1;\n\n            this.defineMirrorRegion(0x2400,0x2000,0x400);\n            this.defineMirrorRegion(0x2c00,0x2800,0x400);\n\n        }else if (mirroring == this.nes.rom.VERTICAL_MIRRORING) {\n            // Vertical mirroring.\n\n            this.ntable1[0] = 0;\n            this.ntable1[1] = 1;\n            this.ntable1[2] = 0;\n            this.ntable1[3] = 1;\n\n            this.defineMirrorRegion(0x2800,0x2000,0x400);\n            this.defineMirrorRegion(0x2c00,0x2400,0x400);\n\n        }else if (mirroring == this.nes.rom.SINGLESCREEN_MIRRORING) {\n\n            // Single Screen mirroring\n\n            this.ntable1[0] = 0;\n            this.ntable1[1] = 0;\n            this.ntable1[2] = 0;\n            this.ntable1[3] = 0;\n\n            this.defineMirrorRegion(0x2400,0x2000,0x400);\n            this.defineMirrorRegion(0x2800,0x2000,0x400);\n            this.defineMirrorRegion(0x2c00,0x2000,0x400);\n\n        }else if (mirroring == this.nes.rom.SINGLESCREEN_MIRRORING2) {\n\n\n            this.ntable1[0] = 1;\n            this.ntable1[1] = 1;\n            this.ntable1[2] = 1;\n            this.ntable1[3] = 1;\n\n            this.defineMirrorRegion(0x2400,0x2400,0x400);\n            this.defineMirrorRegion(0x2800,0x2400,0x400);\n            this.defineMirrorRegion(0x2c00,0x2400,0x400);\n\n        }else {\n\n            // Assume Four-screen mirroring.\n\n            this.ntable1[0] = 0;\n            this.ntable1[1] = 1;\n            this.ntable1[2] = 2;\n            this.ntable1[3] = 3;\n\n        }\n\n    },\n\n\n    // Define a mirrored area in the address lookup table.\n    // Assumes the regions don't overlap.\n    // The 'to' region is the region that is physically in memory.\n    defineMirrorRegion: function(fromStart, toStart, size){\n        for (var i=0;i<size;i++) {\n            this.vramMirrorTable[fromStart+i] = toStart+i;\n        }\n    },\n\n    startVBlank: function(){\n\n        // Do NMI:\n        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n\n        // Make sure everything is rendered:\n        if (this.lastRenderedScanline < 239) {\n            this.renderFramePartially(\n                this.lastRenderedScanline+1,240-this.lastRenderedScanline\n            );\n        }\n\n        // End frame:\n        this.endFrame();\n\n        // Reset scanline counter:\n        this.lastRenderedScanline = -1;\n    },\n\n    endScanline: function(){\n        switch (this.scanline) {\n            case 19:\n                // Dummy scanline.\n                // May be variable length:\n                if (this.dummyCycleToggle) {\n\n                    // Remove dead cycle at end of scanline,\n                    // for next scanline:\n                    this.curX = 1;\n                    this.dummyCycleToggle = !this.dummyCycleToggle;\n\n                }\n                break;\n\n            case 20:\n                // Clear VBlank flag:\n                this.setStatusFlag(this.STATUS_VBLANK,false);\n\n                // Clear Sprite #0 hit flag:\n                this.setStatusFlag(this.STATUS_SPRITE0HIT,false);\n                this.hitSpr0 = false;\n                this.spr0HitX = -1;\n                this.spr0HitY = -1;\n\n                if (this.f_bgVisibility == 1 || this.f_spVisibility==1) {\n\n                    // Update counters:\n                    this.cntFV = this.regFV;\n                    this.cntV = this.regV;\n                    this.cntH = this.regH;\n                    this.cntVT = this.regVT;\n                    this.cntHT = this.regHT;\n\n                    if (this.f_bgVisibility==1) {\n                        // Render dummy scanline:\n                        this.renderBgScanline(false,0);\n                    }\n\n                }\n\n                if (this.f_bgVisibility==1 && this.f_spVisibility==1) {\n\n                    // Check sprite 0 hit for first scanline:\n                    this.checkSprite0(0);\n\n                }\n\n                if (this.f_bgVisibility==1 || this.f_spVisibility==1) {\n                    // Clock mapper IRQ Counter:\n                    this.nes.mmap.clockIrqCounter();\n                }\n                break;\n\n            case 261:\n                // Dead scanline, no rendering.\n                // Set VINT:\n                this.setStatusFlag(this.STATUS_VBLANK,true);\n                this.requestEndFrame = true;\n                this.nmiCounter = 9;\n\n                // Wrap around:\n                this.scanline = -1; // will be incremented to 0\n\n                break;\n\n            default:\n                if (this.scanline >= 21 && this.scanline <= 260) {\n\n                    // Render normally:\n                    if (this.f_bgVisibility == 1) {\n\n                        if (!this.scanlineAlreadyRendered) {\n                            // update scroll:\n                            this.cntHT = this.regHT;\n                            this.cntH = this.regH;\n                            this.renderBgScanline(true,this.scanline+1-21);\n                        }\n                        this.scanlineAlreadyRendered=false;\n\n                        // Check for sprite 0 (next scanline):\n                        if (!this.hitSpr0 && this.f_spVisibility == 1) {\n                            if (this.sprX[0] >= -7 &&\n                                    this.sprX[0] < 256 &&\n                                    this.sprY[0] + 1 <= (this.scanline - 20) &&\n                                    (this.sprY[0] + 1 + (\n                                        this.f_spriteSize === 0 ? 8 : 16\n                                    )) >= (this.scanline - 20)) {\n                                if (this.checkSprite0(this.scanline - 20)) {\n                                    this.hitSpr0 = true;\n                                }\n                            }\n                        }\n\n                    }\n\n                    if (this.f_bgVisibility==1 || this.f_spVisibility==1) {\n                        // Clock mapper IRQ Counter:\n                        this.nes.mmap.clockIrqCounter();\n                    }\n                }\n        }\n\n        this.scanline++;\n        this.regsToAddress();\n        this.cntsToAddress();\n\n    },\n\n    startFrame: function(){\n        // Set background color:\n        var bgColor=0;\n\n        if (this.f_dispType === 0) {\n            // Color display.\n            // f_color determines color emphasis.\n            // Use first entry of image palette as BG color.\n            bgColor = this.imgPalette[0];\n        }\n        else {\n            // Monochrome display.\n            // f_color determines the bg color.\n            switch (this.f_color) {\n                case 0:\n                    // Black\n                    bgColor = 0x00000;\n                    break;\n                case 1:\n                    // Green\n                    bgColor = 0x00FF00;\n                    break;\n                case 2:\n                    // Blue\n                    bgColor = 0xFF0000;\n                    break;\n                case 3:\n                    // Invalid. Use black.\n                    bgColor = 0x000000;\n                    break;\n                case 4:\n                    // Red\n                    bgColor = 0x0000FF;\n                    break;\n                default:\n                    // Invalid. Use black.\n                    bgColor = 0x0;\n            }\n        }\n\n        var buffer = this.buffer;\n        var i;\n        for (i=0; i<256*240; i++) {\n            buffer[i] = bgColor;\n        }\n        var pixrendered = this.pixrendered;\n        for (i=0; i<pixrendered.length; i++) {\n            pixrendered[i]=65;\n        }\n    },\n\n    endFrame: function(){\n        var i, x, y;\n        var buffer = this.buffer;\n\n        // Draw spr#0 hit coordinates:\n        if (this.showSpr0Hit) {\n            // Spr 0 position:\n            if (this.sprX[0] >= 0 && this.sprX[0] < 256 &&\n                    this.sprY[0] >= 0 && this.sprY[0] < 240) {\n                for (i=0; i<256; i++) {\n                    buffer[(this.sprY[0]<<8)+i] = 0xFF5555;\n                }\n                for (i=0; i<240; i++) {\n                    buffer[(i<<8)+this.sprX[0]] = 0xFF5555;\n                }\n            }\n            // Hit position:\n            if (this.spr0HitX >= 0 && this.spr0HitX < 256 &&\n                    this.spr0HitY >= 0 && this.spr0HitY < 240) {\n                for (i=0; i<256; i++) {\n                    buffer[(this.spr0HitY<<8)+i] = 0x55FF55;\n                }\n                for (i=0; i<240; i++) {\n                    buffer[(i<<8)+this.spr0HitX] = 0x55FF55;\n                }\n            }\n        }\n\n        // This is a bit lazy..\n        // if either the sprites or the background should be clipped,\n        // both are clipped after rendering is finished.\n        if (this.clipToTvSize || this.f_bgClipping === 0 || this.f_spClipping === 0) {\n            // Clip left 8-pixels column:\n            for (y=0;y<240;y++) {\n                for (x=0;x<8;x++) {\n                    buffer[(y<<8)+x] = 0;\n                }\n            }\n        }\n\n        if (this.clipToTvSize) {\n            // Clip right 8-pixels column too:\n            for (y=0; y<240; y++) {\n                for (x=0; x<8; x++) {\n                    buffer[(y<<8)+255-x] = 0;\n                }\n            }\n        }\n\n        // Clip top and bottom 8 pixels:\n        if (this.clipToTvSize) {\n            for (y=0; y<8; y++) {\n                for (x=0; x<256; x++) {\n                    buffer[(y<<8)+x] = 0;\n                    buffer[((239-y)<<8)+x] = 0;\n                }\n            }\n        }\n\n        if (this.nes.opts.showDisplay) {\n            this.nes.ui.writeFrame(buffer, this.prevBuffer);\n        }\n    },\n\n    updateControlReg1: function(value){\n\n        this.triggerRendering();\n\n        this.f_nmiOnVblank =    (value>>7)&1;\n        this.f_spriteSize =     (value>>5)&1;\n        this.f_bgPatternTable = (value>>4)&1;\n        this.f_spPatternTable = (value>>3)&1;\n        this.f_addrInc =        (value>>2)&1;\n        this.f_nTblAddress =     value&3;\n\n        this.regV = (value>>1)&1;\n        this.regH = value&1;\n        this.regS = (value>>4)&1;\n\n    },\n\n    updateControlReg2: function(value){\n\n        this.triggerRendering();\n\n        this.f_color =       (value>>5)&7;\n        this.f_spVisibility = (value>>4)&1;\n        this.f_bgVisibility = (value>>3)&1;\n        this.f_spClipping =   (value>>2)&1;\n        this.f_bgClipping =   (value>>1)&1;\n        this.f_dispType =      value&1;\n\n        if (this.f_dispType === 0) {\n            this.palTable.setEmphasis(this.f_color);\n        }\n        this.updatePalettes();\n    },\n\n    setStatusFlag: function(flag, value){\n        var n = 1<<flag;\n        this.nes.cpu.mem[0x2002] =\n            ((this.nes.cpu.mem[0x2002] & (255-n)) | (value?n:0));\n    },\n\n    // CPU Register $2002:\n    // Read the Status Register.\n    readStatusRegister: function(){\n\n        var tmp = this.nes.cpu.mem[0x2002];\n\n        // Reset scroll & VRAM Address toggle:\n        this.firstWrite = true;\n\n        // Clear VBlank flag:\n        this.setStatusFlag(this.STATUS_VBLANK,false);\n\n        // Fetch status data:\n        return tmp;\n\n    },\n\n    // CPU Register $2003:\n    // Write the SPR-RAM address that is used for sramWrite (Register 0x2004 in CPU memory map)\n    writeSRAMAddress: function(address) {\n        this.sramAddress = address;\n    },\n\n    // CPU Register $2004 (R):\n    // Read from SPR-RAM (Sprite RAM).\n    // The address should be set first.\n    sramLoad: function() {\n        /*short tmp = sprMem.load(sramAddress);\n        sramAddress++; // Increment address\n        sramAddress%=0x100;\n        return tmp;*/\n        return this.spriteMem[this.sramAddress];\n    },\n\n    // CPU Register $2004 (W):\n    // Write to SPR-RAM (Sprite RAM).\n    // The address should be set first.\n    sramWrite: function(value){\n        this.spriteMem[this.sramAddress] = value;\n        this.spriteRamWriteUpdate(this.sramAddress,value);\n        this.sramAddress++; // Increment address\n        this.sramAddress %= 0x100;\n    },\n\n    // CPU Register $2005:\n    // Write to scroll registers.\n    // The first write is the vertical offset, the second is the\n    // horizontal offset:\n    scrollWrite: function(value){\n        this.triggerRendering();\n\n        if (this.firstWrite) {\n            // First write, horizontal scroll:\n            this.regHT = (value>>3)&31;\n            this.regFH = value&7;\n\n        }else {\n\n            // Second write, vertical scroll:\n            this.regFV = value&7;\n            this.regVT = (value>>3)&31;\n\n        }\n        this.firstWrite = !this.firstWrite;\n\n    },\n\n    // CPU Register $2006:\n    // Sets the adress used when reading/writing from/to VRAM.\n    // The first write sets the high byte, the second the low byte.\n    writeVRAMAddress: function(address){\n\n        if (this.firstWrite) {\n\n            this.regFV = (address>>4)&3;\n            this.regV = (address>>3)&1;\n            this.regH = (address>>2)&1;\n            this.regVT = (this.regVT&7) | ((address&3)<<3);\n\n        }else {\n            this.triggerRendering();\n\n            this.regVT = (this.regVT&24) | ((address>>5)&7);\n            this.regHT = address&31;\n\n            this.cntFV = this.regFV;\n            this.cntV = this.regV;\n            this.cntH = this.regH;\n            this.cntVT = this.regVT;\n            this.cntHT = this.regHT;\n\n            this.checkSprite0(this.scanline-20);\n\n        }\n\n        this.firstWrite = !this.firstWrite;\n\n        // Invoke mapper latch:\n        this.cntsToAddress();\n        if (this.vramAddress < 0x2000) {\n            this.nes.mmap.latchAccess(this.vramAddress);\n        }\n    },\n\n    // CPU Register $2007(R):\n    // Read from PPU memory. The address should be set first.\n    vramLoad: function(){\n        var tmp;\n\n        this.cntsToAddress();\n        this.regsToAddress();\n\n        // If address is in range 0x0000-0x3EFF, return buffered values:\n        if (this.vramAddress <= 0x3EFF) {\n            tmp = this.vramBufferedReadValue;\n\n            // Update buffered value:\n            if (this.vramAddress < 0x2000) {\n                this.vramBufferedReadValue = this.vramMem[this.vramAddress];\n            }\n            else {\n                this.vramBufferedReadValue = this.mirroredLoad(\n                    this.vramAddress\n                );\n            }\n\n            // Mapper latch access:\n            if (this.vramAddress < 0x2000) {\n                this.nes.mmap.latchAccess(this.vramAddress);\n            }\n\n            // Increment by either 1 or 32, depending on d2 of Control Register 1:\n            this.vramAddress += (this.f_addrInc == 1 ? 32 : 1);\n\n            this.cntsFromAddress();\n            this.regsFromAddress();\n\n            return tmp; // Return the previous buffered value.\n        }\n\n        // No buffering in this mem range. Read normally.\n        tmp = this.mirroredLoad(this.vramAddress);\n\n        // Increment by either 1 or 32, depending on d2 of Control Register 1:\n        this.vramAddress += (this.f_addrInc == 1 ? 32 : 1);\n\n        this.cntsFromAddress();\n        this.regsFromAddress();\n\n        return tmp;\n    },\n\n    // CPU Register $2007(W):\n    // Write to PPU memory. The address should be set first.\n    vramWrite: function(value){\n\n        this.triggerRendering();\n        this.cntsToAddress();\n        this.regsToAddress();\n\n        if (this.vramAddress >= 0x2000) {\n            // Mirroring is used.\n            this.mirroredWrite(this.vramAddress,value);\n        }else {\n\n            // Write normally.\n            this.writeMem(this.vramAddress,value);\n\n            // Invoke mapper latch:\n            this.nes.mmap.latchAccess(this.vramAddress);\n\n        }\n\n        // Increment by either 1 or 32, depending on d2 of Control Register 1:\n        this.vramAddress += (this.f_addrInc==1?32:1);\n        this.regsFromAddress();\n        this.cntsFromAddress();\n\n    },\n\n    // CPU Register $4014:\n    // Write 256 bytes of main memory\n    // into Sprite RAM.\n    sramDMA: function(value){\n        var baseAddress = value * 0x100;\n        var data;\n        for (var i=this.sramAddress; i < 256; i++) {\n            data = this.nes.cpu.mem[baseAddress+i];\n            this.spriteMem[i] = data;\n            this.spriteRamWriteUpdate(i, data);\n        }\n\n        this.nes.cpu.haltCycles(513);\n\n    },\n\n    // Updates the scroll registers from a new VRAM address.\n    regsFromAddress: function(){\n\n        var address = (this.vramTmpAddress>>8)&0xFF;\n        this.regFV = (address>>4)&7;\n        this.regV = (address>>3)&1;\n        this.regH = (address>>2)&1;\n        this.regVT = (this.regVT&7) | ((address&3)<<3);\n\n        address = this.vramTmpAddress&0xFF;\n        this.regVT = (this.regVT&24) | ((address>>5)&7);\n        this.regHT = address&31;\n    },\n\n    // Updates the scroll registers from a new VRAM address.\n    cntsFromAddress: function(){\n\n        var address = (this.vramAddress>>8)&0xFF;\n        this.cntFV = (address>>4)&3;\n        this.cntV = (address>>3)&1;\n        this.cntH = (address>>2)&1;\n        this.cntVT = (this.cntVT&7) | ((address&3)<<3);\n\n        address = this.vramAddress&0xFF;\n        this.cntVT = (this.cntVT&24) | ((address>>5)&7);\n        this.cntHT = address&31;\n\n    },\n\n    regsToAddress: function(){\n        var b1  = (this.regFV&7)<<4;\n        b1 |= (this.regV&1)<<3;\n        b1 |= (this.regH&1)<<2;\n        b1 |= (this.regVT>>3)&3;\n\n        var b2  = (this.regVT&7)<<5;\n        b2 |= this.regHT&31;\n\n        this.vramTmpAddress = ((b1<<8) | b2)&0x7FFF;\n    },\n\n    cntsToAddress: function(){\n        var b1  = (this.cntFV&7)<<4;\n        b1 |= (this.cntV&1)<<3;\n        b1 |= (this.cntH&1)<<2;\n        b1 |= (this.cntVT>>3)&3;\n\n        var b2  = (this.cntVT&7)<<5;\n        b2 |= this.cntHT&31;\n\n        this.vramAddress = ((b1<<8) | b2)&0x7FFF;\n    },\n\n    incTileCounter: function(count) {\n        for (var i=count; i!==0; i--) {\n            this.cntHT++;\n            if (this.cntHT == 32) {\n                this.cntHT = 0;\n                this.cntVT++;\n                if (this.cntVT >= 30) {\n                    this.cntH++;\n                    if(this.cntH == 2) {\n                        this.cntH = 0;\n                        this.cntV++;\n                        if (this.cntV == 2) {\n                            this.cntV = 0;\n                            this.cntFV++;\n                            this.cntFV &= 0x7;\n                        }\n                    }\n                }\n            }\n        }\n    },\n\n    // Reads from memory, taking into account\n    // mirroring/mapping of address ranges.\n    mirroredLoad: function(address) {\n        return this.vramMem[this.vramMirrorTable[address]];\n    },\n\n    // Writes to memory, taking into account\n    // mirroring/mapping of address ranges.\n    mirroredWrite: function(address, value){\n        if (address>=0x3f00 && address<0x3f20) {\n            // Palette write mirroring.\n            if (address==0x3F00 || address==0x3F10) {\n                this.writeMem(0x3F00,value);\n                this.writeMem(0x3F10,value);\n\n            }else if (address==0x3F04 || address==0x3F14) {\n\n                this.writeMem(0x3F04,value);\n                this.writeMem(0x3F14,value);\n\n            }else if (address==0x3F08 || address==0x3F18) {\n\n                this.writeMem(0x3F08,value);\n                this.writeMem(0x3F18,value);\n\n            }else if (address==0x3F0C || address==0x3F1C) {\n\n                this.writeMem(0x3F0C,value);\n                this.writeMem(0x3F1C,value);\n\n            }else {\n                this.writeMem(address,value);\n            }\n\n        }else {\n\n            // Use lookup table for mirrored address:\n            if (address<this.vramMirrorTable.length) {\n                this.writeMem(this.vramMirrorTable[address],value);\n            }else {\n                // FIXME\n                alert(\"Invalid VRAM address: \"+address.toString(16));\n            }\n\n        }\n    },\n\n    triggerRendering: function(){\n        if (this.scanline >= 21 && this.scanline <= 260) {\n            // Render sprites, and combine:\n            this.renderFramePartially(\n                this.lastRenderedScanline+1,\n                this.scanline-21-this.lastRenderedScanline\n            );\n\n            // Set last rendered scanline:\n            this.lastRenderedScanline = this.scanline-21;\n        }\n    },\n\n    renderFramePartially: function(startScan, scanCount){\n        if (this.f_spVisibility == 1) {\n            this.renderSpritesPartially(startScan,scanCount,true);\n        }\n\n        if(this.f_bgVisibility == 1) {\n            var si = startScan<<8;\n            var ei = (startScan+scanCount)<<8;\n            if (ei > 0xF000) {\n                ei = 0xF000;\n            }\n            var buffer = this.buffer;\n            var bgbuffer = this.bgbuffer;\n            var pixrendered = this.pixrendered;\n            for (var destIndex=si; destIndex<ei; destIndex++) {\n                if (pixrendered[destIndex] > 0xFF) {\n                    buffer[destIndex] = bgbuffer[destIndex];\n                }\n            }\n        }\n\n        if (this.f_spVisibility == 1) {\n            this.renderSpritesPartially(startScan, scanCount, false);\n        }\n\n        this.validTileData = false;\n    },\n\n    renderBgScanline: function(bgbuffer, scan) {\n        var baseTile = (this.regS === 0 ? 0 : 256);\n        var destIndex = (scan<<8)-this.regFH;\n\n        this.curNt = this.ntable1[this.cntV+this.cntV+this.cntH];\n\n        this.cntHT = this.regHT;\n        this.cntH = this.regH;\n        this.curNt = this.ntable1[this.cntV+this.cntV+this.cntH];\n\n        if (scan<240 && (scan-this.cntFV)>=0){\n\n            var tscanoffset = this.cntFV<<3;\n            var scantile = this.scantile;\n            var attrib = this.attrib;\n            var ptTile = this.ptTile;\n            var nameTable = this.nameTable;\n            var imgPalette = this.imgPalette;\n            var pixrendered = this.pixrendered;\n            var targetBuffer = bgbuffer ? this.bgbuffer : this.buffer;\n\n            var t, tpix, att, col;\n\n            for (var tile=0;tile<32;tile++) {\n\n                if (scan>=0) {\n\n                    // Fetch tile & attrib data:\n                    if (this.validTileData) {\n                        // Get data from array:\n                        t = scantile[tile];\n                        tpix = t.pix;\n                        att = attrib[tile];\n                    }else {\n                        // Fetch data:\n                        t = ptTile[baseTile+nameTable[this.curNt].getTileIndex(this.cntHT,this.cntVT)];\n                        tpix = t.pix;\n                        att = nameTable[this.curNt].getAttrib(this.cntHT,this.cntVT);\n                        scantile[tile] = t;\n                        attrib[tile] = att;\n                    }\n\n                    // Render tile scanline:\n                    var sx = 0;\n                    var x = (tile<<3)-this.regFH;\n\n                    if (x>-8) {\n                        if (x<0) {\n                            destIndex-=x;\n                            sx = -x;\n                        }\n                        if (t.opaque[this.cntFV]) {\n                            for (;sx<8;sx++) {\n                                targetBuffer[destIndex] = imgPalette[\n                                    tpix[tscanoffset+sx]+att\n                                ];\n                                pixrendered[destIndex] |= 256;\n                                destIndex++;\n                            }\n                        }else {\n                            for (;sx<8;sx++) {\n                                col = tpix[tscanoffset+sx];\n                                if(col !== 0) {\n                                    targetBuffer[destIndex] = imgPalette[\n                                        col+att\n                                    ];\n                                    pixrendered[destIndex] |= 256;\n                                }\n                                destIndex++;\n                            }\n                        }\n                    }\n\n                }\n\n                // Increase Horizontal Tile Counter:\n                if (++this.cntHT==32) {\n                    this.cntHT=0;\n                    this.cntH++;\n                    this.cntH%=2;\n                    this.curNt = this.ntable1[(this.cntV<<1)+this.cntH];\n                }\n\n\n            }\n\n            // Tile data for one row should now have been fetched,\n            // so the data in the array is valid.\n            this.validTileData = true;\n\n        }\n\n        // update vertical scroll:\n        this.cntFV++;\n        if (this.cntFV==8) {\n            this.cntFV = 0;\n            this.cntVT++;\n            if (this.cntVT==30) {\n                this.cntVT = 0;\n                this.cntV++;\n                this.cntV%=2;\n                this.curNt = this.ntable1[(this.cntV<<1)+this.cntH];\n            }else if (this.cntVT==32) {\n                this.cntVT = 0;\n            }\n\n            // Invalidate fetched data:\n            this.validTileData = false;\n\n        }\n    },\n\n    renderSpritesPartially: function(startscan, scancount, bgPri){\n        if (this.f_spVisibility === 1) {\n\n            for (var i=0;i<64;i++) {\n                if (this.bgPriority[i]==bgPri && this.sprX[i]>=0 &&\n                        this.sprX[i]<256 && this.sprY[i]+8>=startscan &&\n                        this.sprY[i]<startscan+scancount) {\n                    // Show sprite.\n                    if (this.f_spriteSize === 0) {\n                        // 8x8 sprites\n\n                        this.srcy1 = 0;\n                        this.srcy2 = 8;\n\n                        if (this.sprY[i]<startscan) {\n                            this.srcy1 = startscan - this.sprY[i]-1;\n                        }\n\n                        if (this.sprY[i]+8 > startscan+scancount) {\n                            this.srcy2 = startscan+scancount-this.sprY[i]+1;\n                        }\n\n                        if (this.f_spPatternTable===0) {\n                            this.ptTile[this.sprTile[i]].render(this.buffer,\n                                0, this.srcy1, 8, this.srcy2, this.sprX[i],\n                                this.sprY[i]+1, this.sprCol[i], this.sprPalette,\n                                this.horiFlip[i], this.vertFlip[i], i,\n                                this.pixrendered\n                            );\n                        }else {\n                            this.ptTile[this.sprTile[i]+256].render(this.buffer, 0, this.srcy1, 8, this.srcy2, this.sprX[i], this.sprY[i]+1, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n                        }\n                    }else {\n                        // 8x16 sprites\n                        var top = this.sprTile[i];\n                        if ((top&1)!==0) {\n                            top = this.sprTile[i]-1+256;\n                        }\n\n                        var srcy1 = 0;\n                        var srcy2 = 8;\n\n                        if (this.sprY[i]<startscan) {\n                            srcy1 = startscan - this.sprY[i]-1;\n                        }\n\n                        if (this.sprY[i]+8 > startscan+scancount) {\n                            srcy2 = startscan+scancount-this.sprY[i];\n                        }\n\n                        this.ptTile[top+(this.vertFlip[i]?1:0)].render(\n                            this.buffer,\n                            0,\n                            srcy1,\n                            8,\n                            srcy2,\n                            this.sprX[i],\n                            this.sprY[i]+1,\n                            this.sprCol[i],\n                            this.sprPalette,\n                            this.horiFlip[i],\n                            this.vertFlip[i],\n                            i,\n                            this.pixrendered\n                        );\n\n                        srcy1 = 0;\n                        srcy2 = 8;\n\n                        if (this.sprY[i]+8<startscan) {\n                            srcy1 = startscan - (this.sprY[i]+8+1);\n                        }\n\n                        if (this.sprY[i]+16 > startscan+scancount) {\n                            srcy2 = startscan+scancount-(this.sprY[i]+8);\n                        }\n\n                        this.ptTile[top+(this.vertFlip[i]?0:1)].render(\n                            this.buffer,\n                            0,\n                            srcy1,\n                            8,\n                            srcy2,\n                            this.sprX[i],\n                            this.sprY[i]+1+8,\n                            this.sprCol[i],\n                            this.sprPalette,\n                            this.horiFlip[i],\n                            this.vertFlip[i],\n                            i,\n                            this.pixrendered\n                        );\n\n                    }\n                }\n            }\n        }\n    },\n\n    checkSprite0: function(scan){\n\n        this.spr0HitX = -1;\n        this.spr0HitY = -1;\n\n        var toffset;\n        var tIndexAdd = (this.f_spPatternTable === 0?0:256);\n        var x, y, t, i;\n        var bufferIndex;\n        var col;\n        var bgPri;\n\n        x = this.sprX[0];\n        y = this.sprY[0]+1;\n\n        if (this.f_spriteSize === 0) {\n            // 8x8 sprites.\n\n            // Check range:\n            if (y <= scan && y + 8 > scan && x >= -7 && x < 256) {\n\n                // Sprite is in range.\n                // Draw scanline:\n                t = this.ptTile[this.sprTile[0] + tIndexAdd];\n                col = this.sprCol[0];\n                bgPri = this.bgPriority[0];\n\n                if (this.vertFlip[0]) {\n                    toffset = 7 - (scan -y);\n                }\n                else {\n                    toffset = scan - y;\n                }\n                toffset *= 8;\n\n                bufferIndex = scan * 256 + x;\n                if (this.horiFlip[0]) {\n                    for (i = 7; i >= 0; i--) {\n                        if (x >= 0 && x < 256) {\n                            if (bufferIndex>=0 && bufferIndex<61440 &&\n                                    this.pixrendered[bufferIndex] !==0 ) {\n                                if (t.pix[toffset+i] !== 0) {\n                                    this.spr0HitX = bufferIndex % 256;\n                                    this.spr0HitY = scan;\n                                    return true;\n                                }\n                            }\n                        }\n                        x++;\n                        bufferIndex++;\n                    }\n                }\n                else {\n                    for (i = 0; i < 8; i++) {\n                        if (x >= 0 && x < 256) {\n                            if (bufferIndex >= 0 && bufferIndex < 61440 &&\n                                    this.pixrendered[bufferIndex] !==0 ) {\n                                if (t.pix[toffset+i] !== 0) {\n                                    this.spr0HitX = bufferIndex % 256;\n                                    this.spr0HitY = scan;\n                                    return true;\n                                }\n                            }\n                        }\n                        x++;\n                        bufferIndex++;\n                    }\n                }\n            }\n        }\n        else {\n            // 8x16 sprites:\n\n            // Check range:\n            if (y <= scan && y + 16 > scan && x >= -7 && x < 256) {\n                // Sprite is in range.\n                // Draw scanline:\n\n                if (this.vertFlip[0]) {\n                    toffset = 15-(scan-y);\n                }else {\n                    toffset = scan-y;\n                }\n\n                if (toffset<8) {\n                    // first half of sprite.\n                    t = this.ptTile[this.sprTile[0]+(this.vertFlip[0]?1:0)+((this.sprTile[0]&1)!==0?255:0)];\n                }else {\n                    // second half of sprite.\n                    t = this.ptTile[this.sprTile[0]+(this.vertFlip[0]?0:1)+((this.sprTile[0]&1)!==0?255:0)];\n                    if (this.vertFlip[0]) {\n                        toffset = 15-toffset;\n                    }\n                    else {\n                        toffset -= 8;\n                    }\n                }\n                toffset*=8;\n                col = this.sprCol[0];\n                bgPri = this.bgPriority[0];\n\n                bufferIndex = scan*256+x;\n                if (this.horiFlip[0]) {\n                    for (i=7;i>=0;i--) {\n                        if (x>=0 && x<256) {\n                            if (bufferIndex>=0 && bufferIndex<61440 && this.pixrendered[bufferIndex]!==0) {\n                                if (t.pix[toffset+i] !== 0) {\n                                    this.spr0HitX = bufferIndex%256;\n                                    this.spr0HitY = scan;\n                                    return true;\n                                }\n                            }\n                        }\n                        x++;\n                        bufferIndex++;\n                    }\n\n                }\n                else {\n\n                    for (i=0;i<8;i++) {\n                        if (x>=0 && x<256) {\n                            if (bufferIndex>=0 && bufferIndex<61440 && this.pixrendered[bufferIndex]!==0) {\n                                if (t.pix[toffset+i] !== 0) {\n                                    this.spr0HitX = bufferIndex%256;\n                                    this.spr0HitY = scan;\n                                    return true;\n                                }\n                            }\n                        }\n                        x++;\n                        bufferIndex++;\n                    }\n\n                }\n\n            }\n\n        }\n\n        return false;\n    },\n\n    // This will write to PPU memory, and\n    // update internally buffered data\n    // appropriately.\n    writeMem: function(address, value){\n        this.vramMem[address] = value;\n\n        // Update internally buffered data:\n        if (address < 0x2000) {\n            this.vramMem[address] = value;\n            this.patternWrite(address,value);\n        }\n        else if (address >=0x2000 && address <0x23c0) {\n            this.nameTableWrite(this.ntable1[0], address - 0x2000, value);\n        }\n        else if (address >=0x23c0 && address <0x2400) {\n            this.attribTableWrite(this.ntable1[0],address-0x23c0,value);\n        }\n        else if (address >=0x2400 && address <0x27c0) {\n            this.nameTableWrite(this.ntable1[1],address-0x2400,value);\n        }\n        else if (address >=0x27c0 && address <0x2800) {\n            this.attribTableWrite(this.ntable1[1],address-0x27c0,value);\n        }\n        else if (address >=0x2800 && address <0x2bc0) {\n            this.nameTableWrite(this.ntable1[2],address-0x2800,value);\n        }\n        else if (address >=0x2bc0 && address <0x2c00) {\n            this.attribTableWrite(this.ntable1[2],address-0x2bc0,value);\n        }\n        else if (address >=0x2c00 && address <0x2fc0) {\n            this.nameTableWrite(this.ntable1[3],address-0x2c00,value);\n        }\n        else if (address >=0x2fc0 && address <0x3000) {\n            this.attribTableWrite(this.ntable1[3],address-0x2fc0,value);\n        }\n        else if (address >=0x3f00 && address <0x3f20) {\n            this.updatePalettes();\n        }\n    },\n\n    // Reads data from $3f00 to $f20\n    // into the two buffered palettes.\n    updatePalettes: function(){\n        var i;\n\n        for (i = 0; i < 16; i++) {\n            if (this.f_dispType === 0) {\n                this.imgPalette[i] = this.palTable.getEntry(\n                    this.vramMem[0x3f00 + i] & 63\n                );\n            }\n            else {\n                this.imgPalette[i] = this.palTable.getEntry(\n                    this.vramMem[0x3f00 + i] & 32\n                );\n            }\n        }\n        for (i = 0; i < 16; i++) {\n            if (this.f_dispType === 0) {\n                this.sprPalette[i] = this.palTable.getEntry(\n                    this.vramMem[0x3f10 + i] & 63\n                );\n            }\n            else {\n                this.sprPalette[i] = this.palTable.getEntry(\n                    this.vramMem[0x3f10 + i] & 32\n                );\n            }\n        }\n    },\n\n    // Updates the internal pattern\n    // table buffers with this new byte.\n    // In vNES, there is a version of this with 4 arguments which isn't used.\n    patternWrite: function(address, value){\n        var tileIndex = Math.floor(address / 16);\n        var leftOver = address%16;\n        if (leftOver<8) {\n            this.ptTile[tileIndex].setScanline(\n                leftOver,\n                value,\n                this.vramMem[address+8]\n            );\n        }\n        else {\n            this.ptTile[tileIndex].setScanline(\n                leftOver-8,\n                this.vramMem[address-8],\n                value\n            );\n        }\n    },\n\n    // Updates the internal name table buffers\n    // with this new byte.\n    nameTableWrite: function(index, address, value){\n        this.nameTable[index].tile[address] = value;\n\n        // Update Sprite #0 hit:\n        //updateSpr0Hit();\n        this.checkSprite0(this.scanline-20);\n    },\n\n    // Updates the internal pattern\n    // table buffers with this new attribute\n    // table byte.\n    attribTableWrite: function(index, address, value){\n        this.nameTable[index].writeAttrib(address,value);\n    },\n\n    // Updates the internally buffered sprite\n    // data with this new byte of info.\n    spriteRamWriteUpdate: function(address, value) {\n        var tIndex = Math.floor(address / 4);\n\n        if (tIndex === 0) {\n            //updateSpr0Hit();\n            this.checkSprite0(this.scanline - 20);\n        }\n\n        if (address % 4 === 0) {\n            // Y coordinate\n            this.sprY[tIndex] = value;\n        }\n        else if (address % 4 == 1) {\n            // Tile index\n            this.sprTile[tIndex] = value;\n        }\n        else if (address % 4 == 2) {\n            // Attributes\n            this.vertFlip[tIndex] = ((value & 0x80) !== 0);\n            this.horiFlip[tIndex] = ((value & 0x40) !==0 );\n            this.bgPriority[tIndex] = ((value & 0x20) !== 0);\n            this.sprCol[tIndex] = (value & 3) << 2;\n\n        }\n        else if (address % 4 == 3) {\n            // X coordinate\n            this.sprX[tIndex] = value;\n        }\n    },\n\n    doNMI: function() {\n        // Set VBlank flag:\n        this.setStatusFlag(this.STATUS_VBLANK,true);\n        //nes.getCpu().doNonMaskableInterrupt();\n        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n    },\n\n    JSON_PROPERTIES: [\n        // Memory\n        'vramMem', 'spriteMem',\n        // Counters\n        'cntFV', 'cntV', 'cntH', 'cntVT', 'cntHT',\n        // Registers\n        'regFV', 'regV', 'regH', 'regVT', 'regHT', 'regFH', 'regS',\n        // VRAM addr\n        'vramAddress', 'vramTmpAddress',\n        // Control/Status registers\n        'f_nmiOnVblank', 'f_spriteSize', 'f_bgPatternTable', 'f_spPatternTable',\n        'f_addrInc', 'f_nTblAddress', 'f_color', 'f_spVisibility',\n        'f_bgVisibility', 'f_spClipping', 'f_bgClipping', 'f_dispType',\n        // VRAM I/O\n        'vramBufferedReadValue', 'firstWrite',\n        // Mirroring\n        'currentMirroring', 'vramMirrorTable', 'ntable1',\n        // SPR-RAM I/O\n        'sramAddress',\n        // Sprites. Most sprite data is rebuilt from spriteMem\n        'hitSpr0',\n        // Palettes\n        'sprPalette', 'imgPalette',\n        // Rendering progression\n        'curX', 'scanline', 'lastRenderedScanline', 'curNt', 'scantile',\n        // Used during rendering\n        'attrib', 'buffer', 'bgbuffer', 'pixrendered',\n        // Misc\n        'requestEndFrame', 'nmiOk', 'dummyCycleToggle', 'nmiCounter',\n        'validTileData', 'scanlineAlreadyRendered'\n    ],\n\n    toJSON: function() {\n        var i;\n        var state = utils.toJSON(this);\n\n        state.nameTable = [];\n        for (i = 0; i < this.nameTable.length; i++) {\n            state.nameTable[i] = this.nameTable[i].toJSON();\n        }\n\n        state.ptTile = [];\n        for (i = 0; i < this.ptTile.length; i++) {\n            state.ptTile[i] = this.ptTile[i].toJSON();\n        }\n\n        return state;\n    },\n\n    fromJSON: function(state) {\n        var i;\n\n        utils.fromJSON(this, state);\n\n        for (i = 0; i < this.nameTable.length; i++) {\n            this.nameTable[i].fromJSON(state.nameTable[i]);\n        }\n\n        for (i = 0; i < this.ptTile.length; i++) {\n            this.ptTile[i].fromJSON(state.ptTile[i]);\n        }\n\n        // Sprite data:\n        for (i = 0; i < this.spriteMem.length; i++) {\n            this.spriteRamWriteUpdate(i, this.spriteMem[i]);\n        }\n    }\n};\n\nPPU.NameTable = function(width, height, name) {\n    this.width = width;\n    this.height = height;\n    this.name = name;\n\n    this.tile = new Array(width*height);\n    this.attrib = new Array(width*height);\n};\n\nPPU.NameTable.prototype = {\n    getTileIndex: function(x, y){\n        return this.tile[y*this.width+x];\n    },\n\n    getAttrib: function(x, y){\n        return this.attrib[y*this.width+x];\n    },\n\n    writeAttrib: function(index, value){\n        var basex = (index % 8) * 4;\n        var basey = Math.floor(index / 8) * 4;\n        var add;\n        var tx, ty;\n        var attindex;\n\n        for (var sqy=0;sqy<2;sqy++) {\n            for (var sqx=0;sqx<2;sqx++) {\n                add = (value>>(2*(sqy*2+sqx)))&3;\n                for (var y=0;y<2;y++) {\n                    for (var x=0;x<2;x++) {\n                        tx = basex+sqx*2+x;\n                        ty = basey+sqy*2+y;\n                        attindex = ty*this.width+tx;\n                        this.attrib[ty*this.width+tx] = (add<<2)&12;\n                    }\n                }\n            }\n        }\n    },\n\n    toJSON: function() {\n        return {\n            'tile': this.tile,\n            'attrib': this.attrib\n        };\n    },\n\n    fromJSON: function(s) {\n        this.tile = s.tile;\n        this.attrib = s.attrib;\n    }\n};\n\n\nPPU.PaletteTable = function() {\n    this.curTable = new Array(64);\n    this.emphTable = new Array(8);\n    this.currentEmph = -1;\n};\n\nPPU.PaletteTable.prototype = {\n    reset: function() {\n        this.setEmphasis(0);\n    },\n\n    loadNTSCPalette: function() {\n        this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n        this.makeTables();\n        this.setEmphasis(0);\n    },\n\n    loadPALPalette: function() {\n        this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n        this.makeTables();\n        this.setEmphasis(0);\n    },\n\n    makeTables: function(){\n        var r, g, b, col, i, rFactor, gFactor, bFactor;\n\n        // Calculate a table for each possible emphasis setting:\n        for (var emph = 0; emph < 8; emph++) {\n\n            // Determine color component factors:\n            rFactor = 1.0;\n            gFactor = 1.0;\n            bFactor = 1.0;\n\n            if ((emph & 1) !== 0) {\n                rFactor = 0.75;\n                bFactor = 0.75;\n            }\n            if ((emph & 2) !== 0) {\n                rFactor = 0.75;\n                gFactor = 0.75;\n            }\n            if ((emph & 4) !== 0) {\n                gFactor = 0.75;\n                bFactor = 0.75;\n            }\n\n            this.emphTable[emph] = new Array(64);\n\n            // Calculate table:\n            for (i = 0; i < 64; i++) {\n                col = this.curTable[i];\n                r = Math.floor(this.getRed(col) * rFactor);\n                g = Math.floor(this.getGreen(col) * gFactor);\n                b = Math.floor(this.getBlue(col) * bFactor);\n                this.emphTable[emph][i] = this.getRgb(r, g, b);\n            }\n        }\n    },\n\n    setEmphasis: function(emph){\n        if (emph != this.currentEmph) {\n            this.currentEmph = emph;\n            for (var i = 0; i < 64; i++) {\n                this.curTable[i] = this.emphTable[emph][i];\n            }\n        }\n    },\n\n    getEntry: function(yiq){\n        return this.curTable[yiq];\n    },\n\n    getRed: function(rgb){\n        return (rgb>>16)&0xFF;\n    },\n\n    getGreen: function(rgb){\n        return (rgb>>8)&0xFF;\n    },\n\n    getBlue: function(rgb){\n        return rgb&0xFF;\n    },\n\n    getRgb: function(r, g, b){\n        return ((r<<16)|(g<<8)|(b));\n    },\n\n    loadDefaultPalette: function(){\n        this.curTable[ 0] = this.getRgb(117,117,117);\n        this.curTable[ 1] = this.getRgb( 39, 27,143);\n        this.curTable[ 2] = this.getRgb(  0,  0,171);\n        this.curTable[ 3] = this.getRgb( 71,  0,159);\n        this.curTable[ 4] = this.getRgb(143,  0,119);\n        this.curTable[ 5] = this.getRgb(171,  0, 19);\n        this.curTable[ 6] = this.getRgb(167,  0,  0);\n        this.curTable[ 7] = this.getRgb(127, 11,  0);\n        this.curTable[ 8] = this.getRgb( 67, 47,  0);\n        this.curTable[ 9] = this.getRgb(  0, 71,  0);\n        this.curTable[10] = this.getRgb(  0, 81,  0);\n        this.curTable[11] = this.getRgb(  0, 63, 23);\n        this.curTable[12] = this.getRgb( 27, 63, 95);\n        this.curTable[13] = this.getRgb(  0,  0,  0);\n        this.curTable[14] = this.getRgb(  0,  0,  0);\n        this.curTable[15] = this.getRgb(  0,  0,  0);\n        this.curTable[16] = this.getRgb(188,188,188);\n        this.curTable[17] = this.getRgb(  0,115,239);\n        this.curTable[18] = this.getRgb( 35, 59,239);\n        this.curTable[19] = this.getRgb(131,  0,243);\n        this.curTable[20] = this.getRgb(191,  0,191);\n        this.curTable[21] = this.getRgb(231,  0, 91);\n        this.curTable[22] = this.getRgb(219, 43,  0);\n        this.curTable[23] = this.getRgb(203, 79, 15);\n        this.curTable[24] = this.getRgb(139,115,  0);\n        this.curTable[25] = this.getRgb(  0,151,  0);\n        this.curTable[26] = this.getRgb(  0,171,  0);\n        this.curTable[27] = this.getRgb(  0,147, 59);\n        this.curTable[28] = this.getRgb(  0,131,139);\n        this.curTable[29] = this.getRgb(  0,  0,  0);\n        this.curTable[30] = this.getRgb(  0,  0,  0);\n        this.curTable[31] = this.getRgb(  0,  0,  0);\n        this.curTable[32] = this.getRgb(255,255,255);\n        this.curTable[33] = this.getRgb( 63,191,255);\n        this.curTable[34] = this.getRgb( 95,151,255);\n        this.curTable[35] = this.getRgb(167,139,253);\n        this.curTable[36] = this.getRgb(247,123,255);\n        this.curTable[37] = this.getRgb(255,119,183);\n        this.curTable[38] = this.getRgb(255,119, 99);\n        this.curTable[39] = this.getRgb(255,155, 59);\n        this.curTable[40] = this.getRgb(243,191, 63);\n        this.curTable[41] = this.getRgb(131,211, 19);\n        this.curTable[42] = this.getRgb( 79,223, 75);\n        this.curTable[43] = this.getRgb( 88,248,152);\n        this.curTable[44] = this.getRgb(  0,235,219);\n        this.curTable[45] = this.getRgb(  0,  0,  0);\n        this.curTable[46] = this.getRgb(  0,  0,  0);\n        this.curTable[47] = this.getRgb(  0,  0,  0);\n        this.curTable[48] = this.getRgb(255,255,255);\n        this.curTable[49] = this.getRgb(171,231,255);\n        this.curTable[50] = this.getRgb(199,215,255);\n        this.curTable[51] = this.getRgb(215,203,255);\n        this.curTable[52] = this.getRgb(255,199,255);\n        this.curTable[53] = this.getRgb(255,199,219);\n        this.curTable[54] = this.getRgb(255,191,179);\n        this.curTable[55] = this.getRgb(255,219,171);\n        this.curTable[56] = this.getRgb(255,231,163);\n        this.curTable[57] = this.getRgb(227,255,163);\n        this.curTable[58] = this.getRgb(171,243,191);\n        this.curTable[59] = this.getRgb(179,255,207);\n        this.curTable[60] = this.getRgb(159,255,243);\n        this.curTable[61] = this.getRgb(  0,  0,  0);\n        this.curTable[62] = this.getRgb(  0,  0,  0);\n        this.curTable[63] = this.getRgb(  0,  0,  0);\n\n        this.makeTables();\n        this.setEmphasis(0);\n    }\n};\n\nPPU.Tile = function() {\n    // Tile data:\n    this.pix = new Array(64);\n\n    this.fbIndex = null;\n    this.tIndex = null;\n    this.x = null;\n    this.y = null;\n    this.w = null;\n    this.h = null;\n    this.incX = null;\n    this.incY = null;\n    this.palIndex = null;\n    this.tpri = null;\n    this.c = null;\n    this.initialized = false;\n    this.opaque = new Array(8);\n};\n\nPPU.Tile.prototype = {\n    setBuffer: function(scanline){\n        for (this.y=0;this.y<8;this.y++) {\n            this.setScanline(this.y,scanline[this.y],scanline[this.y+8]);\n        }\n    },\n\n    setScanline: function(sline, b1, b2){\n        this.initialized = true;\n        this.tIndex = sline<<3;\n        for (this.x = 0; this.x < 8; this.x++) {\n            this.pix[this.tIndex + this.x] = ((b1 >> (7 - this.x)) & 1) +\n                    (((b2 >> (7 - this.x)) & 1) << 1);\n            if(this.pix[this.tIndex+this.x] === 0) {\n                this.opaque[sline] = false;\n            }\n        }\n    },\n\n    render: function(buffer, srcx1, srcy1, srcx2, srcy2, dx, dy, palAdd, palette, flipHorizontal, flipVertical, pri, priTable) {\n\n        if (dx<-7 || dx>=256 || dy<-7 || dy>=240) {\n            return;\n        }\n\n        this.w=srcx2-srcx1;\n        this.h=srcy2-srcy1;\n\n        if (dx<0) {\n            srcx1-=dx;\n        }\n        if (dx+srcx2>=256) {\n            srcx2=256-dx;\n        }\n\n        if (dy<0) {\n            srcy1-=dy;\n        }\n        if (dy+srcy2>=240) {\n            srcy2=240-dy;\n        }\n\n        if (!flipHorizontal && !flipVertical) {\n\n            this.fbIndex = (dy<<8)+dx;\n            this.tIndex = 0;\n            for (this.y=0;this.y<8;this.y++) {\n                for (this.x=0;this.x<8;this.x++) {\n                    if (this.x>=srcx1 && this.x<srcx2 && this.y>=srcy1 && this.y<srcy2) {\n                        this.palIndex = this.pix[this.tIndex];\n                        this.tpri = priTable[this.fbIndex];\n                        if (this.palIndex!==0 && pri<=(this.tpri&0xFF)) {\n                            //console.log(\"Rendering upright tile to buffer\");\n                            buffer[this.fbIndex] = palette[this.palIndex+palAdd];\n                            this.tpri = (this.tpri&0xF00)|pri;\n                            priTable[this.fbIndex] =this.tpri;\n                        }\n                    }\n                    this.fbIndex++;\n                    this.tIndex++;\n                }\n                this.fbIndex-=8;\n                this.fbIndex+=256;\n            }\n\n        }else if (flipHorizontal && !flipVertical) {\n\n            this.fbIndex = (dy<<8)+dx;\n            this.tIndex = 7;\n            for (this.y=0;this.y<8;this.y++) {\n                for (this.x=0;this.x<8;this.x++) {\n                    if (this.x>=srcx1 && this.x<srcx2 && this.y>=srcy1 && this.y<srcy2) {\n                        this.palIndex = this.pix[this.tIndex];\n                        this.tpri = priTable[this.fbIndex];\n                        if (this.palIndex!==0 && pri<=(this.tpri&0xFF)) {\n                            buffer[this.fbIndex] = palette[this.palIndex+palAdd];\n                            this.tpri = (this.tpri&0xF00)|pri;\n                            priTable[this.fbIndex] =this.tpri;\n                        }\n                    }\n                    this.fbIndex++;\n                    this.tIndex--;\n                }\n                this.fbIndex-=8;\n                this.fbIndex+=256;\n                this.tIndex+=16;\n            }\n\n        }\n        else if(flipVertical && !flipHorizontal) {\n\n            this.fbIndex = (dy<<8)+dx;\n            this.tIndex = 56;\n            for (this.y=0;this.y<8;this.y++) {\n                for (this.x=0;this.x<8;this.x++) {\n                    if (this.x>=srcx1 && this.x<srcx2 && this.y>=srcy1 && this.y<srcy2) {\n                        this.palIndex = this.pix[this.tIndex];\n                        this.tpri = priTable[this.fbIndex];\n                        if (this.palIndex!==0 && pri<=(this.tpri&0xFF)) {\n                            buffer[this.fbIndex] = palette[this.palIndex+palAdd];\n                            this.tpri = (this.tpri&0xF00)|pri;\n                            priTable[this.fbIndex] =this.tpri;\n                        }\n                    }\n                    this.fbIndex++;\n                    this.tIndex++;\n                }\n                this.fbIndex-=8;\n                this.fbIndex+=256;\n                this.tIndex-=16;\n            }\n\n        }\n        else {\n            this.fbIndex = (dy<<8)+dx;\n            this.tIndex = 63;\n            for (this.y=0;this.y<8;this.y++) {\n                for (this.x=0;this.x<8;this.x++) {\n                    if (this.x>=srcx1 && this.x<srcx2 && this.y>=srcy1 && this.y<srcy2) {\n                        this.palIndex = this.pix[this.tIndex];\n                        this.tpri = priTable[this.fbIndex];\n                        if (this.palIndex!==0 && pri<=(this.tpri&0xFF)) {\n                            buffer[this.fbIndex] = palette[this.palIndex+palAdd];\n                            this.tpri = (this.tpri&0xF00)|pri;\n                            priTable[this.fbIndex] =this.tpri;\n                        }\n                    }\n                    this.fbIndex++;\n                    this.tIndex--;\n                }\n                this.fbIndex-=8;\n                this.fbIndex+=256;\n            }\n\n        }\n\n    },\n\n    isTransparent: function(x, y){\n        return (this.pix[(y << 3) + x] === 0);\n    },\n\n    toJSON: function() {\n        return {\n            'opaque': this.opaque,\n            'pix': this.pix\n        };\n    },\n\n    fromJSON: function(s) {\n        this.opaque = s.opaque;\n        this.pix = s.pix;\n    }\n};\n\nexport default PPU;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/ppu.js\n **/","/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst PAPU = function(nes) {\n    this.nes = nes;\n\n    this.square1 = new PAPU.ChannelSquare(this, true);\n    this.square2 = new PAPU.ChannelSquare(this, false);\n    this.triangle = new PAPU.ChannelTriangle(this);\n    this.noise = new PAPU.ChannelNoise(this);\n    this.dmc = new PAPU.ChannelDM(this);\n\n    this.frameIrqCounter = null;\n    this.frameIrqCounterMax = 4;\n    this.initCounter = 2048;\n    this.channelEnableValue = null;\n\n    this.bufferSize = 8192;\n    this.bufferIndex = 0;\n    this.sampleRate = 44100;\n\n    this.lengthLookup = null;\n    this.dmcFreqLookup = null;\n    this.noiseWavelengthLookup = null;\n    this.square_table = null;\n    this.tnd_table = null;\n    this.sampleBuffer = new Array(this.bufferSize*2);\n\n    this.frameIrqEnabled = false;\n    this.frameIrqActive = null;\n    this.frameClockNow = null;\n    this.startedPlaying=false;\n    this.recordOutput = false;\n    this.initingHardware = false;\n\n    this.masterFrameCounter = null;\n    this.derivedFrameCounter = null;\n    this.countSequence = null;\n    this.sampleTimer = null;\n    this.frameTime = null;\n    this.sampleTimerMax = null;\n    this.sampleCount = null;\n    this.triValue = 0;\n\n    this.smpSquare1 = null;\n    this.smpSquare2 = null;\n    this.smpTriangle = null;\n    this.smpDmc = null;\n    this.accCount = null;\n\n    // DC removal vars:\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n    this.smpAccumL = 0;\n    this.smpAccumR = 0;\n\n    // DAC range:\n    this.dacRange = 0;\n    this.dcValue = 0;\n\n    // Master volume:\n    this.masterVolume = 256;\n\n    // Stereo positioning:\n    this.stereoPosLSquare1 = null;\n    this.stereoPosLSquare2 = null;\n    this.stereoPosLTriangle = null;\n    this.stereoPosLNoise = null;\n    this.stereoPosLDMC = null;\n    this.stereoPosRSquare1 = null;\n    this.stereoPosRSquare2 = null;\n    this.stereoPosRTriangle = null;\n    this.stereoPosRNoise = null;\n    this.stereoPosRDMC = null;\n\n    this.extraCycles = null;\n\n    this.maxSample = null;\n    this.minSample = null;\n\n    // Panning:\n    this.panning = [80, 170, 100, 150, 128];\n    this.setPanning(this.panning);\n\n    // Initialize lookup tables:\n    this.initLengthLookup();\n    this.initDmcFrequencyLookup();\n    this.initNoiseWavelengthLookup();\n    this.initDACtables();\n\n    // Init sound registers:\n    for (var i = 0; i < 0x14; i++) {\n        if (i === 0x10){\n            this.writeReg(0x4010, 0x10);\n        }\n        else {\n            this.writeReg(0x4000 + i, 0);\n        }\n    }\n\n    this.reset();\n};\n\nPAPU.prototype = {\n    reset: function() {\n        this.sampleRate = this.nes.opts.sampleRate;\n        this.sampleTimerMax = Math.floor(\n            (1024.0 * this.nes.opts.CPU_FREQ_NTSC *\n                this.nes.opts.preferredFrameRate) /\n                (this.sampleRate * 60.0)\n        );\n\n        this.frameTime = Math.floor(\n            (14915.0 * this.nes.opts.preferredFrameRate) / 60.0\n        );\n\n        this.sampleTimer = 0;\n        this.bufferIndex = 0;\n\n        this.updateChannelEnable(0);\n        this.masterFrameCounter = 0;\n        this.derivedFrameCounter = 0;\n        this.countSequence = 0;\n        this.sampleCount = 0;\n        this.initCounter = 2048;\n        this.frameIrqEnabled = false;\n        this.initingHardware = false;\n\n        this.resetCounter();\n\n        this.square1.reset();\n        this.square2.reset();\n        this.triangle.reset();\n        this.noise.reset();\n        this.dmc.reset();\n\n        this.bufferIndex = 0;\n        this.accCount = 0;\n        this.smpSquare1 = 0;\n        this.smpSquare2 = 0;\n        this.smpTriangle = 0;\n        this.smpDmc = 0;\n\n        this.frameIrqEnabled = false;\n        this.frameIrqCounterMax = 4;\n\n        this.channelEnableValue = 0xFF;\n        this.startedPlaying = false;\n        this.prevSampleL = 0;\n        this.prevSampleR = 0;\n        this.smpAccumL = 0;\n        this.smpAccumR = 0;\n\n        this.maxSample = -500000;\n        this.minSample = 500000;\n    },\n\n    readReg: function(address){\n        // Read 0x4015:\n        var tmp = 0;\n        tmp |= (this.square1.getLengthStatus()   );\n        tmp |= (this.square2.getLengthStatus() <<1);\n        tmp |= (this.triangle.getLengthStatus()<<2);\n        tmp |= (this.noise.getLengthStatus()   <<3);\n        tmp |= (this.dmc.getLengthStatus()     <<4);\n        tmp |= (((this.frameIrqActive && this.frameIrqEnabled)? 1 : 0) << 6);\n        tmp |= (this.dmc.getIrqStatus()        <<7);\n\n        this.frameIrqActive = false;\n        this.dmc.irqGenerated = false;\n\n        return tmp & 0xFFFF;\n    },\n\n    writeReg: function(address, value){\n        if (address >= 0x4000 && address < 0x4004) {\n            // Square Wave 1 Control\n            this.square1.writeReg(address, value);\n            ////System.out.println(\"Square Write\");\n        }\n        else if (address >= 0x4004 && address < 0x4008) {\n            // Square 2 Control\n            this.square2.writeReg(address, value);\n        }\n        else if (address >= 0x4008 && address < 0x400C) {\n            // Triangle Control\n            this.triangle.writeReg(address, value);\n        }\n        else if (address >= 0x400C && address <= 0x400F) {\n            // Noise Control\n            this.noise.writeReg(address, value);\n        }\n        else if (address === 0x4010){\n            // DMC Play mode & DMA frequency\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4011){\n            // DMC Delta Counter\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4012){\n            // DMC Play code starting address\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4013){\n            // DMC Play code length\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4015){\n            // Channel enable\n            this.updateChannelEnable(value);\n\n            if (value !== 0 && this.initCounter > 0) {\n                // Start hardware initialization\n                this.initingHardware = true;\n            }\n\n            // DMC/IRQ Status\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4017) {\n            // Frame counter control\n            this.countSequence = (value>>7)&1;\n            this.masterFrameCounter = 0;\n            this.frameIrqActive = false;\n\n            if (((value>>6)&0x1)===0){\n                this.frameIrqEnabled = true;\n            }\n            else {\n                this.frameIrqEnabled = false;\n            }\n\n            if (this.countSequence === 0) {\n                // NTSC:\n                this.frameIrqCounterMax = 4;\n                this.derivedFrameCounter = 4;\n            }\n            else {\n                // PAL:\n                this.frameIrqCounterMax = 5;\n                this.derivedFrameCounter = 0;\n                this.frameCounterTick();\n            }\n        }\n    },\n\n    resetCounter: function(){\n        if (this.countSequence === 0) {\n            this.derivedFrameCounter = 4;\n        }else{\n            this.derivedFrameCounter = 0;\n        }\n    },\n\n    // Updates channel enable status.\n    // This is done on writes to the\n    // channel enable register (0x4015),\n    // and when the user enables/disables channels\n    // in the GUI.\n    updateChannelEnable: function(value){\n        this.channelEnableValue = value&0xFFFF;\n        this.square1.setEnabled((value&1) !== 0);\n        this.square2.setEnabled((value&2) !== 0);\n        this.triangle.setEnabled((value&4) !== 0);\n        this.noise.setEnabled((value&8) !== 0);\n        this.dmc.setEnabled((value&16) !== 0);\n    },\n\n    // Clocks the frame counter. It should be clocked at\n    // twice the cpu speed, so the cycles will be\n    // divided by 2 for those counters that are\n    // clocked at cpu speed.\n    clockFrameCounter: function(nCycles){\n        if (this.initCounter > 0) {\n            if (this.initingHardware) {\n                this.initCounter -= nCycles;\n                if (this.initCounter <= 0) {\n                    this.initingHardware = false;\n                }\n                return;\n            }\n        }\n\n        // Don't process ticks beyond next sampling:\n        nCycles += this.extraCycles;\n        var maxCycles = this.sampleTimerMax-this.sampleTimer;\n        if ((nCycles<<10) > maxCycles) {\n\n            this.extraCycles = ((nCycles<<10) - maxCycles)>>10;\n            nCycles -= this.extraCycles;\n\n        }else{\n\n            this.extraCycles = 0;\n\n        }\n\n        var dmc = this.dmc;\n        var triangle = this.triangle;\n        var square1 = this.square1;\n        var square2 = this.square2;\n        var noise = this.noise;\n\n        // Clock DMC:\n        if (dmc.isEnabled) {\n\n            dmc.shiftCounter-=(nCycles<<3);\n            while(dmc.shiftCounter<=0 && dmc.dmaFrequency>0){\n                dmc.shiftCounter += dmc.dmaFrequency;\n                dmc.clockDmc();\n            }\n\n        }\n\n        // Clock Triangle channel Prog timer:\n        if (triangle.progTimerMax>0) {\n\n            triangle.progTimerCount -= nCycles;\n            while(triangle.progTimerCount <= 0){\n\n                triangle.progTimerCount += triangle.progTimerMax+1;\n                if (triangle.linearCounter>0 && triangle.lengthCounter>0) {\n\n                    triangle.triangleCounter++;\n                    triangle.triangleCounter &= 0x1F;\n\n                    if (triangle.isEnabled) {\n                        if (triangle.triangleCounter>=0x10) {\n                            // Normal value.\n                            triangle.sampleValue = (triangle.triangleCounter&0xF);\n                        }else{\n                            // Inverted value.\n                            triangle.sampleValue = (0xF - (triangle.triangleCounter&0xF));\n                        }\n                        triangle.sampleValue <<= 4;\n                    }\n                }\n            }\n        }\n\n        // Clock Square channel 1 Prog timer:\n        square1.progTimerCount -= nCycles;\n        if (square1.progTimerCount <= 0) {\n\n            square1.progTimerCount += (square1.progTimerMax+1)<<1;\n\n            square1.squareCounter++;\n            square1.squareCounter&=0x7;\n            square1.updateSampleValue();\n\n        }\n\n        // Clock Square channel 2 Prog timer:\n        square2.progTimerCount -= nCycles;\n        if (square2.progTimerCount <= 0) {\n\n            square2.progTimerCount += (square2.progTimerMax+1)<<1;\n\n            square2.squareCounter++;\n            square2.squareCounter&=0x7;\n            square2.updateSampleValue();\n\n        }\n\n        // Clock noise channel Prog timer:\n        var acc_c = nCycles;\n        if (noise.progTimerCount-acc_c > 0) {\n\n            // Do all cycles at once:\n            noise.progTimerCount -= acc_c;\n            noise.accCount       += acc_c;\n            noise.accValue       += acc_c * noise.sampleValue;\n\n        }else{\n\n            // Slow-step:\n            while((acc_c--) > 0){\n\n                if (--noise.progTimerCount <= 0 && noise.progTimerMax>0) {\n\n                    // Update noise shift register:\n                    noise.shiftReg <<= 1;\n                    noise.tmp = (((noise.shiftReg << (noise.randomMode===0?1:6)) ^ noise.shiftReg) & 0x8000 );\n                    if (noise.tmp !== 0) {\n\n                        // Sample value must be 0.\n                        noise.shiftReg |= 0x01;\n                        noise.randomBit = 0;\n                        noise.sampleValue = 0;\n\n                    }else{\n\n                        // Find sample value:\n                        noise.randomBit = 1;\n                        if (noise.isEnabled && noise.lengthCounter>0) {\n                            noise.sampleValue = noise.masterVolume;\n                        }else{\n                            noise.sampleValue = 0;\n                        }\n\n                    }\n\n                    noise.progTimerCount += noise.progTimerMax;\n\n                }\n\n                noise.accValue += noise.sampleValue;\n                noise.accCount++;\n\n            }\n        }\n\n\n        // Frame IRQ handling:\n        if (this.frameIrqEnabled && this.frameIrqActive){\n            this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n        }\n\n        // Clock frame counter at double CPU speed:\n        this.masterFrameCounter += (nCycles<<1);\n        if (this.masterFrameCounter >= this.frameTime) {\n            // 240Hz tick:\n            this.masterFrameCounter -= this.frameTime;\n            this.frameCounterTick();\n        }\n\n        // Accumulate sample value:\n        this.accSample(nCycles);\n\n        // Clock sample timer:\n        this.sampleTimer += nCycles<<10;\n        if (this.sampleTimer>=this.sampleTimerMax) {\n            // Sample channels:\n            this.sample();\n            this.sampleTimer -= this.sampleTimerMax;\n        }\n    },\n\n    accSample: function(cycles) {\n        // Special treatment for triangle channel - need to interpolate.\n        if (this.triangle.sampleCondition) {\n            this.triValue = Math.floor((this.triangle.progTimerCount << 4) /\n                    (this.triangle.progTimerMax + 1));\n            if (this.triValue > 16) {\n                this.triValue = 16;\n            }\n            if (this.triangle.triangleCounter >= 16) {\n                this.triValue = 16 - this.triValue;\n            }\n\n            // Add non-interpolated sample value:\n            this.triValue += this.triangle.sampleValue;\n        }\n\n        // Now sample normally:\n        if (cycles === 2) {\n\n            this.smpTriangle += this.triValue                << 1;\n            this.smpDmc      += this.dmc.sample         << 1;\n            this.smpSquare1  += this.square1.sampleValue    << 1;\n            this.smpSquare2  += this.square2.sampleValue    << 1;\n            this.accCount    += 2;\n\n        }else if (cycles === 4) {\n\n            this.smpTriangle += this.triValue                << 2;\n            this.smpDmc      += this.dmc.sample         << 2;\n            this.smpSquare1  += this.square1.sampleValue    << 2;\n            this.smpSquare2  += this.square2.sampleValue    << 2;\n            this.accCount    += 4;\n\n        }else{\n\n            this.smpTriangle += cycles * this.triValue;\n            this.smpDmc      += cycles * this.dmc.sample;\n            this.smpSquare1  += cycles * this.square1.sampleValue;\n            this.smpSquare2  += cycles * this.square2.sampleValue;\n            this.accCount    += cycles;\n\n        }\n\n    },\n\n    frameCounterTick: function(){\n\n        this.derivedFrameCounter++;\n        if (this.derivedFrameCounter >= this.frameIrqCounterMax) {\n            this.derivedFrameCounter = 0;\n        }\n\n        if (this.derivedFrameCounter===1 || this.derivedFrameCounter===3) {\n\n            // Clock length & sweep:\n            this.triangle.clockLengthCounter();\n            this.square1.clockLengthCounter();\n            this.square2.clockLengthCounter();\n            this.noise.clockLengthCounter();\n            this.square1.clockSweep();\n            this.square2.clockSweep();\n\n        }\n\n        if (this.derivedFrameCounter >= 0 && this.derivedFrameCounter < 4) {\n\n            // Clock linear & decay:\n            this.square1.clockEnvDecay();\n            this.square2.clockEnvDecay();\n            this.noise.clockEnvDecay();\n            this.triangle.clockLinearCounter();\n\n        }\n\n        if (this.derivedFrameCounter === 3 && this.countSequence===0) {\n\n            // Enable IRQ:\n            this.frameIrqActive = true;\n\n        }\n\n\n        // End of 240Hz tick\n\n    },\n\n\n    // Samples the channels, mixes the output together,\n    // writes to buffer and (if enabled) file.\n    sample: function(){\n        var sq_index, tnd_index;\n\n        if (this.accCount > 0) {\n\n            this.smpSquare1 <<= 4;\n            this.smpSquare1 = Math.floor(this.smpSquare1 / this.accCount);\n\n            this.smpSquare2 <<= 4;\n            this.smpSquare2 = Math.floor(this.smpSquare2 / this.accCount);\n\n            this.smpTriangle = Math.floor(this.smpTriangle / this.accCount);\n\n            this.smpDmc <<= 4;\n            this.smpDmc = Math.floor(this.smpDmc / this.accCount);\n\n            this.accCount = 0;\n        }\n        else {\n            this.smpSquare1 = this.square1.sampleValue << 4;\n            this.smpSquare2 = this.square2.sampleValue << 4;\n            this.smpTriangle = this.triangle.sampleValue;\n            this.smpDmc = this.dmc.sample << 4;\n        }\n\n        var smpNoise = Math.floor((this.noise.accValue << 4) /\n                this.noise.accCount);\n        this.noise.accValue = smpNoise >> 4;\n        this.noise.accCount = 1;\n\n        // Stereo sound.\n\n        // Left channel:\n        sq_index  = (\n                this.smpSquare1 * this.stereoPosLSquare1 +\n                this.smpSquare2 * this.stereoPosLSquare2\n            ) >> 8;\n        tnd_index = (\n                3 * this.smpTriangle * this.stereoPosLTriangle +\n                (smpNoise<<1) * this.stereoPosLNoise + this.smpDmc *\n                this.stereoPosLDMC\n            ) >> 8;\n        if (sq_index >= this.square_table.length) {\n            sq_index  = this.square_table.length-1;\n        }\n        if (tnd_index >= this.tnd_table.length) {\n            tnd_index = this.tnd_table.length - 1;\n        }\n        var sampleValueL = this.square_table[sq_index] +\n                this.tnd_table[tnd_index] - this.dcValue;\n\n        // Right channel:\n        sq_index = (this.smpSquare1 * this.stereoPosRSquare1 +\n                this.smpSquare2 * this.stereoPosRSquare2\n            ) >> 8;\n        tnd_index = (3 * this.smpTriangle * this.stereoPosRTriangle +\n                (smpNoise << 1) * this.stereoPosRNoise + this.smpDmc *\n                this.stereoPosRDMC\n            ) >> 8;\n        if (sq_index >= this.square_table.length) {\n            sq_index = this.square_table.length - 1;\n        }\n        if (tnd_index >= this.tnd_table.length) {\n            tnd_index = this.tnd_table.length - 1;\n        }\n        var sampleValueR = this.square_table[sq_index] +\n                this.tnd_table[tnd_index] - this.dcValue;\n\n        // Remove DC from left channel:\n        var smpDiffL = sampleValueL - this.prevSampleL;\n        this.prevSampleL += smpDiffL;\n        this.smpAccumL += smpDiffL - (this.smpAccumL >> 10);\n        sampleValueL = this.smpAccumL;\n\n        // Remove DC from right channel:\n        var smpDiffR     = sampleValueR - this.prevSampleR;\n        this.prevSampleR += smpDiffR;\n        this.smpAccumR  += smpDiffR - (this.smpAccumR >> 10);\n        sampleValueR = this.smpAccumR;\n\n        // Write:\n        if (sampleValueL > this.maxSample) {\n            this.maxSample = sampleValueL;\n        }\n        if (sampleValueL < this.minSample) {\n            this.minSample = sampleValueL;\n        }\n        this.sampleBuffer[this.bufferIndex++] = sampleValueL;\n        this.sampleBuffer[this.bufferIndex++] = sampleValueR;\n\n        // Write full buffer\n        if (this.bufferIndex === this.sampleBuffer.length) {\n            this.nes.ui.writeAudio(this.sampleBuffer);\n            this.sampleBuffer = new Array(this.bufferSize*2);\n            this.bufferIndex = 0;\n        }\n\n        // Reset sampled values:\n        this.smpSquare1 = 0;\n        this.smpSquare2 = 0;\n        this.smpTriangle = 0;\n        this.smpDmc = 0;\n\n    },\n\n    getLengthMax: function(value){\n        return this.lengthLookup[value >> 3];\n    },\n\n    getDmcFrequency: function(value){\n        if (value >= 0 && value < 0x10) {\n            return this.dmcFreqLookup[value];\n        }\n        return 0;\n    },\n\n    getNoiseWaveLength: function(value){\n        if (value >= 0 && value < 0x10) {\n            return this.noiseWavelengthLookup[value];\n        }\n        return 0;\n    },\n\n    setPanning: function(pos){\n        for (var i = 0; i < 5; i++) {\n            this.panning[i] = pos[i];\n        }\n        this.updateStereoPos();\n    },\n\n    setMasterVolume: function(value){\n        if (value < 0) {\n            value = 0;\n        }\n        if (value > 256) {\n            value = 256;\n        }\n        this.masterVolume = value;\n        this.updateStereoPos();\n    },\n\n    updateStereoPos: function(){\n        this.stereoPosLSquare1 = (this.panning[0] * this.masterVolume) >> 8;\n        this.stereoPosLSquare2 = (this.panning[1] * this.masterVolume) >> 8;\n        this.stereoPosLTriangle = (this.panning[2] * this.masterVolume) >> 8;\n        this.stereoPosLNoise = (this.panning[3] * this.masterVolume) >> 8;\n        this.stereoPosLDMC = (this.panning[4] * this.masterVolume) >> 8;\n\n        this.stereoPosRSquare1 = this.masterVolume - this.stereoPosLSquare1;\n        this.stereoPosRSquare2 = this.masterVolume - this.stereoPosLSquare2;\n        this.stereoPosRTriangle = this.masterVolume - this.stereoPosLTriangle;\n        this.stereoPosRNoise = this.masterVolume - this.stereoPosLNoise;\n        this.stereoPosRDMC = this.masterVolume - this.stereoPosLDMC;\n    },\n\n    initLengthLookup: function(){\n\n        this.lengthLookup = [\n            0x0A, 0xFE,\n            0x14, 0x02,\n            0x28, 0x04,\n            0x50, 0x06,\n            0xA0, 0x08,\n            0x3C, 0x0A,\n            0x0E, 0x0C,\n            0x1A, 0x0E,\n            0x0C, 0x10,\n            0x18, 0x12,\n            0x30, 0x14,\n            0x60, 0x16,\n            0xC0, 0x18,\n            0x48, 0x1A,\n            0x10, 0x1C,\n            0x20, 0x1E\n        ];\n    },\n\n    initDmcFrequencyLookup: function(){\n\n        this.dmcFreqLookup = new Array(16);\n\n        this.dmcFreqLookup[0x0] = 0xD60;\n        this.dmcFreqLookup[0x1] = 0xBE0;\n        this.dmcFreqLookup[0x2] = 0xAA0;\n        this.dmcFreqLookup[0x3] = 0xA00;\n        this.dmcFreqLookup[0x4] = 0x8F0;\n        this.dmcFreqLookup[0x5] = 0x7F0;\n        this.dmcFreqLookup[0x6] = 0x710;\n        this.dmcFreqLookup[0x7] = 0x6B0;\n        this.dmcFreqLookup[0x8] = 0x5F0;\n        this.dmcFreqLookup[0x9] = 0x500;\n        this.dmcFreqLookup[0xA] = 0x470;\n        this.dmcFreqLookup[0xB] = 0x400;\n        this.dmcFreqLookup[0xC] = 0x350;\n        this.dmcFreqLookup[0xD] = 0x2A0;\n        this.dmcFreqLookup[0xE] = 0x240;\n        this.dmcFreqLookup[0xF] = 0x1B0;\n        //for(int i=0;i<16;i++)dmcFreqLookup[i]/=8;\n\n    },\n\n    initNoiseWavelengthLookup: function(){\n\n        this.noiseWavelengthLookup = new Array(16);\n\n        this.noiseWavelengthLookup[0x0] = 0x004;\n        this.noiseWavelengthLookup[0x1] = 0x008;\n        this.noiseWavelengthLookup[0x2] = 0x010;\n        this.noiseWavelengthLookup[0x3] = 0x020;\n        this.noiseWavelengthLookup[0x4] = 0x040;\n        this.noiseWavelengthLookup[0x5] = 0x060;\n        this.noiseWavelengthLookup[0x6] = 0x080;\n        this.noiseWavelengthLookup[0x7] = 0x0A0;\n        this.noiseWavelengthLookup[0x8] = 0x0CA;\n        this.noiseWavelengthLookup[0x9] = 0x0FE;\n        this.noiseWavelengthLookup[0xA] = 0x17C;\n        this.noiseWavelengthLookup[0xB] = 0x1FC;\n        this.noiseWavelengthLookup[0xC] = 0x2FA;\n        this.noiseWavelengthLookup[0xD] = 0x3F8;\n        this.noiseWavelengthLookup[0xE] = 0x7F2;\n        this.noiseWavelengthLookup[0xF] = 0xFE4;\n\n    },\n\n    initDACtables: function(){\n        var value, ival, i;\n        var max_sqr = 0;\n        var max_tnd = 0;\n\n        this.square_table = new Array(32*16);\n        this.tnd_table = new Array(204*16);\n\n        for (i = 0; i < 32 * 16; i++) {\n            value = 95.52 / (8128.0 / (i/16.0) + 100.0);\n            value *= 0.98411;\n            value *= 50000.0;\n            ival = Math.floor(value);\n\n            this.square_table[i] = ival;\n            if (ival > max_sqr) {\n                max_sqr = ival;\n            }\n        }\n\n        for (i = 0; i < 204 * 16; i++) {\n            value = 163.67 / (24329.0 / (i/16.0) + 100.0);\n            value *= 0.98411;\n            value *= 50000.0;\n            ival = Math.floor(value);\n\n            this.tnd_table[i] = ival;\n            if (ival > max_tnd) {\n                max_tnd = ival;\n            }\n\n        }\n\n        this.dacRange = max_sqr+max_tnd;\n        this.dcValue = this.dacRange/2;\n\n    }\n};\n\n\nPAPU.ChannelDM = function(papu) {\n    this.papu = papu;\n\n    this.MODE_NORMAL = 0;\n    this.MODE_LOOP = 1;\n    this.MODE_IRQ = 2;\n\n    this.isEnabled = null;\n    this.hasSample = null;\n    this.irqGenerated = false;\n\n    this.playMode = null;\n    this.dmaFrequency = null;\n    this.dmaCounter = null;\n    this.deltaCounter = null;\n    this.playStartAddress = null;\n    this.playAddress = null;\n    this.playLength = null;\n    this.playLengthCounter = null;\n    this.shiftCounter = null;\n    this.reg4012 = null;\n    this.reg4013 = null;\n    this.sample = null;\n    this.dacLsb = null;\n    this.data = null;\n\n    this.reset();\n};\n\nPAPU.ChannelDM.prototype = {\n    clockDmc: function() {\n\n        // Only alter DAC value if the sample buffer has data:\n        if(this.hasSample) {\n\n            if ((this.data & 1) === 0) {\n\n                // Decrement delta:\n                if(this.deltaCounter>0) {\n                    this.deltaCounter--;\n                }\n            }\n            else {\n                // Increment delta:\n                if (this.deltaCounter < 63) {\n                    this.deltaCounter++;\n                }\n            }\n\n            // Update sample value:\n            this.sample = this.isEnabled ? (this.deltaCounter << 1) + this.dacLsb : 0;\n\n            // Update shift register:\n            this.data >>= 1;\n\n        }\n\n        this.dmaCounter--;\n        if (this.dmaCounter <= 0) {\n\n            // No more sample bits.\n            this.hasSample = false;\n            this.endOfSample();\n            this.dmaCounter = 8;\n\n        }\n\n        if (this.irqGenerated) {\n            this.papu.nes.cpu.requestIrq(this.papu.nes.cpu.IRQ_NORMAL);\n        }\n\n    },\n\n    endOfSample: function() {\n        if (this.playLengthCounter === 0 && this.playMode === this.MODE_LOOP) {\n\n            // Start from beginning of sample:\n            this.playAddress = this.playStartAddress;\n            this.playLengthCounter = this.playLength;\n\n        }\n\n        if (this.playLengthCounter > 0) {\n\n            // Fetch next sample:\n            this.nextSample();\n\n            if (this.playLengthCounter === 0) {\n\n                // Last byte of sample fetched, generate IRQ:\n                if (this.playMode === this.MODE_IRQ) {\n\n                    // Generate IRQ:\n                    this.irqGenerated = true;\n\n                }\n\n            }\n\n        }\n\n    },\n\n    nextSample: function() {\n        // Fetch byte:\n        this.data = this.papu.nes.mmap.load(this.playAddress);\n        this.papu.nes.cpu.haltCycles(4);\n\n        this.playLengthCounter--;\n        this.playAddress++;\n        if (this.playAddress > 0xFFFF) {\n            this.playAddress = 0x8000;\n        }\n\n        this.hasSample = true;\n    },\n\n    writeReg: function(address, value) {\n        if (address === 0x4010) {\n\n            // Play mode, DMA Frequency\n            if ((value >> 6) === 0) {\n                this.playMode = this.MODE_NORMAL;\n            }\n            else if (((value >> 6) & 1) === 1) {\n                this.playMode = this.MODE_LOOP;\n            }\n            else if ((value >> 6) === 2) {\n                this.playMode = this.MODE_IRQ;\n            }\n\n            if ((value & 0x80) === 0) {\n                this.irqGenerated = false;\n            }\n\n            this.dmaFrequency = this.papu.getDmcFrequency(value & 0xF);\n\n        }\n        else if (address === 0x4011) {\n\n            // Delta counter load register:\n            this.deltaCounter = (value >> 1) & 63;\n            this.dacLsb = value & 1;\n            this.sample = ((this.deltaCounter << 1) + this.dacLsb); // update sample value\n\n        }\n        else if (address === 0x4012) {\n\n            // DMA address load register\n            this.playStartAddress = (value << 6) | 0x0C000;\n            this.playAddress = this.playStartAddress;\n            this.reg4012 = value;\n\n        }\n        else if (address === 0x4013) {\n\n            // Length of play code\n            this.playLength = (value << 4) + 1;\n            this.playLengthCounter = this.playLength;\n            this.reg4013 = value;\n\n        }\n        else if (address === 0x4015) {\n\n            // DMC/IRQ Status\n            if (((value >> 4) & 1) === 0) {\n                // Disable:\n                this.playLengthCounter = 0;\n            }\n            else {\n                // Restart:\n                this.playAddress = this.playStartAddress;\n                this.playLengthCounter = this.playLength;\n            }\n            this.irqGenerated = false;\n        }\n    },\n\n    setEnabled: function(value) {\n        if ((!this.isEnabled) && value) {\n            this.playLengthCounter = this.playLength;\n        }\n        this.isEnabled = value;\n    },\n\n    getLengthStatus: function(){\n        return ((this.playLengthCounter === 0 || !this.isEnabled) ? 0 : 1);\n    },\n\n    getIrqStatus: function(){\n        return (this.irqGenerated ? 1 : 0);\n    },\n\n    reset: function(){\n        this.isEnabled = false;\n        this.irqGenerated = false;\n        this.playMode = this.MODE_NORMAL;\n        this.dmaFrequency = 0;\n        this.dmaCounter = 0;\n        this.deltaCounter = 0;\n        this.playStartAddress = 0;\n        this.playAddress = 0;\n        this.playLength = 0;\n        this.playLengthCounter = 0;\n        this.sample = 0;\n        this.dacLsb = 0;\n        this.shiftCounter = 0;\n        this.reg4012 = 0;\n        this.reg4013 = 0;\n        this.data = 0;\n    }\n};\n\n\nPAPU.ChannelNoise = function(papu) {\n    this.papu = papu;\n\n    this.isEnabled = null;\n    this.envDecayDisable = null;\n    this.envDecayLoopEnable = null;\n    this.lengthCounterEnable = null;\n    this.envReset = null;\n    this.shiftNow = null;\n\n    this.lengthCounter = null;\n    this.progTimerCount = null;\n    this.progTimerMax = null;\n    this.envDecayRate = null;\n    this.envDecayCounter = null;\n    this.envVolume = null;\n    this.masterVolume = null;\n    this.shiftReg = 1<<14;\n    this.randomBit = null;\n    this.randomMode = null;\n    this.sampleValue = null;\n    this.accValue=0;\n    this.accCount=1;\n    this.tmp = null;\n\n    this.reset();\n};\n\nPAPU.ChannelNoise.prototype = {\n    reset: function() {\n        this.progTimerCount = 0;\n        this.progTimerMax = 0;\n        this.isEnabled = false;\n        this.lengthCounter = 0;\n        this.lengthCounterEnable = false;\n        this.envDecayDisable = false;\n        this.envDecayLoopEnable = false;\n        this.shiftNow = false;\n        this.envDecayRate = 0;\n        this.envDecayCounter = 0;\n        this.envVolume = 0;\n        this.masterVolume = 0;\n        this.shiftReg = 1;\n        this.randomBit = 0;\n        this.randomMode = 0;\n        this.sampleValue = 0;\n        this.tmp = 0;\n    },\n\n    clockLengthCounter: function(){\n        if (this.lengthCounterEnable && this.lengthCounter>0){\n            this.lengthCounter--;\n            if (this.lengthCounter === 0) {\n                this.updateSampleValue();\n            }\n        }\n    },\n\n    clockEnvDecay: function() {\n        if(this.envReset) {\n            // Reset envelope:\n            this.envReset = false;\n            this.envDecayCounter = this.envDecayRate + 1;\n            this.envVolume = 0xF;\n        }\n        else if (--this.envDecayCounter <= 0) {\n            // Normal handling:\n            this.envDecayCounter = this.envDecayRate + 1;\n            if(this.envVolume>0) {\n                this.envVolume--;\n            }\n            else {\n                this.envVolume = this.envDecayLoopEnable ? 0xF : 0;\n            }\n        }\n        this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n        this.updateSampleValue();\n    },\n\n    updateSampleValue: function() {\n        if (this.isEnabled && this.lengthCounter>0) {\n            this.sampleValue = this.randomBit * this.masterVolume;\n        }\n    },\n\n    writeReg: function(address, value){\n        if(address === 0x400C) {\n            // Volume/Envelope decay:\n            this.envDecayDisable = ((value&0x10) !== 0);\n            this.envDecayRate = value&0xF;\n            this.envDecayLoopEnable = ((value&0x20) !== 0);\n            this.lengthCounterEnable = ((value&0x20)===0);\n            this.masterVolume = this.envDecayDisable?this.envDecayRate:this.envVolume;\n\n        }else if(address === 0x400E) {\n            // Programmable timer:\n            this.progTimerMax = this.papu.getNoiseWaveLength(value&0xF);\n            this.randomMode = value>>7;\n\n        }else if(address === 0x400F) {\n            // Length counter\n            this.lengthCounter = this.papu.getLengthMax(value&248);\n            this.envReset = true;\n        }\n        // Update:\n        //updateSampleValue();\n    },\n\n    setEnabled: function(value){\n        this.isEnabled = value;\n        if (!value) {\n            this.lengthCounter = 0;\n        }\n        this.updateSampleValue();\n    },\n\n    getLengthStatus: function() {\n        return ((this.lengthCounter===0 || !this.isEnabled)?0:1);\n    }\n};\n\n\nPAPU.ChannelSquare = function(papu, square1) {\n    this.papu = papu;\n\n    this.dutyLookup = [\n         0, 1, 0, 0, 0, 0, 0, 0,\n         0, 1, 1, 0, 0, 0, 0, 0,\n         0, 1, 1, 1, 1, 0, 0, 0,\n         1, 0, 0, 1, 1, 1, 1, 1\n    ];\n    this.impLookup = [\n         1,-1, 0, 0, 0, 0, 0, 0,\n         1, 0,-1, 0, 0, 0, 0, 0,\n         1, 0, 0, 0,-1, 0, 0, 0,\n        -1, 0, 1, 0, 0, 0, 0, 0\n    ];\n\n    this.sqr1 = square1;\n    this.isEnabled = null;\n    this.lengthCounterEnable = null;\n    this.sweepActive = null;\n    this.envDecayDisable = null;\n    this.envDecayLoopEnable = null;\n    this.envReset = null;\n    this.sweepCarry = null;\n    this.updateSweepPeriod = null;\n\n    this.progTimerCount = null;\n    this.progTimerMax = null;\n    this.lengthCounter = null;\n    this.squareCounter = null;\n    this.sweepCounter = null;\n    this.sweepCounterMax = null;\n    this.sweepMode = null;\n    this.sweepShiftAmount = null;\n    this.envDecayRate = null;\n    this.envDecayCounter = null;\n    this.envVolume = null;\n    this.masterVolume = null;\n    this.dutyMode = null;\n    this.sweepResult = null;\n    this.sampleValue = null;\n    this.vol = null;\n\n    this.reset();\n};\n\nPAPU.ChannelSquare.prototype = {\n    reset: function() {\n        this.progTimerCount = 0;\n        this.progTimerMax = 0;\n        this.lengthCounter = 0;\n        this.squareCounter = 0;\n        this.sweepCounter = 0;\n        this.sweepCounterMax = 0;\n        this.sweepMode = 0;\n        this.sweepShiftAmount = 0;\n        this.envDecayRate = 0;\n        this.envDecayCounter = 0;\n        this.envVolume = 0;\n        this.masterVolume = 0;\n        this.dutyMode = 0;\n        this.vol = 0;\n\n        this.isEnabled = false;\n        this.lengthCounterEnable = false;\n        this.sweepActive = false;\n        this.sweepCarry = false;\n        this.envDecayDisable = false;\n        this.envDecayLoopEnable = false;\n    },\n\n    clockLengthCounter: function() {\n        if (this.lengthCounterEnable && this.lengthCounter > 0){\n            this.lengthCounter--;\n            if (this.lengthCounter === 0) {\n                this.updateSampleValue();\n            }\n        }\n    },\n\n    clockEnvDecay: function() {\n        if (this.envReset) {\n            // Reset envelope:\n            this.envReset = false;\n            this.envDecayCounter = this.envDecayRate + 1;\n            this.envVolume = 0xF;\n        }else if ((--this.envDecayCounter) <= 0) {\n            // Normal handling:\n            this.envDecayCounter = this.envDecayRate + 1;\n            if (this.envVolume>0) {\n                this.envVolume--;\n            }else{\n                this.envVolume = this.envDecayLoopEnable ? 0xF : 0;\n            }\n        }\n\n        this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n        this.updateSampleValue();\n    },\n\n    clockSweep: function() {\n        if (--this.sweepCounter<=0) {\n\n            this.sweepCounter = this.sweepCounterMax + 1;\n            if (this.sweepActive && this.sweepShiftAmount>0 && this.progTimerMax>7) {\n\n                // Calculate result from shifter:\n                this.sweepCarry = false;\n                if (this.sweepMode===0) {\n                    this.progTimerMax += (this.progTimerMax>>this.sweepShiftAmount);\n                    if (this.progTimerMax > 4095) {\n                        this.progTimerMax = 4095;\n                        this.sweepCarry = true;\n                    }\n                }else{\n                    this.progTimerMax = this.progTimerMax - ((this.progTimerMax>>this.sweepShiftAmount)-(this.sqr1?1:0));\n                }\n            }\n        }\n\n        if (this.updateSweepPeriod) {\n            this.updateSweepPeriod = false;\n            this.sweepCounter = this.sweepCounterMax + 1;\n        }\n    },\n\n    updateSampleValue: function() {\n        if (this.isEnabled && this.lengthCounter>0 && this.progTimerMax>7) {\n\n            if (this.sweepMode===0 && (this.progTimerMax + (this.progTimerMax>>this.sweepShiftAmount)) > 4095) {\n            //if (this.sweepCarry) {\n                this.sampleValue = 0;\n            }else{\n                this.sampleValue = this.masterVolume*this.dutyLookup[(this.dutyMode<<3)+this.squareCounter];\n            }\n        }else{\n            this.sampleValue = 0;\n        }\n    },\n\n    writeReg: function(address, value){\n        var addrAdd = (this.sqr1?0:4);\n        if (address === 0x4000 + addrAdd) {\n            // Volume/Envelope decay:\n            this.envDecayDisable = ((value&0x10) !== 0);\n            this.envDecayRate = value & 0xF;\n            this.envDecayLoopEnable = ((value&0x20) !== 0);\n            this.dutyMode = (value>>6)&0x3;\n            this.lengthCounterEnable = ((value&0x20)===0);\n            this.masterVolume = this.envDecayDisable?this.envDecayRate:this.envVolume;\n            this.updateSampleValue();\n\n        }\n        else if (address === 0x4001+addrAdd) {\n            // Sweep:\n            this.sweepActive = ((value&0x80) !== 0);\n            this.sweepCounterMax = ((value>>4)&7);\n            this.sweepMode = (value>>3)&1;\n            this.sweepShiftAmount = value&7;\n            this.updateSweepPeriod = true;\n        }\n        else if (address === 0x4002+addrAdd){\n            // Programmable timer:\n            this.progTimerMax &= 0x700;\n            this.progTimerMax |= value;\n        }\n        else if (address === 0x4003+addrAdd) {\n            // Programmable timer, length counter\n            this.progTimerMax &= 0xFF;\n            this.progTimerMax |= ((value&0x7)<<8);\n\n            if (this.isEnabled){\n                this.lengthCounter = this.papu.getLengthMax(value&0xF8);\n            }\n\n            this.envReset  = true;\n        }\n    },\n\n    setEnabled: function(value) {\n        this.isEnabled = value;\n        if (!value) {\n            this.lengthCounter = 0;\n        }\n        this.updateSampleValue();\n    },\n\n    getLengthStatus: function() {\n        return ((this.lengthCounter === 0 || !this.isEnabled) ? 0 : 1);\n    }\n};\n\n\nPAPU.ChannelTriangle = function(papu) {\n    this.papu = papu;\n\n    this.isEnabled = null;\n    this.sampleCondition = null;\n    this.lengthCounterEnable = null;\n    this.lcHalt = null;\n    this.lcControl = null;\n\n    this.progTimerCount = null;\n    this.progTimerMax = null;\n    this.triangleCounter = null;\n    this.lengthCounter = null;\n    this.linearCounter = null;\n    this.lcLoadValue = null;\n    this.sampleValue = null;\n    this.tmp = null;\n\n    this.reset();\n};\n\nPAPU.ChannelTriangle.prototype = {\n    reset: function(){\n        this.progTimerCount = 0;\n        this.progTimerMax = 0;\n        this.triangleCounter = 0;\n        this.isEnabled = false;\n        this.sampleCondition = false;\n        this.lengthCounter = 0;\n        this.lengthCounterEnable = false;\n        this.linearCounter = 0;\n        this.lcLoadValue = 0;\n        this.lcHalt = true;\n        this.lcControl = false;\n        this.tmp = 0;\n        this.sampleValue = 0xF;\n    },\n\n    clockLengthCounter: function(){\n        if (this.lengthCounterEnable && this.lengthCounter>0) {\n            this.lengthCounter--;\n            if (this.lengthCounter===0) {\n                this.updateSampleCondition();\n            }\n        }\n    },\n\n    clockLinearCounter: function(){\n        if (this.lcHalt){\n            // Load:\n            this.linearCounter = this.lcLoadValue;\n            this.updateSampleCondition();\n        }\n        else if (this.linearCounter > 0) {\n            // Decrement:\n            this.linearCounter--;\n            this.updateSampleCondition();\n        }\n        if (!this.lcControl) {\n            // Clear halt flag:\n            this.lcHalt = false;\n        }\n    },\n\n    getLengthStatus: function(){\n        return ((this.lengthCounter === 0 || !this.isEnabled)?0:1);\n    },\n\n    readReg: function(address){\n        return 0;\n    },\n\n    writeReg: function(address, value){\n        if (address === 0x4008) {\n            // New values for linear counter:\n            this.lcControl  = (value&0x80)!==0;\n            this.lcLoadValue =  value&0x7F;\n\n            // Length counter enable:\n            this.lengthCounterEnable = !this.lcControl;\n        }\n        else if (address === 0x400A) {\n            // Programmable timer:\n            this.progTimerMax &= 0x700;\n            this.progTimerMax |= value;\n\n        }\n        else if(address === 0x400B) {\n            // Programmable timer, length counter\n            this.progTimerMax &= 0xFF;\n            this.progTimerMax |= ((value&0x07)<<8);\n            this.lengthCounter = this.papu.getLengthMax(value&0xF8);\n            this.lcHalt = true;\n        }\n\n        this.updateSampleCondition();\n    },\n\n    clockProgrammableTimer: function(nCycles){\n        if (this.progTimerMax>0) {\n            this.progTimerCount += nCycles;\n            while (this.progTimerMax > 0 &&\n                    this.progTimerCount >= this.progTimerMax) {\n                this.progTimerCount -= this.progTimerMax;\n                if (this.isEnabled && this.lengthCounter>0 &&\n                        this.linearCounter > 0) {\n                    this.clockTriangleGenerator();\n                }\n            }\n        }\n    },\n\n    clockTriangleGenerator: function() {\n        this.triangleCounter++;\n        this.triangleCounter &= 0x1F;\n    },\n\n    setEnabled: function(value) {\n        this.isEnabled = value;\n        if(!value) {\n            this.lengthCounter = 0;\n        }\n        this.updateSampleCondition();\n    },\n\n    updateSampleCondition: function() {\n        this.sampleCondition = this.isEnabled &&\n                this.progTimerMax > 7 &&\n                this.linearCounter > 0 &&\n                this.lengthCounter > 0;\n    }\n};\n\nexport default PAPU;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/papu.js\n **/","/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport PPU from './ppu';\nimport Mappers from './mappers';\n\nconst ROM = function(nes) {\n    this.nes = nes;\n\n    this.mapperName = new Array(92);\n\n    for (var i=0;i<92;i++) {\n        this.mapperName[i] = \"Unknown Mapper\";\n    }\n    this.mapperName[ 0] = \"Direct Access\";\n    this.mapperName[ 1] = \"Nintendo MMC1\";\n    this.mapperName[ 2] = \"UNROM\";\n    this.mapperName[ 3] = \"CNROM\";\n    this.mapperName[ 4] = \"Nintendo MMC3\";\n    this.mapperName[ 5] = \"Nintendo MMC5\";\n    this.mapperName[ 6] = \"FFE F4xxx\";\n    this.mapperName[ 7] = \"AOROM\";\n    this.mapperName[ 8] = \"FFE F3xxx\";\n    this.mapperName[ 9] = \"Nintendo MMC2\";\n    this.mapperName[10] = \"Nintendo MMC4\";\n    this.mapperName[11] = \"Color Dreams Chip\";\n    this.mapperName[12] = \"FFE F6xxx\";\n    this.mapperName[15] = \"100-in-1 switch\";\n    this.mapperName[16] = \"Bandai chip\";\n    this.mapperName[17] = \"FFE F8xxx\";\n    this.mapperName[18] = \"Jaleco SS8806 chip\";\n    this.mapperName[19] = \"Namcot 106 chip\";\n    this.mapperName[20] = \"Famicom Disk System\";\n    this.mapperName[21] = \"Konami VRC4a\";\n    this.mapperName[22] = \"Konami VRC2a\";\n    this.mapperName[23] = \"Konami VRC2a\";\n    this.mapperName[24] = \"Konami VRC6\";\n    this.mapperName[25] = \"Konami VRC4b\";\n    this.mapperName[32] = \"Irem G-101 chip\";\n    this.mapperName[33] = \"Taito TC0190/TC0350\";\n    this.mapperName[34] = \"32kB ROM switch\";\n\n    this.mapperName[64] = \"Tengen RAMBO-1 chip\";\n    this.mapperName[65] = \"Irem H-3001 chip\";\n    this.mapperName[66] = \"GNROM switch\";\n    this.mapperName[67] = \"SunSoft3 chip\";\n    this.mapperName[68] = \"SunSoft4 chip\";\n    this.mapperName[69] = \"SunSoft5 FME-7 chip\";\n    this.mapperName[71] = \"Camerica chip\";\n    this.mapperName[78] = \"Irem 74HC161/32-based\";\n    this.mapperName[91] = \"Pirate HK-SF3 chip\";\n};\n\nROM.prototype = {\n    // Mirroring types:\n    VERTICAL_MIRRORING: 0,\n    HORIZONTAL_MIRRORING: 1,\n    FOURSCREEN_MIRRORING: 2,\n    SINGLESCREEN_MIRRORING: 3,\n    SINGLESCREEN_MIRRORING2: 4,\n    SINGLESCREEN_MIRRORING3: 5,\n    SINGLESCREEN_MIRRORING4: 6,\n    CHRROM_MIRRORING: 7,\n\n    header: null,\n    rom: null,\n    vrom: null,\n    vromTile: null,\n\n    romCount: null,\n    vromCount: null,\n    mirroring: null,\n    batteryRam: null,\n    trainer: null,\n    fourScreen: null,\n    mapperType: null,\n    valid: false,\n\n    load: function(data) {\n        var i, j, v;\n\n        if (data.indexOf(\"NES\\x1a\") === -1) {\n            this.nes.ui.updateStatus(\"Not a valid NES ROM.\");\n            return;\n        }\n        this.header = new Array(16);\n        for (i = 0; i < 16; i++) {\n            this.header[i] = data.charCodeAt(i) & 0xFF;\n        }\n        this.romCount = this.header[4];\n        this.vromCount = this.header[5]*2; // Get the number of 4kB banks, not 8kB\n        this.mirroring = ((this.header[6] & 1) !== 0 ? 1 : 0);\n        this.batteryRam = (this.header[6] & 2) !== 0;\n        this.trainer = (this.header[6] & 4) !== 0;\n        this.fourScreen = (this.header[6] & 8) !== 0;\n        this.mapperType = (this.header[6] >> 4) | (this.header[7] & 0xF0);\n        /* TODO\n        if (this.batteryRam)\n            this.loadBatteryRam();*/\n        // Check whether byte 8-15 are zero's:\n        var foundError = false;\n        for (i=8; i<16; i++) {\n            if (this.header[i] !== 0) {\n                foundError = true;\n                break;\n            }\n        }\n        if (foundError) {\n            this.mapperType &= 0xF; // Ignore byte 7\n        }\n        // Load PRG-ROM banks:\n        this.rom = new Array(this.romCount);\n        var offset = 16;\n        for (i=0; i < this.romCount; i++) {\n            this.rom[i] = new Array(16384);\n            for (j=0; j < 16384; j++) {\n                if (offset+j >= data.length) {\n                    break;\n                }\n                this.rom[i][j] = data.charCodeAt(offset + j) & 0xFF;\n            }\n            offset += 16384;\n        }\n        // Load CHR-ROM banks:\n        this.vrom = new Array(this.vromCount);\n        for (i=0; i < this.vromCount; i++) {\n            this.vrom[i] = new Array(4096);\n            for (j=0; j < 4096; j++) {\n                if (offset+j >= data.length){\n                    break;\n                }\n                this.vrom[i][j] = data.charCodeAt(offset + j) & 0xFF;\n            }\n            offset += 4096;\n        }\n\n        // Create VROM tiles:\n        this.vromTile = new Array(this.vromCount);\n        for (i=0; i < this.vromCount; i++) {\n            this.vromTile[i] = new Array(256);\n            for (j=0; j < 256; j++) {\n                this.vromTile[i][j] = new PPU.Tile();\n            }\n        }\n\n        // Convert CHR-ROM banks to tiles:\n        var tileIndex;\n        var leftOver;\n        for (v=0; v < this.vromCount; v++) {\n            for (i=0; i < 4096; i++) {\n                tileIndex = i >> 4;\n                leftOver = i % 16;\n                if (leftOver < 8) {\n                    this.vromTile[v][tileIndex].setScanline(\n                        leftOver,\n                        this.vrom[v][i],\n                        this.vrom[v][i+8]\n                    );\n                }\n                else {\n                    this.vromTile[v][tileIndex].setScanline(\n                        leftOver-8,\n                        this.vrom[v][i-8],\n                        this.vrom[v][i]\n                    );\n                }\n            }\n        }\n\n        this.valid = true;\n    },\n\n    getMirroringType: function() {\n        if (this.fourScreen) {\n            return this.FOURSCREEN_MIRRORING;\n        }\n        if (this.mirroring === 0) {\n            return this.HORIZONTAL_MIRRORING;\n        }\n        return this.VERTICAL_MIRRORING;\n    },\n\n    getMapperName: function() {\n        if (this.mapperType >= 0 && this.mapperType < this.mapperName.length) {\n            return this.mapperName[this.mapperType];\n        }\n        return \"Unknown Mapper, \"+this.mapperType;\n    },\n\n    mapperSupported: function() {\n        return typeof Mappers[this.mapperType] !== 'undefined';\n    },\n\n    createMapper: function() {\n        if (this.mapperSupported()) {\n            return new Mappers[this.mapperType](this.nes);\n        }\n        else {\n            this.nes.ui.updateStatus(\"This ROM uses a mapper not supported by JSNES: \"+this.getMapperName()+\"(\"+this.mapperType+\")\");\n            return null;\n        }\n    }\n};\n\nexport default ROM;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/rom.js\n **/","/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport utils from './utils';\n\nconst Mappers = {};\n\nMappers[0] = function(nes) {\n    this.nes = nes;\n};\n\nMappers[0].prototype = {\n    reset: function() {\n        this.joy1StrobeState = 0;\n        this.joy2StrobeState = 0;\n        this.joypadLastWrite = 0;\n\n        this.mousePressed = false;\n        this.mouseX = null;\n        this.mouseY = null;\n    },\n\n    write: function(address, value) {\n        if (address < 0x2000) {\n            // Mirroring of RAM:\n            this.nes.cpu.mem[address & 0x7FF] = value;\n\n        }\n        else if (address > 0x4017) {\n            this.nes.cpu.mem[address] = value;\n            if (address >= 0x6000 && address < 0x8000) {\n                // Write to SaveRAM. Store in file:\n                // TODO: not yet\n                //if(this.nes.rom!=null)\n                //    this.nes.rom.writeBatteryRam(address,value);\n            }\n        }\n        else if (address > 0x2007 && address < 0x4000) {\n            this.regWrite(0x2000 + (address & 0x7), value);\n        }\n        else {\n            this.regWrite(address, value);\n        }\n    },\n\n    writelow: function(address, value) {\n        if (address < 0x2000) {\n            // Mirroring of RAM:\n            this.nes.cpu.mem[address & 0x7FF] = value;\n        }\n        else if (address > 0x4017) {\n            this.nes.cpu.mem[address] = value;\n        }\n        else if (address > 0x2007 && address < 0x4000) {\n            this.regWrite(0x2000 + (address & 0x7), value);\n        }\n        else {\n            this.regWrite(address, value);\n        }\n    },\n\n    load: function(address) {\n        // Wrap around:\n        address &= 0xFFFF;\n\n        // Check address range:\n        if (address > 0x4017) {\n            // ROM:\n            return this.nes.cpu.mem[address];\n        }\n        else if (address >= 0x2000) {\n            // I/O Ports.\n            return this.regLoad(address);\n        }\n        else {\n            // RAM (mirrored)\n            return this.nes.cpu.mem[address & 0x7FF];\n        }\n    },\n\n    regLoad: function(address) {\n        switch (address >> 12) { // use fourth nibble (0xF000)\n            case 0:\n                break;\n\n            case 1:\n                break;\n\n            case 2:\n                // Fall through to case 3\n            case 3:\n                // PPU Registers\n                switch (address & 0x7) {\n                    case 0x0:\n                        // 0x2000:\n                        // PPU Control Register 1.\n                        // (the value is stored both\n                        // in main memory and in the\n                        // PPU as flags):\n                        // (not in the real NES)\n                        return this.nes.cpu.mem[0x2000];\n\n                    case 0x1:\n                        // 0x2001:\n                        // PPU Control Register 2.\n                        // (the value is stored both\n                        // in main memory and in the\n                        // PPU as flags):\n                        // (not in the real NES)\n                        return this.nes.cpu.mem[0x2001];\n\n                    case 0x2:\n                        // 0x2002:\n                        // PPU Status Register.\n                        // The value is stored in\n                        // main memory in addition\n                        // to as flags in the PPU.\n                        // (not in the real NES)\n                        return this.nes.ppu.readStatusRegister();\n\n                    case 0x3:\n                        return 0;\n\n                    case 0x4:\n                        // 0x2004:\n                        // Sprite Memory read.\n                        return this.nes.ppu.sramLoad();\n                    case 0x5:\n                        return 0;\n\n                    case 0x6:\n                        return 0;\n\n                    case 0x7:\n                        // 0x2007:\n                        // VRAM read:\n                        return this.nes.ppu.vramLoad();\n                }\n                break;\n            case 4:\n                // Sound+Joypad registers\n                switch (address - 0x4015) {\n                    case 0:\n                        // 0x4015:\n                        // Sound channel enable, DMC Status\n                        return this.nes.papu.readReg(address);\n\n                    case 1:\n                        // 0x4016:\n                        // Joystick 1 + Strobe\n                        return this.joy1Read();\n\n                    case 2:\n                        // 0x4017:\n                        // Joystick 2 + Strobe\n                        if (this.mousePressed) {\n\n                            // Check for white pixel nearby:\n                            var sx = Math.max(0, this.mouseX - 4);\n                            var ex = Math.min(256, this.mouseX + 4);\n                            var sy = Math.max(0, this.mouseY - 4);\n                            var ey = Math.min(240, this.mouseY + 4);\n                            var w = 0;\n\n                            for (var y=sy; y<ey; y++) {\n                                for (var x=sx; x<ex; x++) {\n\n                                    if (this.nes.ppu.buffer[(y<<8)+x] == 0xFFFFFF) {\n                                        w |= 0x1<<3;\n                                        console.debug(\"Clicked on white!\");\n                                        break;\n                                    }\n                                }\n                            }\n\n                            w |= (this.mousePressed?(0x1<<4):0);\n                            return (this.joy2Read()|w) & 0xFFFF;\n                        }\n                        else {\n                            return this.joy2Read();\n                        }\n\n                }\n                break;\n        }\n        return 0;\n    },\n\n    regWrite: function(address, value) {\n        switch (address) {\n            case 0x2000:\n                // PPU Control register 1\n                this.nes.cpu.mem[address] = value;\n                this.nes.ppu.updateControlReg1(value);\n                break;\n\n            case 0x2001:\n                // PPU Control register 2\n                this.nes.cpu.mem[address] = value;\n                this.nes.ppu.updateControlReg2(value);\n                break;\n\n            case 0x2003:\n                // Set Sprite RAM address:\n                this.nes.ppu.writeSRAMAddress(value);\n                break;\n\n            case 0x2004:\n                // Write to Sprite RAM:\n                this.nes.ppu.sramWrite(value);\n                break;\n\n            case 0x2005:\n                // Screen Scroll offsets:\n                this.nes.ppu.scrollWrite(value);\n                break;\n\n            case 0x2006:\n                // Set VRAM address:\n                this.nes.ppu.writeVRAMAddress(value);\n                break;\n\n            case 0x2007:\n                // Write to VRAM:\n                this.nes.ppu.vramWrite(value);\n                break;\n\n            case 0x4014:\n                // Sprite Memory DMA Access\n                this.nes.ppu.sramDMA(value);\n                break;\n\n            case 0x4015:\n                // Sound Channel Switch, DMC Status\n                this.nes.papu.writeReg(address, value);\n                break;\n\n            case 0x4016:\n                // Joystick 1 + Strobe\n                if ((value&1) === 0 && (this.joypadLastWrite&1) === 1) {\n                    this.joy1StrobeState = 0;\n                    this.joy2StrobeState = 0;\n                }\n                this.joypadLastWrite = value;\n                break;\n\n            case 0x4017:\n                // Sound channel frame sequencer:\n                this.nes.papu.writeReg(address, value);\n                break;\n\n            default:\n                // Sound registers\n                ////System.out.println(\"write to sound reg\");\n                if (address >= 0x4000 && address <= 0x4017) {\n                    this.nes.papu.writeReg(address,value);\n                }\n\n        }\n    },\n\n    joy1Read: function() {\n        var ret;\n\n        switch (this.joy1StrobeState) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n                ret = this.nes.keyboard.state1[this.joy1StrobeState];\n                break;\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n                ret = 0;\n                break;\n            case 19:\n                ret = 1;\n                break;\n            default:\n                ret = 0;\n        }\n\n        this.joy1StrobeState++;\n        if (this.joy1StrobeState == 24) {\n            this.joy1StrobeState = 0;\n        }\n\n        return ret;\n    },\n\n    joy2Read: function() {\n        var ret;\n\n        switch (this.joy2StrobeState) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n                ret = this.nes.keyboard.state2[this.joy2StrobeState];\n                break;\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n                ret = 0;\n                break;\n            case 19:\n                ret = 1;\n                break;\n            default:\n                ret = 0;\n        }\n\n        this.joy2StrobeState++;\n        if (this.joy2StrobeState == 24) {\n            this.joy2StrobeState = 0;\n        }\n\n        return ret;\n      },\n\n    loadROM: function() {\n        if (!this.nes.rom.valid || this.nes.rom.romCount < 1) {\n            alert(\"NoMapper: Invalid ROM! Unable to load.\");\n            return;\n        }\n\n        // Load ROM into memory:\n        this.loadPRGROM();\n\n        // Load CHR-ROM:\n        this.loadCHRROM();\n\n        // Load Battery RAM (if present):\n        this.loadBatteryRam();\n\n        // Reset IRQ:\n        //nes.getCpu().doResetInterrupt();\n        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n    },\n\n    loadPRGROM: function() {\n        if (this.nes.rom.romCount > 1) {\n            // Load the two first banks into memory.\n            this.loadRomBank(0, 0x8000);\n            this.loadRomBank(1, 0xC000);\n        }\n        else {\n            // Load the one bank into both memory locations:\n            this.loadRomBank(0, 0x8000);\n            this.loadRomBank(0, 0xC000);\n        }\n    },\n\n    loadCHRROM: function() {\n        ////System.out.println(\"Loading CHR ROM..\");\n        if (this.nes.rom.vromCount > 0) {\n            if (this.nes.rom.vromCount == 1) {\n                this.loadVromBank(0,0x0000);\n                this.loadVromBank(0,0x1000);\n            }\n            else {\n                this.loadVromBank(0,0x0000);\n                this.loadVromBank(1,0x1000);\n            }\n        }\n        else {\n            //System.out.println(\"There aren't any CHR-ROM banks..\");\n        }\n    },\n\n    loadBatteryRam: function() {\n        if (this.nes.rom.batteryRam) {\n            var ram = this.nes.rom.batteryRam;\n            if (ram !== null && ram.length == 0x2000) {\n                // Load Battery RAM into memory:\n                utils.copyArrayElements(ram, 0, this.nes.cpu.mem, 0x6000, 0x2000);\n            }\n        }\n    },\n\n    loadRomBank: function(bank, address) {\n        // Loads a ROM bank into the specified address.\n        bank %= this.nes.rom.romCount;\n        //var data = this.nes.rom.rom[bank];\n        //cpuMem.write(address,data,data.length);\n        utils.copyArrayElements(this.nes.rom.rom[bank], 0, this.nes.cpu.mem, address, 16384);\n    },\n\n    loadVromBank: function(bank, address) {\n        if (this.nes.rom.vromCount === 0) {\n            return;\n        }\n        this.nes.ppu.triggerRendering();\n\n        utils.copyArrayElements(this.nes.rom.vrom[bank % this.nes.rom.vromCount],\n            0, this.nes.ppu.vramMem, address, 4096);\n\n        var vromTile = this.nes.rom.vromTile[bank % this.nes.rom.vromCount];\n        utils.copyArrayElements(vromTile, 0, this.nes.ppu.ptTile,address >> 4, 256);\n    },\n\n    load32kRomBank: function(bank, address) {\n        this.loadRomBank((bank*2) % this.nes.rom.romCount, address);\n        this.loadRomBank((bank*2+1) % this.nes.rom.romCount, address+16384);\n    },\n\n    load8kVromBank: function(bank4kStart, address) {\n        if (this.nes.rom.vromCount === 0) {\n            return;\n        }\n        this.nes.ppu.triggerRendering();\n\n        this.loadVromBank((bank4kStart) % this.nes.rom.vromCount, address);\n        this.loadVromBank((bank4kStart + 1) % this.nes.rom.vromCount,\n                address + 4096);\n    },\n\n    load1kVromBank: function(bank1k, address) {\n        if (this.nes.rom.vromCount === 0) {\n            return;\n        }\n        this.nes.ppu.triggerRendering();\n\n        var bank4k = Math.floor(bank1k / 4) % this.nes.rom.vromCount;\n        var bankoffset = (bank1k % 4) * 1024;\n        utils.copyArrayElements(this.nes.rom.vrom[bank4k], 0,\n            this.nes.ppu.vramMem, bankoffset, 1024);\n\n        // Update tiles:\n        var vromTile = this.nes.rom.vromTile[bank4k];\n        var baseIndex = address >> 4;\n        for (var i = 0; i < 64; i++) {\n            this.nes.ppu.ptTile[baseIndex+i] = vromTile[((bank1k%4) << 6) + i];\n        }\n    },\n\n    load2kVromBank: function(bank2k, address) {\n        if (this.nes.rom.vromCount === 0) {\n            return;\n        }\n        this.nes.ppu.triggerRendering();\n\n        var bank4k = Math.floor(bank2k / 2) % this.nes.rom.vromCount;\n        var bankoffset = (bank2k % 2) * 2048;\n        utils.copyArrayElements(this.nes.rom.vrom[bank4k], bankoffset,\n            this.nes.ppu.vramMem, address, 2048);\n\n        // Update tiles:\n        var vromTile = this.nes.rom.vromTile[bank4k];\n        var baseIndex = address >> 4;\n        for (var i = 0; i < 128; i++) {\n            this.nes.ppu.ptTile[baseIndex+i] = vromTile[((bank2k%2) << 7) + i];\n        }\n    },\n\n    load8kRomBank: function(bank8k, address) {\n        var bank16k = Math.floor(bank8k / 2) % this.nes.rom.romCount;\n        var offset = (bank8k % 2) * 8192;\n\n        //this.nes.cpu.mem.write(address,this.nes.rom.rom[bank16k],offset,8192);\n        utils.copyArrayElements(this.nes.rom.rom[bank16k], offset,\n                  this.nes.cpu.mem, address, 8192);\n    },\n\n    clockIrqCounter: function() {\n        // Does nothing. This is used by the MMC3 mapper.\n    },\n\n    latchAccess: function(address) {\n        // Does nothing. This is used by MMC2.\n    },\n\n    toJSON: function() {\n        return {\n            'joy1StrobeState': this.joy1StrobeState,\n            'joy2StrobeState': this.joy2StrobeState,\n            'joypadLastWrite': this.joypadLastWrite\n        };\n    },\n\n    fromJSON: function(s) {\n        this.joy1StrobeState = s.joy1StrobeState;\n        this.joy2StrobeState = s.joy2StrobeState;\n        this.joypadLastWrite = s.joypadLastWrite;\n    }\n};\n\n\nMappers[1] = function(nes) {\n    this.nes = nes;\n};\n\nMappers[1].prototype = new Mappers[0]();\n\nMappers[1].prototype.reset = function() {\n    Mappers[0].prototype.reset.apply(this);\n\n    // 5-bit buffer:\n    this.regBuffer = 0;\n    this.regBufferCounter = 0;\n\n    // Register 0:\n    this.mirroring = 0;\n    this.oneScreenMirroring = 0;\n    this.prgSwitchingArea = 1;\n    this.prgSwitchingSize = 1;\n    this.vromSwitchingSize = 0;\n\n    // Register 1:\n    this.romSelectionReg0 = 0;\n\n    // Register 2:\n    this.romSelectionReg1 = 0;\n\n    // Register 3:\n    this.romBankSelect = 0;\n};\n\nMappers[1].prototype.write = function(address, value) {\n    // Writes to addresses other than MMC registers are handled by NoMapper.\n    if (address < 0x8000) {\n        Mappers[0].prototype.write.apply(this, arguments);\n        return;\n    }\n\n    // See what should be done with the written value:\n    if ((value & 128) !== 0) {\n\n        // Reset buffering:\n        this.regBufferCounter = 0;\n        this.regBuffer = 0;\n\n        // Reset register:\n        if (this.getRegNumber(address) === 0) {\n\n            this.prgSwitchingArea = 1;\n            this.prgSwitchingSize = 1;\n\n        }\n    }\n    else {\n\n        // Continue buffering:\n        //regBuffer = (regBuffer & (0xFF-(1<<regBufferCounter))) | ((value & (1<<regBufferCounter))<<regBufferCounter);\n        this.regBuffer = (this.regBuffer & (0xFF - (1 << this.regBufferCounter))) | ((value & 1) << this.regBufferCounter);\n        this.regBufferCounter++;\n\n        if (this.regBufferCounter == 5) {\n            // Use the buffered value:\n            this.setReg(this.getRegNumber(address), this.regBuffer);\n\n            // Reset buffer:\n            this.regBuffer = 0;\n            this.regBufferCounter = 0;\n        }\n    }\n};\n\nMappers[1].prototype.setReg = function(reg, value) {\n    var tmp;\n\n    switch (reg) {\n        case 0:\n            // Mirroring:\n            tmp = value & 3;\n            if (tmp !== this.mirroring) {\n                // Set mirroring:\n                this.mirroring = tmp;\n                if ((this.mirroring & 2) === 0) {\n                    // SingleScreen mirroring overrides the other setting:\n                    this.nes.ppu.setMirroring(\n                        this.nes.rom.SINGLESCREEN_MIRRORING);\n                }\n                // Not overridden by SingleScreen mirroring.\n                else if ((this.mirroring & 1) !== 0) {\n                    this.nes.ppu.setMirroring(\n                        this.nes.rom.HORIZONTAL_MIRRORING\n                    );\n                }\n                else {\n                    this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n                }\n            }\n\n            // PRG Switching Area;\n            this.prgSwitchingArea = (value >> 2) & 1;\n\n            // PRG Switching Size:\n            this.prgSwitchingSize = (value >> 3) & 1;\n\n            // VROM Switching Size:\n            this.vromSwitchingSize = (value >> 4) & 1;\n\n            break;\n\n        case 1:\n            // ROM selection:\n            this.romSelectionReg0 = (value >> 4) & 1;\n\n            // Check whether the cart has VROM:\n            if (this.nes.rom.vromCount > 0) {\n\n                // Select VROM bank at 0x0000:\n                if (this.vromSwitchingSize === 0) {\n\n                    // Swap 8kB VROM:\n                    if (this.romSelectionReg0 === 0) {\n                        this.load8kVromBank((value & 0xF), 0x0000);\n                    }\n                    else {\n                        this.load8kVromBank(\n                            Math.floor(this.nes.rom.vromCount / 2) +\n                                (value & 0xF),\n                            0x0000\n                        );\n                    }\n\n                }\n                else {\n                    // Swap 4kB VROM:\n                    if (this.romSelectionReg0 === 0) {\n                        this.loadVromBank((value & 0xF), 0x0000);\n                    }\n                    else {\n                        this.loadVromBank(\n                            Math.floor(this.nes.rom.vromCount / 2) +\n                                (value & 0xF),\n                            0x0000\n                        );\n                    }\n                }\n            }\n\n            break;\n\n        case 2:\n            // ROM selection:\n            this.romSelectionReg1 = (value >> 4) & 1;\n\n            // Check whether the cart has VROM:\n            if (this.nes.rom.vromCount > 0) {\n\n                // Select VROM bank at 0x1000:\n                if (this.vromSwitchingSize === 1) {\n                    // Swap 4kB of VROM:\n                    if (this.romSelectionReg1 === 0) {\n                        this.loadVromBank((value & 0xF), 0x1000);\n                    }\n                    else {\n                        this.loadVromBank(\n                            Math.floor(this.nes.rom.vromCount / 2) +\n                                (value & 0xF),\n                            0x1000\n                        );\n                    }\n                }\n            }\n            break;\n\n        default:\n            // Select ROM bank:\n            // -------------------------\n            tmp = value & 0xF;\n            var bank;\n            var baseBank = 0;\n\n            if (this.nes.rom.romCount >= 32) {\n                // 1024 kB cart\n                if (this.vromSwitchingSize === 0) {\n                    if (this.romSelectionReg0 === 1) {\n                        baseBank = 16;\n                    }\n                }\n                else {\n                    baseBank = (this.romSelectionReg0\n                                | (this.romSelectionReg1 << 1)) << 3;\n                }\n            }\n            else if (this.nes.rom.romCount >= 16) {\n                // 512 kB cart\n                if (this.romSelectionReg0 === 1) {\n                    baseBank = 8;\n                }\n            }\n\n            if (this.prgSwitchingSize === 0) {\n                // 32kB\n                bank = baseBank + (value & 0xF);\n                this.load32kRomBank(bank, 0x8000);\n            }\n            else {\n                // 16kB\n                bank = baseBank * 2 + (value & 0xF);\n                if (this.prgSwitchingArea === 0) {\n                    this.loadRomBank(bank, 0xC000);\n                }\n                else {\n                    this.loadRomBank(bank, 0x8000);\n                }\n            }\n    }\n};\n\n// Returns the register number from the address written to:\nMappers[1].prototype.getRegNumber = function(address) {\n    if (address >= 0x8000 && address <= 0x9FFF) {\n        return 0;\n    }\n    else if (address >= 0xA000 && address <= 0xBFFF) {\n        return 1;\n    }\n    else if (address >= 0xC000 && address <= 0xDFFF) {\n        return 2;\n    }\n    else {\n        return 3;\n    }\n};\n\nMappers[1].prototype.loadROM = function(rom) {\n    if (!this.nes.rom.valid) {\n        alert(\"MMC1: Invalid ROM! Unable to load.\");\n        return;\n    }\n\n    // Load PRG-ROM:\n    this.loadRomBank(0, 0x8000);                         //   First ROM bank..\n    this.loadRomBank(this.nes.rom.romCount - 1, 0xC000); // ..and last ROM bank.\n\n    // Load CHR-ROM:\n    this.loadCHRROM();\n\n    // Load Battery RAM (if present):\n    this.loadBatteryRam();\n\n    // Do Reset-Interrupt:\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\nMappers[1].prototype.switchLowHighPrgRom = function(oldSetting) {\n    // not yet.\n};\n\nMappers[1].prototype.switch16to32 = function() {\n    // not yet.\n};\n\nMappers[1].prototype.switch32to16 = function() {\n    // not yet.\n};\n\nMappers[1].prototype.toJSON = function() {\n    var s = Mappers[0].prototype.toJSON.apply(this);\n    s.mirroring = this.mirroring;\n    s.oneScreenMirroring = this.oneScreenMirroring;\n    s.prgSwitchingArea = this.prgSwitchingArea;\n    s.prgSwitchingSize = this.prgSwitchingSize;\n    s.vromSwitchingSize = this.vromSwitchingSize;\n    s.romSelectionReg0 = this.romSelectionReg0;\n    s.romSelectionReg1 = this.romSelectionReg1;\n    s.romBankSelect = this.romBankSelect;\n    s.regBuffer = this.regBuffer;\n    s.regBufferCounter = this.regBufferCounter;\n    return s;\n};\n\nMappers[1].prototype.fromJSON = function(s) {\n    Mappers[0].prototype.fromJSON.apply(this, s);\n    this.mirroring = s.mirroring;\n    this.oneScreenMirroring = s.oneScreenMirroring;\n    this.prgSwitchingArea = s.prgSwitchingArea;\n    this.prgSwitchingSize = s.prgSwitchingSize;\n    this.vromSwitchingSize = s.vromSwitchingSize;\n    this.romSelectionReg0 = s.romSelectionReg0;\n    this.romSelectionReg1 = s.romSelectionReg1;\n    this.romBankSelect = s.romBankSelect;\n    this.regBuffer = s.regBuffer;\n    this.regBufferCounter = s.regBufferCounter;\n};\n\nMappers[2] = function(nes) {\n    this.nes = nes;\n};\n\nMappers[2].prototype = new Mappers[0]();\n\nMappers[2].prototype.write = function(address, value) {\n    // Writes to addresses other than MMC registers are handled by NoMapper.\n    if (address < 0x8000) {\n        Mappers[0].prototype.write.apply(this, arguments);\n        return;\n    }\n\n    else {\n        // This is a ROM bank select command.\n        // Swap in the given ROM bank at 0x8000:\n        this.loadRomBank(value, 0x8000);\n    }\n};\n\nMappers[2].prototype.loadROM = function(rom) {\n    if (!this.nes.rom.valid) {\n        alert(\"UNROM: Invalid ROM! Unable to load.\");\n        return;\n    }\n\n    // Load PRG-ROM:\n    this.loadRomBank(0, 0x8000);\n    this.loadRomBank(this.nes.rom.romCount - 1, 0xC000);\n\n    // Load CHR-ROM:\n    this.loadCHRROM();\n\n    // Do Reset-Interrupt:\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\n\nMappers[4] = function(nes) {\n    this.nes = nes;\n\n    this.CMD_SEL_2_1K_VROM_0000 = 0;\n    this.CMD_SEL_2_1K_VROM_0800 = 1;\n    this.CMD_SEL_1K_VROM_1000 = 2;\n    this.CMD_SEL_1K_VROM_1400 = 3;\n    this.CMD_SEL_1K_VROM_1800 = 4;\n    this.CMD_SEL_1K_VROM_1C00 = 5;\n    this.CMD_SEL_ROM_PAGE1 = 6;\n    this.CMD_SEL_ROM_PAGE2 = 7;\n\n    this.command = null;\n    this.prgAddressSelect = null;\n    this.chrAddressSelect = null;\n    this.pageNumber = null;\n    this.irqCounter = null;\n    this.irqLatchValue = null;\n    this.irqEnable = null;\n    this.prgAddressChanged = false;\n};\n\nMappers[4].prototype = new Mappers[0]();\n\nMappers[4].prototype.write = function(address, value) {\n    // Writes to addresses other than MMC registers are handled by NoMapper.\n    if (address < 0x8000) {\n        Mappers[0].prototype.write.apply(this, arguments);\n        return;\n    }\n\n    switch (address) {\n        case 0x8000:\n            // Command/Address Select register\n            this.command = value & 7;\n            var tmp = (value >> 6) & 1;\n            if (tmp != this.prgAddressSelect) {\n                this.prgAddressChanged = true;\n            }\n            this.prgAddressSelect = tmp;\n            this.chrAddressSelect = (value >> 7) & 1;\n            break;\n\n        case 0x8001:\n            // Page number for command\n            this.executeCommand(this.command, value);\n            break;\n\n        case 0xA000:\n            // Mirroring select\n            if ((value & 1) !== 0) {\n                this.nes.ppu.setMirroring(\n                    this.nes.rom.HORIZONTAL_MIRRORING\n                );\n            }\n            else {\n                this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n            }\n            break;\n\n        case 0xA001:\n            // SaveRAM Toggle\n            // TODO\n            //nes.getRom().setSaveState((value&1)!=0);\n            break;\n\n        case 0xC000:\n            // IRQ Counter register\n            this.irqCounter = value;\n            //nes.ppu.mapperIrqCounter = 0;\n            break;\n\n        case 0xC001:\n            // IRQ Latch register\n            this.irqLatchValue = value;\n            break;\n\n        case 0xE000:\n            // IRQ Control Reg 0 (disable)\n            //irqCounter = irqLatchValue;\n            this.irqEnable = 0;\n            break;\n\n        case 0xE001:\n            // IRQ Control Reg 1 (enable)\n            this.irqEnable = 1;\n            break;\n\n        default:\n            // Not a MMC3 register.\n            // The game has probably crashed,\n            // since it tries to write to ROM..\n            // IGNORE.\n    }\n};\n\nMappers[4].prototype.executeCommand = function(cmd, arg) {\n    switch (cmd) {\n        case this.CMD_SEL_2_1K_VROM_0000:\n            // Select 2 1KB VROM pages at 0x0000:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x0000);\n                this.load1kVromBank(arg + 1, 0x0400);\n            }\n            else {\n                this.load1kVromBank(arg, 0x1000);\n                this.load1kVromBank(arg + 1, 0x1400);\n            }\n            break;\n\n        case this.CMD_SEL_2_1K_VROM_0800:\n            // Select 2 1KB VROM pages at 0x0800:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x0800);\n                this.load1kVromBank(arg + 1, 0x0C00);\n            }\n            else {\n                this.load1kVromBank(arg, 0x1800);\n                this.load1kVromBank(arg + 1, 0x1C00);\n            }\n            break;\n\n        case this.CMD_SEL_1K_VROM_1000:\n            // Select 1K VROM Page at 0x1000:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x1000);\n            }\n            else {\n                this.load1kVromBank(arg, 0x0000);\n            }\n            break;\n\n        case this.CMD_SEL_1K_VROM_1400:\n            // Select 1K VROM Page at 0x1400:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x1400);\n            }\n            else {\n                this.load1kVromBank(arg, 0x0400);\n            }\n            break;\n\n        case this.CMD_SEL_1K_VROM_1800:\n            // Select 1K VROM Page at 0x1800:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x1800);\n            }\n            else {\n                this.load1kVromBank(arg, 0x0800);\n            }\n            break;\n\n        case this.CMD_SEL_1K_VROM_1C00:\n            // Select 1K VROM Page at 0x1C00:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x1C00);\n            }else {\n                this.load1kVromBank(arg, 0x0C00);\n            }\n            break;\n\n        case this.CMD_SEL_ROM_PAGE1:\n            if (this.prgAddressChanged) {\n                // Load the two hardwired banks:\n                if (this.prgAddressSelect === 0) {\n                    this.load8kRomBank(\n                        ((this.nes.rom.romCount - 1) * 2),\n                        0xC000\n                    );\n                }\n                else {\n                    this.load8kRomBank(\n                        ((this.nes.rom.romCount - 1) * 2),\n                        0x8000\n                    );\n                }\n                this.prgAddressChanged = false;\n            }\n\n            // Select first switchable ROM page:\n            if (this.prgAddressSelect === 0) {\n                this.load8kRomBank(arg, 0x8000);\n            }\n            else {\n                this.load8kRomBank(arg, 0xC000);\n            }\n            break;\n\n        case this.CMD_SEL_ROM_PAGE2:\n            // Select second switchable ROM page:\n            this.load8kRomBank(arg, 0xA000);\n\n            // hardwire appropriate bank:\n            if (this.prgAddressChanged) {\n                // Load the two hardwired banks:\n                if (this.prgAddressSelect === 0) {\n                    this.load8kRomBank(\n                        ((this.nes.rom.romCount - 1) * 2),\n                        0xC000\n                    );\n                }\n                else {\n                    this.load8kRomBank(\n                        ((this.nes.rom.romCount - 1) * 2),\n                        0x8000\n                    );\n                }\n                this.prgAddressChanged = false;\n            }\n    }\n};\n\nMappers[4].prototype.loadROM = function(rom) {\n    if (!this.nes.rom.valid) {\n        alert(\"MMC3: Invalid ROM! Unable to load.\");\n        return;\n    }\n\n    // Load hardwired PRG banks (0xC000 and 0xE000):\n    this.load8kRomBank(((this.nes.rom.romCount - 1) * 2), 0xC000);\n    this.load8kRomBank(((this.nes.rom.romCount - 1) * 2) + 1, 0xE000);\n\n    // Load swappable PRG banks (0x8000 and 0xA000):\n    this.load8kRomBank(0, 0x8000);\n    this.load8kRomBank(1, 0xA000);\n\n    // Load CHR-ROM:\n    this.loadCHRROM();\n\n    // Load Battery RAM (if present):\n    this.loadBatteryRam();\n\n    // Do Reset-Interrupt:\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\nMappers[4].prototype.clockIrqCounter = function() {\n    if (this.irqEnable == 1) {\n        this.irqCounter--;\n        if (this.irqCounter < 0) {\n            // Trigger IRQ:\n            //nes.getCpu().doIrq();\n            this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n            this.irqCounter = this.irqLatchValue;\n        }\n    }\n};\n\nMappers[4].prototype.toJSON = function() {\n    var s = Mappers[0].prototype.toJSON.apply(this);\n    s.command = this.command;\n    s.prgAddressSelect = this.prgAddressSelect;\n    s.chrAddressSelect = this.chrAddressSelect;\n    s.pageNumber = this.pageNumber;\n    s.irqCounter = this.irqCounter;\n    s.irqLatchValue = this.irqLatchValue;\n    s.irqEnable = this.irqEnable;\n    s.prgAddressChanged = this.prgAddressChanged;\n    return s;\n};\n\nMappers[4].prototype.fromJSON = function(s) {\n    Mappers[0].prototype.fromJSON.apply(this, s);\n    this.command = s.command;\n    this.prgAddressSelect = s.prgAddressSelect;\n    this.chrAddressSelect = s.chrAddressSelect;\n    this.pageNumber = s.pageNumber;\n    this.irqCounter = s.irqCounter;\n    this.irqLatchValue = s.irqLatchValue;\n    this.irqEnable = s.irqEnable;\n    this.prgAddressChanged = s.prgAddressChanged;\n};\n\nexport default Mappers;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/mappers.js\n **/","'use strict';\n\n/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Keyboard events are bound in the UI\nconst Keyboard = function() {\n    var i;\n\n    this.keys = {\n        KEY_A: 0,\n        KEY_B: 1,\n        KEY_SELECT: 2,\n        KEY_START: 3,\n        KEY_UP: 4,\n        KEY_DOWN: 5,\n        KEY_LEFT: 6,\n        KEY_RIGHT: 7\n    };\n\n    this.state1 = new Array(8);\n    for (i = 0; i < this.state1.length; i++) {\n        this.state1[i] = 0x40;\n    }\n    this.state2 = new Array(8);\n    for (i = 0; i < this.state2.length; i++) {\n        this.state2[i] = 0x40;\n    }\n};\n\nKeyboard.prototype = {\n    setKey: function(key, value) {\n        switch (key) {\n            case 88: this.state1[this.keys.KEY_A] = value; break;      // X\n            case 89: this.state1[this.keys.KEY_B] = value; break;      // Y (Central European keyboard)\n            case 90: this.state1[this.keys.KEY_B] = value; break;      // Z\n            case 17: this.state1[this.keys.KEY_SELECT] = value; break; // Right Ctrl\n            case 13: this.state1[this.keys.KEY_START] = value; break;  // Enter\n            case 38: this.state1[this.keys.KEY_UP] = value; break;     // Up\n            case 40: this.state1[this.keys.KEY_DOWN] = value; break;   // Down\n            case 37: this.state1[this.keys.KEY_LEFT] = value; break;   // Left\n            case 39: this.state1[this.keys.KEY_RIGHT] = value; break;  // Right\n\n            case 103: this.state2[this.keys.KEY_A] = value; break;     // Num-7\n            case 105: this.state2[this.keys.KEY_B] = value; break;     // Num-9\n            case 99: this.state2[this.keys.KEY_SELECT] = value; break; // Num-3\n            case 97: this.state2[this.keys.KEY_START] = value; break;  // Num-1\n            case 104: this.state2[this.keys.KEY_UP] = value; break;    // Num-8\n            case 98: this.state2[this.keys.KEY_DOWN] = value; break;   // Num-2\n            case 100: this.state2[this.keys.KEY_LEFT] = value; break;  // Num-4\n            case 102: this.state2[this.keys.KEY_RIGHT] = value; break; // Num-6\n            default: return true;\n        }\n        return false; // preventDefault\n    },\n\n    keyDown: function(evt) {\n        if (!this.setKey(evt.keyCode, 0x41) && evt.preventDefault) {\n            evt.preventDefault();\n        }\n    },\n\n    keyUp: function(evt) {\n        if (!this.setKey(evt.keyCode, 0x40) && evt.preventDefault) {\n            evt.preventDefault();\n        }\n    },\n\n    keyPress: function(evt) {\n        evt.preventDefault();\n    }\n};\n\nexport default Keyboard;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/keyboard.js\n **/"],"sourceRoot":""}