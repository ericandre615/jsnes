{"version":3,"sources":["webpack:///jsnes.min.js","webpack:///webpack/bootstrap 941b370b35370e42cf53","webpack:///./index.js","webpack:///./source/nes.js","webpack:///./source/cpu.js","webpack:///./source/utils.js","webpack:///./source/ppu.js","webpack:///./source/papu.js","webpack:///./source/rom.js","webpack:///./source/mappers.js","webpack:///./source/controllers.js","webpack:///./source/gamepads.js"],"names":["JSNES","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","create","undefined","_nes","_nes2","opts","_cpu","_cpu2","_ppu","_ppu2","_papu","_papu2","_rom","_rom2","_controllers","_controllers2","_gamepads","_gamepads2","DummyUI","nes","this","enable","updateStatus","writeAudio","writeFrame","ui","swfPath","preferredFrameRate","fpsInterval","showDisplay","emulateSound","sampleRate","CPU_FREQ_NTSC","CPU_FREQ_PAL","key","frameTime","cpu","ppu","papu","mmap","controllers","gamepad","VERSION","prototype","isRunning","fpsFrameCount","romData","reset","start","self","rom","valid","frameInterval","setInterval","frame","resetFps","printFps","startFrame","cycles","FRAMELOOP","cyclesToHalt","emulate","clockFrameCounter","curX","spr0HitX","f_spVisibility","scanline","spr0HitY","setStatusFlag","STATUS_SPRITE0HIT","requestEndFrame","nmiCounter","startVBlank","endScanline","now","Date","s","lastFpsTime","toFixed","stop","clearInterval","reloadRom","loadRom","data","load","createMapper","loadROM","setMirroring","getMirroringType","setFramerate","rate","setSampleRate","toJSON","fromJSON","_utils","_utils2","CPU","mem","REG_ACC","REG_X","REG_Y","REG_SP","REG_PC","REG_PC_NEW","REG_STATUS","F_CARRY","F_DECIMAL","F_INTERRUPT","F_INTERRUPT_NEW","F_OVERFLOW","F_SIGN","F_ZERO","F_NOTUSED","F_NOTUSED_NEW","F_BRK","F_BRK_NEW","opdata","crash","irqRequested","irqType","IRQ_NORMAL","IRQ_NMI","IRQ_RESET","Array","i","length","setStatus","OpData","temp","add","doIrq","doNonMaskableInterrupt","doResetInterrupt","opinf","cycleCount","cycleAdd","addrMode","opaddr","addr","load16bit","write","push","pull","stackWrap","crashMessage","toString","val","requestIrq","type","pageCrossed","addr1","addr2","haltCycles","status","getStatus","st","JSON_PROPERTIES","setOp","INS_ADC","ADDR_IMM","ADDR_ZP","ADDR_ZPX","ADDR_ABS","ADDR_ABSX","ADDR_ABSY","ADDR_PREIDXIND","ADDR_POSTIDXIND","INS_AND","INS_ASL","ADDR_ACC","INS_BCC","ADDR_REL","INS_BCS","INS_BEQ","INS_BIT","INS_BMI","INS_BNE","INS_BPL","INS_BRK","ADDR_IMP","INS_BVC","INS_BVS","INS_CLC","INS_CLD","INS_CLI","INS_CLV","INS_CMP","INS_CPX","INS_CPY","INS_DEC","INS_DEX","INS_DEY","INS_EOR","INS_INC","INS_INX","INS_INY","INS_JMP","ADDR_INDABS","INS_JSR","INS_LDA","INS_LDX","ADDR_ZPY","INS_LDY","INS_LSR","INS_NOP","INS_ORA","INS_PHA","INS_PHP","INS_PLA","INS_PLP","INS_ROL","INS_ROR","INS_RTI","INS_RTS","INS_SBC","INS_SEC","INS_SED","INS_SEI","INS_STA","INS_STX","INS_STY","INS_TAX","INS_TAY","INS_TSX","INS_TXA","INS_TXS","INS_TYA","cycTable","instname","addrDesc","INS_DUMMY","inst","op","size","utils","copyArrayElements","src","srcPos","dest","destPos","copyArray","state","isIE","test","navigator","userAgent","PPU","vramMem","spriteMem","vramAddress","vramTmpAddress","vramBufferedReadValue","firstWrite","sramAddress","currentMirroring","nmiOk","dummyCycleToggle","validTileData","scanlineAlreadyRendered","f_nmiOnVblank","f_spriteSize","f_bgPatternTable","f_spPatternTable","f_addrInc","f_nTblAddress","f_color","f_bgVisibility","f_spClipping","f_bgClipping","f_dispType","cntFV","cntV","cntH","cntVT","cntHT","regFV","regV","regH","regVT","regHT","regFH","regS","curNt","attrib","buffer","prevBuffer","bgbuffer","pixrendered","scantile","lastRenderedScanline","sprX","sprY","sprTile","sprCol","vertFlip","horiFlip","bgPriority","hitSpr0","sprPalette","imgPalette","ptTile","ntable1","nameTable","vramMirrorTable","palTable","showSpr0Hit","clipToTvSize","STATUS_VRAMWRITE","STATUS_SLSPRITECOUNT","STATUS_VBLANK","Tile","NameTable","PaletteTable","loadNTSCPalette","updateControlReg1","updateControlReg2","mirroring","triggerRendering","defineMirrorRegion","HORIZONTAL_MIRRORING","VERTICAL_MIRRORING","SINGLESCREEN_MIRRORING","SINGLESCREEN_MIRRORING2","fromStart","toStart","renderFramePartially","endFrame","renderBgScanline","checkSprite0","clockIrqCounter","regsToAddress","cntsToAddress","bgColor","x","y","setEmphasis","updatePalettes","flag","n","readStatusRegister","tmp","writeSRAMAddress","address","sramLoad","sramWrite","spriteRamWriteUpdate","scrollWrite","writeVRAMAddress","latchAccess","vramLoad","mirroredLoad","cntsFromAddress","regsFromAddress","vramWrite","mirroredWrite","writeMem","sramDMA","baseAddress","b1","b2","incTileCounter","count","alert","startScan","scanCount","renderSpritesPartially","si","ei","destIndex","scan","baseTile","t","tpix","att","col","tscanoffset","targetBuffer","tile","pix","getTileIndex","getAttrib","sx","opaque","startscan","scancount","bgPri","srcy1","srcy2","render","top","toffset","bufferIndex","tIndexAdd","patternWrite","nameTableWrite","attribTableWrite","getEntry","tileIndex","Math","floor","leftOver","setScanline","index","writeAttrib","tIndex","doNMI","width","height","name","tx","ty","attindex","basex","basey","sqy","sqx","curTable","emphTable","currentEmph","makeTables","loadPALPalette","r","g","b","rFactor","gFactor","bFactor","emph","getRed","getGreen","getBlue","getRgb","yiq","rgb","loadDefaultPalette","fbIndex","w","h","incX","incY","palIndex","tpri","initialized","setBuffer","sline","srcx1","srcx2","dx","dy","palAdd","palette","flipHorizontal","flipVertical","pri","priTable","isTransparent","PAPU","square1","ChannelSquare","square2","triangle","ChannelTriangle","noise","ChannelNoise","dmc","ChannelDM","frameIrqCounter","frameIrqCounterMax","initCounter","channelEnableValue","bufferSize","lengthLookup","dmcFreqLookup","noiseWavelengthLookup","square_table","tnd_table","sampleBuffer","frameIrqEnabled","frameIrqActive","frameClockNow","startedPlaying","recordOutput","initingHardware","masterFrameCounter","derivedFrameCounter","countSequence","sampleTimer","sampleTimerMax","sampleCount","triValue","smpSquare1","smpSquare2","smpTriangle","smpDmc","accCount","prevSampleL","prevSampleR","smpAccumL","smpAccumR","dacRange","dcValue","masterVolume","stereoPosLSquare1","stereoPosLSquare2","stereoPosLTriangle","stereoPosLNoise","stereoPosLDMC","stereoPosRSquare1","stereoPosRSquare2","stereoPosRTriangle","stereoPosRNoise","stereoPosRDMC","extraCycles","maxSample","minSample","panning","setPanning","initLengthLookup","initDmcFrequencyLookup","initNoiseWavelengthLookup","initDACtables","writeReg","updateChannelEnable","resetCounter","readReg","getLengthStatus","getIrqStatus","irqGenerated","frameCounterTick","setEnabled","nCycles","maxCycles","isEnabled","shiftCounter","dmaFrequency","clockDmc","progTimerMax","progTimerCount","linearCounter","lengthCounter","triangleCounter","sampleValue","squareCounter","updateSampleValue","acc_c","accValue","shiftReg","randomMode","randomBit","accSample","sample","sampleCondition","clockLengthCounter","clockSweep","clockEnvDecay","clockLinearCounter","sq_index","tnd_index","smpNoise","sampleValueL","sampleValueR","smpDiffL","smpDiffR","getLengthMax","getDmcFrequency","getNoiseWaveLength","pos","updateStereoPos","setMasterVolume","ival","max_sqr","max_tnd","MODE_NORMAL","MODE_LOOP","MODE_IRQ","hasSample","playMode","dmaCounter","deltaCounter","playStartAddress","playAddress","playLength","playLengthCounter","reg4012","reg4013","dacLsb","endOfSample","nextSample","envDecayDisable","envDecayLoopEnable","lengthCounterEnable","envReset","shiftNow","envDecayRate","envDecayCounter","envVolume","dutyLookup","impLookup","sqr1","sweepActive","sweepCarry","updateSweepPeriod","sweepCounter","sweepCounterMax","sweepMode","sweepShiftAmount","dutyMode","sweepResult","vol","addrAdd","lcHalt","lcControl","lcLoadValue","updateSampleCondition","clockProgrammableTimer","clockTriangleGenerator","_mappers","_mappers2","ROM","mapperName","FOURSCREEN_MIRRORING","SINGLESCREEN_MIRRORING3","SINGLESCREEN_MIRRORING4","CHRROM_MIRRORING","header","vrom","vromTile","romCount","vromCount","batteryRam","trainer","fourScreen","mapperType","j","v","indexOf","charCodeAt","foundError","offset","getMapperName","mapperSupported","Mappers","joy1StrobeState","joy2StrobeState","joypadLastWrite","mousePressed","mouseX","mouseY","regWrite","writelow","regLoad","joy1Read","max","ex","min","sy","ey","console","debug","joy2Read","ret","state1","state2","loadPRGROM","loadCHRROM","loadBatteryRam","loadRomBank","loadVromBank","ram","bank","load32kRomBank","load8kVromBank","bank4kStart","load1kVromBank","bank1k","bank4k","bankoffset","baseIndex","load2kVromBank","bank2k","load8kRomBank","bank8k","bank16k","apply","regBuffer","regBufferCounter","oneScreenMirroring","prgSwitchingArea","prgSwitchingSize","vromSwitchingSize","romSelectionReg0","romSelectionReg1","romBankSelect","arguments","getRegNumber","setReg","reg","baseBank","switchLowHighPrgRom","oldSetting","switch16to32","switch32to16","CMD_SEL_2_1K_VROM_0000","CMD_SEL_2_1K_VROM_0800","CMD_SEL_1K_VROM_1000","CMD_SEL_1K_VROM_1400","CMD_SEL_1K_VROM_1800","CMD_SEL_1K_VROM_1C00","CMD_SEL_ROM_PAGE1","CMD_SEL_ROM_PAGE2","command","prgAddressSelect","chrAddressSelect","pageNumber","irqCounter","irqLatchValue","irqEnable","prgAddressChanged","executeCommand","cmd","arg","defaultConfig","player_one","mapping","A","B","SELECT","START","UP","DOWN","LEFT","RIGHT","player_two","Controllers","config","buttons","_i","setButton","button","buttonDown","evt","buttonPressed","keyCode","detail","preventDefault","buttonUp","buttonPress","configureButton","player","log","configureAllButtons","_typeof","Symbol","iterator","constructor","Gamepad","gamepads","gamepadPoll","buttonPressedEvent","CustomEvent","checkPads","gamepadHandler","event","connecting","isButtonPressed","btn","pressed","gamepadListener","getGamepadss","webkitGetGamepadss","forEach","pad","getGamepads","len","message","window","dispatchEvent","l","axes","requestAnimationFrame","addButtonPressListener","addEventListener","e","listenForGamepadConnected","context","listenForGamepadDisconnected","cancelAnimationFrame","init"],"mappings":"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E,GAE7C/J,KAAK+M,SAAW,GAAIxG,OACX,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9B,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EA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","file":"jsnes.min.js","sourcesContent":["var JSNES =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.create = undefined;\n\t\n\tvar _nes = __webpack_require__(2);\n\t\n\tvar _nes2 = _interopRequireDefault(_nes);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _nes2.default;\n\tvar create = exports.create = function create(opts) {\n\t  return new _nes2.default(opts);\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _cpu = __webpack_require__(3);\n\t\n\tvar _cpu2 = _interopRequireDefault(_cpu);\n\t\n\tvar _ppu = __webpack_require__(5);\n\t\n\tvar _ppu2 = _interopRequireDefault(_ppu);\n\t\n\tvar _papu = __webpack_require__(6);\n\t\n\tvar _papu2 = _interopRequireDefault(_papu);\n\t\n\tvar _rom = __webpack_require__(7);\n\t\n\tvar _rom2 = _interopRequireDefault(_rom);\n\t\n\tvar _controllers = __webpack_require__(9);\n\t\n\tvar _controllers2 = _interopRequireDefault(_controllers);\n\t\n\tvar _gamepads = __webpack_require__(10);\n\t\n\tvar _gamepads2 = _interopRequireDefault(_gamepads);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar DummyUI = function DummyUI(nes) {\n\t    this.nes = nes;\n\t    this.enable = function () {};\n\t    this.updateStatus = function () {};\n\t    this.writeAudio = function () {};\n\t    this.writeFrame = function () {};\n\t};\n\t\n\tvar JSNES = function JSNES(opts) {\n\t    this.opts = {\n\t        ui: DummyUI,\n\t        swfPath: 'lib/',\n\t\n\t        preferredFrameRate: 60,\n\t        fpsInterval: 500, // Time between updating FPS in ms\n\t        showDisplay: true,\n\t\n\t        emulateSound: false,\n\t        sampleRate: 44100, // Sound sample rate in hz\n\t\n\t        CPU_FREQ_NTSC: 1789772.5, //1789772.72727272d;\n\t        CPU_FREQ_PAL: 1773447.4\n\t    };\n\t    if (typeof opts != 'undefined') {\n\t        var key;\n\t        for (key in this.opts) {\n\t            if (typeof opts[key] != 'undefined') {\n\t                this.opts[key] = opts[key];\n\t            }\n\t        }\n\t    }\n\t\n\t    this.frameTime = 1000 / this.opts.preferredFrameRate;\n\t\n\t    this.ui = new this.opts.ui(this);\n\t    this.cpu = new _cpu2.default(this);\n\t    this.ppu = new _ppu2.default(this);\n\t    this.papu = new _papu2.default(this);\n\t    this.mmap = null; // set in loadRom()\n\t    this.controllers = new _controllers2.default();\n\t    this.gamepad = new _gamepads2.default(this);\n\t\n\t    this.ui.updateStatus(\"Ready to load a ROM.\");\n\t\n\t    return this;\n\t};\n\t\n\tJSNES.VERSION = \"<%= version %>\";\n\t\n\tJSNES.prototype = {\n\t    isRunning: false,\n\t    fpsFrameCount: 0,\n\t    romData: null,\n\t\n\t    // Resets the system\n\t    reset: function reset() {\n\t        if (this.mmap !== null) {\n\t            this.mmap.reset();\n\t        }\n\t\n\t        this.cpu.reset();\n\t        this.ppu.reset();\n\t        this.papu.reset();\n\t    },\n\t\n\t    start: function start() {\n\t        var self = this;\n\t\n\t        if (this.rom !== null && this.rom.valid) {\n\t            if (!this.isRunning) {\n\t                this.isRunning = true;\n\t\n\t                this.frameInterval = setInterval(function () {\n\t                    self.frame();\n\t                }, this.frameTime);\n\t                this.resetFps();\n\t                this.printFps();\n\t                this.fpsInterval = setInterval(function () {\n\t                    self.printFps();\n\t                }, this.opts.fpsInterval);\n\t            }\n\t        } else {\n\t            this.ui.updateStatus(\"There is no ROM loaded, or it is invalid.\");\n\t        }\n\t    },\n\t\n\t    frame: function frame() {\n\t        this.ppu.startFrame();\n\t        var cycles = 0;\n\t        var emulateSound = this.opts.emulateSound;\n\t        var cpu = this.cpu;\n\t        var ppu = this.ppu;\n\t        var papu = this.papu;\n\t        FRAMELOOP: for (;;) {\n\t            if (cpu.cyclesToHalt === 0) {\n\t                // Execute a CPU instruction\n\t                cycles = cpu.emulate();\n\t                if (emulateSound) {\n\t                    papu.clockFrameCounter(cycles);\n\t                }\n\t                cycles *= 3;\n\t            } else {\n\t                if (cpu.cyclesToHalt > 8) {\n\t                    cycles = 24;\n\t                    if (emulateSound) {\n\t                        papu.clockFrameCounter(8);\n\t                    }\n\t                    cpu.cyclesToHalt -= 8;\n\t                } else {\n\t                    cycles = cpu.cyclesToHalt * 3;\n\t                    if (emulateSound) {\n\t                        papu.clockFrameCounter(cpu.cyclesToHalt);\n\t                    }\n\t                    cpu.cyclesToHalt = 0;\n\t                }\n\t            }\n\t\n\t            for (; cycles > 0; cycles--) {\n\t                if (ppu.curX === ppu.spr0HitX && ppu.f_spVisibility === 1 && ppu.scanline - 21 === ppu.spr0HitY) {\n\t                    // Set sprite 0 hit flag:\n\t                    ppu.setStatusFlag(ppu.STATUS_SPRITE0HIT, true);\n\t                }\n\t\n\t                if (ppu.requestEndFrame) {\n\t                    ppu.nmiCounter--;\n\t                    if (ppu.nmiCounter === 0) {\n\t                        ppu.requestEndFrame = false;\n\t                        ppu.startVBlank();\n\t                        break FRAMELOOP;\n\t                    }\n\t                }\n\t\n\t                ppu.curX++;\n\t                if (ppu.curX === 341) {\n\t                    ppu.curX = 0;\n\t                    ppu.endScanline();\n\t                }\n\t            }\n\t        }\n\t        this.fpsFrameCount++;\n\t    },\n\t\n\t    printFps: function printFps() {\n\t        var now = +new Date();\n\t        var s = 'Running';\n\t        if (this.lastFpsTime) {\n\t            s += ': ' + (this.fpsFrameCount / ((now - this.lastFpsTime) / 1000)).toFixed(2) + ' FPS';\n\t        }\n\t        this.ui.updateStatus(s);\n\t        this.fpsFrameCount = 0;\n\t        this.lastFpsTime = now;\n\t    },\n\t\n\t    stop: function stop() {\n\t        clearInterval(this.frameInterval);\n\t        clearInterval(this.fpsInterval);\n\t        this.isRunning = false;\n\t    },\n\t\n\t    reloadRom: function reloadRom() {\n\t        if (this.romData !== null) {\n\t            this.loadRom(this.romData);\n\t        }\n\t    },\n\t\n\t    // Loads a ROM file into the CPU and PPU.\n\t    // The ROM file is validated first.\n\t    loadRom: function loadRom(data) {\n\t        if (this.isRunning) {\n\t            this.stop();\n\t        }\n\t\n\t        this.ui.updateStatus(\"Loading ROM...\");\n\t\n\t        // Load ROM file:\n\t        this.rom = new _rom2.default(this);\n\t        this.rom.load(data);\n\t\n\t        if (this.rom.valid) {\n\t            this.reset();\n\t            this.mmap = this.rom.createMapper();\n\t            if (!this.mmap) {\n\t                return;\n\t            }\n\t            this.mmap.loadROM();\n\t            this.ppu.setMirroring(this.rom.getMirroringType());\n\t            this.romData = data;\n\t\n\t            this.ui.updateStatus(\"Successfully loaded. Ready to be started.\");\n\t        } else {\n\t            this.ui.updateStatus(\"Invalid ROM!\");\n\t        }\n\t        return this.rom.valid;\n\t    },\n\t\n\t    resetFps: function resetFps() {\n\t        this.lastFpsTime = null;\n\t        this.fpsFrameCount = 0;\n\t    },\n\t\n\t    setFramerate: function setFramerate(rate) {\n\t        this.opts.preferredFrameRate = rate;\n\t        this.frameTime = 1000 / rate;\n\t        this.papu.setSampleRate(this.opts.sampleRate, false);\n\t    },\n\t\n\t    toJSON: function toJSON() {\n\t        return {\n\t            'romData': this.romData,\n\t            'cpu': this.cpu.toJSON(),\n\t            'mmap': this.mmap.toJSON(),\n\t            'ppu': this.ppu.toJSON()\n\t        };\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        this.loadRom(s.romData);\n\t        this.cpu.fromJSON(s.cpu);\n\t        this.mmap.fromJSON(s.mmap);\n\t        this.ppu.fromJSON(s.ppu);\n\t    }\n\t};\n\t\n\texports.default = JSNES;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar CPU = function CPU(nes) {\n\t    this.nes = nes;\n\t\n\t    // Keep Chrome happy\n\t    this.mem = null;\n\t    this.REG_ACC = null;\n\t    this.REG_X = null;\n\t    this.REG_Y = null;\n\t    this.REG_SP = null;\n\t    this.REG_PC = null;\n\t    this.REG_PC_NEW = null;\n\t    this.REG_STATUS = null;\n\t    this.F_CARRY = null;\n\t    this.F_DECIMAL = null;\n\t    this.F_INTERRUPT = null;\n\t    this.F_INTERRUPT_NEW = null;\n\t    this.F_OVERFLOW = null;\n\t    this.F_SIGN = null;\n\t    this.F_ZERO = null;\n\t    this.F_NOTUSED = null;\n\t    this.F_NOTUSED_NEW = null;\n\t    this.F_BRK = null;\n\t    this.F_BRK_NEW = null;\n\t    this.opdata = null;\n\t    this.cyclesToHalt = null;\n\t    this.crash = null;\n\t    this.irqRequested = null;\n\t    this.irqType = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tCPU.prototype = {\n\t    // IRQ Types\n\t    IRQ_NORMAL: 0,\n\t    IRQ_NMI: 1,\n\t    IRQ_RESET: 2,\n\t\n\t    reset: function reset() {\n\t        // Main memory\n\t        this.mem = new Array(0x10000);\n\t\n\t        for (var i = 0; i < 0x2000; i++) {\n\t            this.mem[i] = 0xFF;\n\t        }\n\t        for (var p = 0; p < 4; p++) {\n\t            var i = p * 0x800;\n\t            this.mem[i + 0x008] = 0xF7;\n\t            this.mem[i + 0x009] = 0xEF;\n\t            this.mem[i + 0x00A] = 0xDF;\n\t            this.mem[i + 0x00F] = 0xBF;\n\t        }\n\t        for (var i = 0x2001; i < this.mem.length; i++) {\n\t            this.mem[i] = 0;\n\t        }\n\t\n\t        // CPU Registers:\n\t        this.REG_ACC = 0;\n\t        this.REG_X = 0;\n\t        this.REG_Y = 0;\n\t        // Reset Stack pointer:\n\t        this.REG_SP = 0x01FF;\n\t        // Reset Program counter:\n\t        this.REG_PC = 0x8000 - 1;\n\t        this.REG_PC_NEW = 0x8000 - 1;\n\t        // Reset Status register:\n\t        this.REG_STATUS = 0x28;\n\t\n\t        this.setStatus(0x28);\n\t\n\t        // Set flags:\n\t        this.F_CARRY = 0;\n\t        this.F_DECIMAL = 0;\n\t        this.F_INTERRUPT = 1;\n\t        this.F_INTERRUPT_NEW = 1;\n\t        this.F_OVERFLOW = 0;\n\t        this.F_SIGN = 0;\n\t        this.F_ZERO = 1;\n\t\n\t        this.F_NOTUSED = 1;\n\t        this.F_NOTUSED_NEW = 1;\n\t        this.F_BRK = 1;\n\t        this.F_BRK_NEW = 1;\n\t\n\t        this.opdata = new CPU.OpData().opdata;\n\t        this.cyclesToHalt = 0;\n\t\n\t        // Reset crash flag:\n\t        this.crash = false;\n\t\n\t        // Interrupt notification:\n\t        this.irqRequested = false;\n\t        this.irqType = null;\n\t    },\n\t\n\t    // Emulates a single CPU instruction, returns the number of cycles\n\t    emulate: function emulate() {\n\t        var temp;\n\t        var add;\n\t\n\t        // Check interrupts:\n\t        if (this.irqRequested) {\n\t            temp = this.F_CARRY | (this.F_ZERO === 0 ? 1 : 0) << 1 | this.F_INTERRUPT << 2 | this.F_DECIMAL << 3 | this.F_BRK << 4 | this.F_NOTUSED << 5 | this.F_OVERFLOW << 6 | this.F_SIGN << 7;\n\t\n\t            this.REG_PC_NEW = this.REG_PC;\n\t            this.F_INTERRUPT_NEW = this.F_INTERRUPT;\n\t            switch (this.irqType) {\n\t                case 0:\n\t                    {\n\t                        // Normal IRQ:\n\t                        if (this.F_INTERRUPT != 0) {\n\t                            ////System.out.println(\"Interrupt was masked.\");\n\t                            break;\n\t                        }\n\t                        this.doIrq(temp);\n\t                        ////System.out.println(\"Did normal IRQ. I=\"+this.F_INTERRUPT);\n\t                        break;\n\t                    }case 1:\n\t                    {\n\t                        // NMI:\n\t                        this.doNonMaskableInterrupt(temp);\n\t                        break;\n\t                    }case 2:\n\t                    {\n\t                        // Reset:\n\t                        this.doResetInterrupt();\n\t                        break;\n\t                    }\n\t            }\n\t\n\t            this.REG_PC = this.REG_PC_NEW;\n\t            this.F_INTERRUPT = this.F_INTERRUPT_NEW;\n\t            this.F_BRK = this.F_BRK_NEW;\n\t            this.irqRequested = false;\n\t        }\n\t\n\t        var opinf = this.opdata[this.nes.mmap.load(this.REG_PC + 1)];\n\t        var cycleCount = opinf >> 24;\n\t        var cycleAdd = 0;\n\t\n\t        // Find address mode:\n\t        var addrMode = opinf >> 8 & 0xFF;\n\t\n\t        // Increment PC by number of op bytes:\n\t        var opaddr = this.REG_PC;\n\t        this.REG_PC += opinf >> 16 & 0xFF;\n\t\n\t        var addr = 0;\n\t        switch (addrMode) {\n\t            case 0:\n\t                {\n\t                    // Zero Page mode. Use the address given after the opcode,\n\t                    // but without high byte.\n\t                    addr = this.load(opaddr + 2);\n\t                    break;\n\t                }case 1:\n\t                {\n\t                    // Relative mode.\n\t                    addr = this.load(opaddr + 2);\n\t                    if (addr < 0x80) {\n\t                        addr += this.REG_PC;\n\t                    } else {\n\t                        addr += this.REG_PC - 256;\n\t                    }\n\t                    break;\n\t                }case 2:\n\t                {\n\t                    // Ignore. Address is implied in instruction.\n\t                    break;\n\t                }case 3:\n\t                {\n\t                    // Absolute mode. Use the two bytes following the opcode as\n\t                    // an address.\n\t                    addr = this.load16bit(opaddr + 2);\n\t                    break;\n\t                }case 4:\n\t                {\n\t                    // Accumulator mode. The address is in the accumulator\n\t                    // register.\n\t                    addr = this.REG_ACC;\n\t                    break;\n\t                }case 5:\n\t                {\n\t                    // Immediate mode. The value is given after the opcode.\n\t                    addr = this.REG_PC;\n\t                    break;\n\t                }case 6:\n\t                {\n\t                    // Zero Page Indexed mode, X as index. Use the address given\n\t                    // after the opcode, then add the\n\t                    // X register to it to get the final address.\n\t                    addr = this.load(opaddr + 2) + this.REG_X & 0xFF;\n\t                    break;\n\t                }case 7:\n\t                {\n\t                    // Zero Page Indexed mode, Y as index. Use the address given\n\t                    // after the opcode, then add the\n\t                    // Y register to it to get the final address.\n\t                    addr = this.load(opaddr + 2) + this.REG_Y & 0xFF;\n\t                    break;\n\t                }case 8:\n\t                {\n\t                    // Absolute Indexed Mode, X as index. Same as zero page\n\t                    // indexed, but with the high byte.\n\t                    addr = this.load16bit(opaddr + 2);\n\t                    if ((addr & 0xFF00) != (addr + this.REG_X & 0xFF00)) {\n\t                        cycleAdd = 1;\n\t                    }\n\t                    addr += this.REG_X;\n\t                    break;\n\t                }case 9:\n\t                {\n\t                    // Absolute Indexed Mode, Y as index. Same as zero page\n\t                    // indexed, but with the high byte.\n\t                    addr = this.load16bit(opaddr + 2);\n\t                    if ((addr & 0xFF00) != (addr + this.REG_Y & 0xFF00)) {\n\t                        cycleAdd = 1;\n\t                    }\n\t                    addr += this.REG_Y;\n\t                    break;\n\t                }case 10:\n\t                {\n\t                    // Pre-indexed Indirect mode. Find the 16-bit address\n\t                    // starting at the given location plus\n\t                    // the current X register. The value is the contents of that\n\t                    // address.\n\t                    addr = this.load(opaddr + 2);\n\t                    if ((addr & 0xFF00) != (addr + this.REG_X & 0xFF00)) {\n\t                        cycleAdd = 1;\n\t                    }\n\t                    addr += this.REG_X;\n\t                    addr &= 0xFF;\n\t                    addr = this.load16bit(addr);\n\t                    break;\n\t                }case 11:\n\t                {\n\t                    // Post-indexed Indirect mode. Find the 16-bit address\n\t                    // contained in the given location\n\t                    // (and the one following). Add to that address the contents\n\t                    // of the Y register. Fetch the value\n\t                    // stored at that adress.\n\t                    addr = this.load16bit(this.load(opaddr + 2));\n\t                    if ((addr & 0xFF00) != (addr + this.REG_Y & 0xFF00)) {\n\t                        cycleAdd = 1;\n\t                    }\n\t                    addr += this.REG_Y;\n\t                    break;\n\t                }case 12:\n\t                {\n\t                    // Indirect Absolute mode. Find the 16-bit address contained\n\t                    // at the given location.\n\t                    addr = this.load16bit(opaddr + 2); // Find op\n\t                    if (addr < 0x1FFF) {\n\t                        addr = this.mem[addr] + (this.mem[addr & 0xFF00 | (addr & 0xFF) + 1 & 0xFF] << 8); // Read from address given in op\n\t                    } else {\n\t                        addr = this.nes.mmap.load(addr) + (this.nes.mmap.load(addr & 0xFF00 | (addr & 0xFF) + 1 & 0xFF) << 8);\n\t                    }\n\t                    break;\n\t                }\n\t\n\t        }\n\t        // Wrap around for addresses above 0xFFFF:\n\t        addr &= 0xFFFF;\n\t\n\t        // ----------------------------------------------------------------------------------------------------\n\t        // Decode & execute instruction:\n\t        // ----------------------------------------------------------------------------------------------------\n\t\n\t        // This should be compiled to a jump table.\n\t        switch (opinf & 0xFF) {\n\t            case 0:\n\t                {\n\t                    // *******\n\t                    // * ADC *\n\t                    // *******\n\t\n\t                    // Add with carry.\n\t                    temp = this.REG_ACC + this.load(addr) + this.F_CARRY;\n\t                    this.F_OVERFLOW = !(((this.REG_ACC ^ this.load(addr)) & 0x80) != 0) && ((this.REG_ACC ^ temp) & 0x80) != 0 ? 1 : 0;\n\t                    this.F_CARRY = temp > 255 ? 1 : 0;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    this.REG_ACC = temp & 255;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 1:\n\t                {\n\t                    // *******\n\t                    // * AND *\n\t                    // *******\n\t\n\t                    // AND memory with accumulator.\n\t                    this.REG_ACC = this.REG_ACC & this.load(addr);\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    //this.REG_ACC = temp;\n\t                    if (addrMode != 11) cycleCount += cycleAdd; // PostIdxInd = 11\n\t                    break;\n\t                }case 2:\n\t                {\n\t                    // *******\n\t                    // * ASL *\n\t                    // *******\n\t\n\t                    // Shift left one bit\n\t                    if (addrMode == 4) {\n\t                        // ADDR_ACC = 4\n\t\n\t                        this.F_CARRY = this.REG_ACC >> 7 & 1;\n\t                        this.REG_ACC = this.REG_ACC << 1 & 255;\n\t                        this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                        this.F_ZERO = this.REG_ACC;\n\t                    } else {\n\t\n\t                        temp = this.load(addr);\n\t                        this.F_CARRY = temp >> 7 & 1;\n\t                        temp = temp << 1 & 255;\n\t                        this.F_SIGN = temp >> 7 & 1;\n\t                        this.F_ZERO = temp;\n\t                        this.write(addr, temp);\n\t                    }\n\t                    break;\n\t                }case 3:\n\t                {\n\t\n\t                    // *******\n\t                    // * BCC *\n\t                    // *******\n\t\n\t                    // Branch on carry clear\n\t                    if (this.F_CARRY == 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 4:\n\t                {\n\t\n\t                    // *******\n\t                    // * BCS *\n\t                    // *******\n\t\n\t                    // Branch on carry set\n\t                    if (this.F_CARRY == 1) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 5:\n\t                {\n\t\n\t                    // *******\n\t                    // * BEQ *\n\t                    // *******\n\t\n\t                    // Branch on zero\n\t                    if (this.F_ZERO == 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 6:\n\t                {\n\t\n\t                    // *******\n\t                    // * BIT *\n\t                    // *******\n\t\n\t                    temp = this.load(addr);\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_OVERFLOW = temp >> 6 & 1;\n\t                    temp &= this.REG_ACC;\n\t                    this.F_ZERO = temp;\n\t                    break;\n\t                }case 7:\n\t                {\n\t\n\t                    // *******\n\t                    // * BMI *\n\t                    // *******\n\t\n\t                    // Branch on negative result\n\t                    if (this.F_SIGN == 1) {\n\t                        cycleCount++;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 8:\n\t                {\n\t\n\t                    // *******\n\t                    // * BNE *\n\t                    // *******\n\t\n\t                    // Branch on not zero\n\t                    if (this.F_ZERO != 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 9:\n\t                {\n\t\n\t                    // *******\n\t                    // * BPL *\n\t                    // *******\n\t\n\t                    // Branch on positive result\n\t                    if (this.F_SIGN == 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 10:\n\t                {\n\t\n\t                    // *******\n\t                    // * BRK *\n\t                    // *******\n\t\n\t                    this.REG_PC += 2;\n\t                    this.push(this.REG_PC >> 8 & 255);\n\t                    this.push(this.REG_PC & 255);\n\t                    this.F_BRK = 1;\n\t\n\t                    this.push(this.F_CARRY | (this.F_ZERO == 0 ? 1 : 0) << 1 | this.F_INTERRUPT << 2 | this.F_DECIMAL << 3 | this.F_BRK << 4 | this.F_NOTUSED << 5 | this.F_OVERFLOW << 6 | this.F_SIGN << 7);\n\t\n\t                    this.F_INTERRUPT = 1;\n\t                    //this.REG_PC = load(0xFFFE) | (load(0xFFFF) << 8);\n\t                    this.REG_PC = this.load16bit(0xFFFE);\n\t                    this.REG_PC--;\n\t                    break;\n\t                }case 11:\n\t                {\n\t\n\t                    // *******\n\t                    // * BVC *\n\t                    // *******\n\t\n\t                    // Branch on overflow clear\n\t                    if (this.F_OVERFLOW == 0) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 12:\n\t                {\n\t\n\t                    // *******\n\t                    // * BVS *\n\t                    // *******\n\t\n\t                    // Branch on overflow set\n\t                    if (this.F_OVERFLOW == 1) {\n\t                        cycleCount += (opaddr & 0xFF00) != (addr & 0xFF00) ? 2 : 1;\n\t                        this.REG_PC = addr;\n\t                    }\n\t                    break;\n\t                }case 13:\n\t                {\n\t\n\t                    // *******\n\t                    // * CLC *\n\t                    // *******\n\t\n\t                    // Clear carry flag\n\t                    this.F_CARRY = 0;\n\t                    break;\n\t                }case 14:\n\t                {\n\t\n\t                    // *******\n\t                    // * CLD *\n\t                    // *******\n\t\n\t                    // Clear decimal flag\n\t                    this.F_DECIMAL = 0;\n\t                    break;\n\t                }case 15:\n\t                {\n\t\n\t                    // *******\n\t                    // * CLI *\n\t                    // *******\n\t\n\t                    // Clear interrupt flag\n\t                    this.F_INTERRUPT = 0;\n\t                    break;\n\t                }case 16:\n\t                {\n\t\n\t                    // *******\n\t                    // * CLV *\n\t                    // *******\n\t\n\t                    // Clear overflow flag\n\t                    this.F_OVERFLOW = 0;\n\t                    break;\n\t                }case 17:\n\t                {\n\t\n\t                    // *******\n\t                    // * CMP *\n\t                    // *******\n\t\n\t                    // Compare memory and accumulator:\n\t                    temp = this.REG_ACC - this.load(addr);\n\t                    this.F_CARRY = temp >= 0 ? 1 : 0;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 18:\n\t                {\n\t\n\t                    // *******\n\t                    // * CPX *\n\t                    // *******\n\t\n\t                    // Compare memory and index X:\n\t                    temp = this.REG_X - this.load(addr);\n\t                    this.F_CARRY = temp >= 0 ? 1 : 0;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    break;\n\t                }case 19:\n\t                {\n\t\n\t                    // *******\n\t                    // * CPY *\n\t                    // *******\n\t\n\t                    // Compare memory and index Y:\n\t                    temp = this.REG_Y - this.load(addr);\n\t                    this.F_CARRY = temp >= 0 ? 1 : 0;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    break;\n\t                }case 20:\n\t                {\n\t\n\t                    // *******\n\t                    // * DEC *\n\t                    // *******\n\t\n\t                    // Decrement memory by one:\n\t                    temp = this.load(addr) - 1 & 0xFF;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    this.write(addr, temp);\n\t                    break;\n\t                }case 21:\n\t                {\n\t\n\t                    // *******\n\t                    // * DEX *\n\t                    // *******\n\t\n\t                    // Decrement index X by one:\n\t                    this.REG_X = this.REG_X - 1 & 0xFF;\n\t                    this.F_SIGN = this.REG_X >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    break;\n\t                }case 22:\n\t                {\n\t\n\t                    // *******\n\t                    // * DEY *\n\t                    // *******\n\t\n\t                    // Decrement index Y by one:\n\t                    this.REG_Y = this.REG_Y - 1 & 0xFF;\n\t                    this.F_SIGN = this.REG_Y >> 7 & 1;\n\t                    this.F_ZERO = this.REG_Y;\n\t                    break;\n\t                }case 23:\n\t                {\n\t\n\t                    // *******\n\t                    // * EOR *\n\t                    // *******\n\t\n\t                    // XOR Memory with accumulator, store in accumulator:\n\t                    this.REG_ACC = (this.load(addr) ^ this.REG_ACC) & 0xFF;\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 24:\n\t                {\n\t\n\t                    // *******\n\t                    // * INC *\n\t                    // *******\n\t\n\t                    // Increment memory by one:\n\t                    temp = this.load(addr) + 1 & 0xFF;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    this.write(addr, temp & 0xFF);\n\t                    break;\n\t                }case 25:\n\t                {\n\t\n\t                    // *******\n\t                    // * INX *\n\t                    // *******\n\t\n\t                    // Increment index X by one:\n\t                    this.REG_X = this.REG_X + 1 & 0xFF;\n\t                    this.F_SIGN = this.REG_X >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    break;\n\t                }case 26:\n\t                {\n\t\n\t                    // *******\n\t                    // * INY *\n\t                    // *******\n\t\n\t                    // Increment index Y by one:\n\t                    this.REG_Y++;\n\t                    this.REG_Y &= 0xFF;\n\t                    this.F_SIGN = this.REG_Y >> 7 & 1;\n\t                    this.F_ZERO = this.REG_Y;\n\t                    break;\n\t                }case 27:\n\t                {\n\t\n\t                    // *******\n\t                    // * JMP *\n\t                    // *******\n\t\n\t                    // Jump to new location:\n\t                    this.REG_PC = addr - 1;\n\t                    break;\n\t                }case 28:\n\t                {\n\t\n\t                    // *******\n\t                    // * JSR *\n\t                    // *******\n\t\n\t                    // Jump to new location, saving return address.\n\t                    // Push return address on stack:\n\t                    this.push(this.REG_PC >> 8 & 255);\n\t                    this.push(this.REG_PC & 255);\n\t                    this.REG_PC = addr - 1;\n\t                    break;\n\t                }case 29:\n\t                {\n\t\n\t                    // *******\n\t                    // * LDA *\n\t                    // *******\n\t\n\t                    // Load accumulator with memory:\n\t                    this.REG_ACC = this.load(addr);\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 30:\n\t                {\n\t\n\t                    // *******\n\t                    // * LDX *\n\t                    // *******\n\t\n\t                    // Load index X with memory:\n\t                    this.REG_X = this.load(addr);\n\t                    this.F_SIGN = this.REG_X >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 31:\n\t                {\n\t\n\t                    // *******\n\t                    // * LDY *\n\t                    // *******\n\t\n\t                    // Load index Y with memory:\n\t                    this.REG_Y = this.load(addr);\n\t                    this.F_SIGN = this.REG_Y >> 7 & 1;\n\t                    this.F_ZERO = this.REG_Y;\n\t                    cycleCount += cycleAdd;\n\t                    break;\n\t                }case 32:\n\t                {\n\t\n\t                    // *******\n\t                    // * LSR *\n\t                    // *******\n\t\n\t                    // Shift right one bit:\n\t                    if (addrMode == 4) {\n\t                        // ADDR_ACC\n\t\n\t                        temp = this.REG_ACC & 0xFF;\n\t                        this.F_CARRY = temp & 1;\n\t                        temp >>= 1;\n\t                        this.REG_ACC = temp;\n\t                    } else {\n\t\n\t                        temp = this.load(addr) & 0xFF;\n\t                        this.F_CARRY = temp & 1;\n\t                        temp >>= 1;\n\t                        this.write(addr, temp);\n\t                    }\n\t                    this.F_SIGN = 0;\n\t                    this.F_ZERO = temp;\n\t                    break;\n\t                }case 33:\n\t                {\n\t\n\t                    // *******\n\t                    // * NOP *\n\t                    // *******\n\t\n\t                    // No OPeration.\n\t                    // Ignore.\n\t                    break;\n\t                }case 34:\n\t                {\n\t\n\t                    // *******\n\t                    // * ORA *\n\t                    // *******\n\t\n\t                    // OR memory with accumulator, store in accumulator.\n\t                    temp = (this.load(addr) | this.REG_ACC) & 255;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    this.REG_ACC = temp;\n\t                    if (addrMode != 11) cycleCount += cycleAdd; // PostIdxInd = 11\n\t                    break;\n\t                }case 35:\n\t                {\n\t\n\t                    // *******\n\t                    // * PHA *\n\t                    // *******\n\t\n\t                    // Push accumulator on stack\n\t                    this.push(this.REG_ACC);\n\t                    break;\n\t                }case 36:\n\t                {\n\t\n\t                    // *******\n\t                    // * PHP *\n\t                    // *******\n\t\n\t                    // Push processor status on stack\n\t                    this.F_BRK = 1;\n\t                    this.push(this.F_CARRY | (this.F_ZERO == 0 ? 1 : 0) << 1 | this.F_INTERRUPT << 2 | this.F_DECIMAL << 3 | this.F_BRK << 4 | this.F_NOTUSED << 5 | this.F_OVERFLOW << 6 | this.F_SIGN << 7);\n\t                    break;\n\t                }case 37:\n\t                {\n\t\n\t                    // *******\n\t                    // * PLA *\n\t                    // *******\n\t\n\t                    // Pull accumulator from stack\n\t                    this.REG_ACC = this.pull();\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    break;\n\t                }case 38:\n\t                {\n\t\n\t                    // *******\n\t                    // * PLP *\n\t                    // *******\n\t\n\t                    // Pull processor status from stack\n\t                    temp = this.pull();\n\t                    this.F_CARRY = temp & 1;\n\t                    this.F_ZERO = (temp >> 1 & 1) == 1 ? 0 : 1;\n\t                    this.F_INTERRUPT = temp >> 2 & 1;\n\t                    this.F_DECIMAL = temp >> 3 & 1;\n\t                    this.F_BRK = temp >> 4 & 1;\n\t                    this.F_NOTUSED = temp >> 5 & 1;\n\t                    this.F_OVERFLOW = temp >> 6 & 1;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t\n\t                    this.F_NOTUSED = 1;\n\t                    break;\n\t                }case 39:\n\t                {\n\t\n\t                    // *******\n\t                    // * ROL *\n\t                    // *******\n\t\n\t                    // Rotate one bit left\n\t                    if (addrMode == 4) {\n\t                        // ADDR_ACC = 4\n\t\n\t                        temp = this.REG_ACC;\n\t                        add = this.F_CARRY;\n\t                        this.F_CARRY = temp >> 7 & 1;\n\t                        temp = (temp << 1 & 0xFF) + add;\n\t                        this.REG_ACC = temp;\n\t                    } else {\n\t\n\t                        temp = this.load(addr);\n\t                        add = this.F_CARRY;\n\t                        this.F_CARRY = temp >> 7 & 1;\n\t                        temp = (temp << 1 & 0xFF) + add;\n\t                        this.write(addr, temp);\n\t                    }\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    break;\n\t                }case 40:\n\t                {\n\t\n\t                    // *******\n\t                    // * ROR *\n\t                    // *******\n\t\n\t                    // Rotate one bit right\n\t                    if (addrMode == 4) {\n\t                        // ADDR_ACC = 4\n\t\n\t                        add = this.F_CARRY << 7;\n\t                        this.F_CARRY = this.REG_ACC & 1;\n\t                        temp = (this.REG_ACC >> 1) + add;\n\t                        this.REG_ACC = temp;\n\t                    } else {\n\t\n\t                        temp = this.load(addr);\n\t                        add = this.F_CARRY << 7;\n\t                        this.F_CARRY = temp & 1;\n\t                        temp = (temp >> 1) + add;\n\t                        this.write(addr, temp);\n\t                    }\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp;\n\t                    break;\n\t                }case 41:\n\t                {\n\t\n\t                    // *******\n\t                    // * RTI *\n\t                    // *******\n\t\n\t                    // Return from interrupt. Pull status and PC from stack.\n\t\n\t                    temp = this.pull();\n\t                    this.F_CARRY = temp & 1;\n\t                    this.F_ZERO = (temp >> 1 & 1) == 0 ? 1 : 0;\n\t                    this.F_INTERRUPT = temp >> 2 & 1;\n\t                    this.F_DECIMAL = temp >> 3 & 1;\n\t                    this.F_BRK = temp >> 4 & 1;\n\t                    this.F_NOTUSED = temp >> 5 & 1;\n\t                    this.F_OVERFLOW = temp >> 6 & 1;\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t\n\t                    this.REG_PC = this.pull();\n\t                    this.REG_PC += this.pull() << 8;\n\t                    if (this.REG_PC == 0xFFFF) {\n\t                        return;\n\t                    }\n\t                    this.REG_PC--;\n\t                    this.F_NOTUSED = 1;\n\t                    break;\n\t                }case 42:\n\t                {\n\t\n\t                    // *******\n\t                    // * RTS *\n\t                    // *******\n\t\n\t                    // Return from subroutine. Pull PC from stack.\n\t\n\t                    this.REG_PC = this.pull();\n\t                    this.REG_PC += this.pull() << 8;\n\t\n\t                    if (this.REG_PC == 0xFFFF) {\n\t                        return; // return from NSF play routine:\n\t                    }\n\t                    break;\n\t                }case 43:\n\t                {\n\t\n\t                    // *******\n\t                    // * SBC *\n\t                    // *******\n\t\n\t                    temp = this.REG_ACC - this.load(addr) - (1 - this.F_CARRY);\n\t                    this.F_SIGN = temp >> 7 & 1;\n\t                    this.F_ZERO = temp & 0xFF;\n\t                    this.F_OVERFLOW = ((this.REG_ACC ^ temp) & 0x80) != 0 && ((this.REG_ACC ^ this.load(addr)) & 0x80) != 0 ? 1 : 0;\n\t                    this.F_CARRY = temp < 0 ? 0 : 1;\n\t                    this.REG_ACC = temp & 0xFF;\n\t                    if (addrMode != 11) cycleCount += cycleAdd; // PostIdxInd = 11\n\t                    break;\n\t                }case 44:\n\t                {\n\t\n\t                    // *******\n\t                    // * SEC *\n\t                    // *******\n\t\n\t                    // Set carry flag\n\t                    this.F_CARRY = 1;\n\t                    break;\n\t                }case 45:\n\t                {\n\t\n\t                    // *******\n\t                    // * SED *\n\t                    // *******\n\t\n\t                    // Set decimal mode\n\t                    this.F_DECIMAL = 1;\n\t                    break;\n\t                }case 46:\n\t                {\n\t\n\t                    // *******\n\t                    // * SEI *\n\t                    // *******\n\t\n\t                    // Set interrupt disable status\n\t                    this.F_INTERRUPT = 1;\n\t                    break;\n\t                }case 47:\n\t                {\n\t\n\t                    // *******\n\t                    // * STA *\n\t                    // *******\n\t\n\t                    // Store accumulator in memory\n\t                    this.write(addr, this.REG_ACC);\n\t                    break;\n\t                }case 48:\n\t                {\n\t\n\t                    // *******\n\t                    // * STX *\n\t                    // *******\n\t\n\t                    // Store index X in memory\n\t                    this.write(addr, this.REG_X);\n\t                    break;\n\t                }case 49:\n\t                {\n\t\n\t                    // *******\n\t                    // * STY *\n\t                    // *******\n\t\n\t                    // Store index Y in memory:\n\t                    this.write(addr, this.REG_Y);\n\t                    break;\n\t                }case 50:\n\t                {\n\t\n\t                    // *******\n\t                    // * TAX *\n\t                    // *******\n\t\n\t                    // Transfer accumulator to index X:\n\t                    this.REG_X = this.REG_ACC;\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    break;\n\t                }case 51:\n\t                {\n\t\n\t                    // *******\n\t                    // * TAY *\n\t                    // *******\n\t\n\t                    // Transfer accumulator to index Y:\n\t                    this.REG_Y = this.REG_ACC;\n\t                    this.F_SIGN = this.REG_ACC >> 7 & 1;\n\t                    this.F_ZERO = this.REG_ACC;\n\t                    break;\n\t                }case 52:\n\t                {\n\t\n\t                    // *******\n\t                    // * TSX *\n\t                    // *******\n\t\n\t                    // Transfer stack pointer to index X:\n\t                    this.REG_X = this.REG_SP - 0x0100;\n\t                    this.F_SIGN = this.REG_SP >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    break;\n\t                }case 53:\n\t                {\n\t\n\t                    // *******\n\t                    // * TXA *\n\t                    // *******\n\t\n\t                    // Transfer index X to accumulator:\n\t                    this.REG_ACC = this.REG_X;\n\t                    this.F_SIGN = this.REG_X >> 7 & 1;\n\t                    this.F_ZERO = this.REG_X;\n\t                    break;\n\t                }case 54:\n\t                {\n\t\n\t                    // *******\n\t                    // * TXS *\n\t                    // *******\n\t\n\t                    // Transfer index X to stack pointer:\n\t                    this.REG_SP = this.REG_X + 0x0100;\n\t                    this.stackWrap();\n\t                    break;\n\t                }case 55:\n\t                {\n\t\n\t                    // *******\n\t                    // * TYA *\n\t                    // *******\n\t\n\t                    // Transfer index Y to accumulator:\n\t                    this.REG_ACC = this.REG_Y;\n\t                    this.F_SIGN = this.REG_Y >> 7 & 1;\n\t                    this.F_ZERO = this.REG_Y;\n\t                    break;\n\t                }default:\n\t                {\n\t\n\t                    // *******\n\t                    // * ??? *\n\t                    // *******\n\t\n\t                    this.nes.stop();\n\t                    this.nes.crashMessage = \"Game crashed, invalid opcode at address $\" + opaddr.toString(16);\n\t                    break;\n\t                }\n\t\n\t        } // end of switch\n\t\n\t        return cycleCount;\n\t    },\n\t\n\t    load: function load(addr) {\n\t        if (addr < 0x2000) {\n\t            return this.mem[addr & 0x7FF];\n\t        } else {\n\t            return this.nes.mmap.load(addr);\n\t        }\n\t    },\n\t\n\t    load16bit: function load16bit(addr) {\n\t        if (addr < 0x1FFF) {\n\t            return this.mem[addr & 0x7FF] | this.mem[addr + 1 & 0x7FF] << 8;\n\t        } else {\n\t            return this.nes.mmap.load(addr) | this.nes.mmap.load(addr + 1) << 8;\n\t        }\n\t    },\n\t\n\t    write: function write(addr, val) {\n\t        if (addr < 0x2000) {\n\t            this.mem[addr & 0x7FF] = val;\n\t        } else {\n\t            this.nes.mmap.write(addr, val);\n\t        }\n\t    },\n\t\n\t    requestIrq: function requestIrq(type) {\n\t        if (this.irqRequested) {\n\t            if (type == this.IRQ_NORMAL) {\n\t                return;\n\t            }\n\t            ////System.out.println(\"too fast irqs. type=\"+type);\n\t        }\n\t        this.irqRequested = true;\n\t        this.irqType = type;\n\t    },\n\t\n\t    push: function push(value) {\n\t        this.nes.mmap.write(this.REG_SP, value);\n\t        this.REG_SP--;\n\t        this.REG_SP = 0x0100 | this.REG_SP & 0xFF;\n\t    },\n\t\n\t    stackWrap: function stackWrap() {\n\t        this.REG_SP = 0x0100 | this.REG_SP & 0xFF;\n\t    },\n\t\n\t    pull: function pull() {\n\t        this.REG_SP++;\n\t        this.REG_SP = 0x0100 | this.REG_SP & 0xFF;\n\t        return this.nes.mmap.load(this.REG_SP);\n\t    },\n\t\n\t    pageCrossed: function pageCrossed(addr1, addr2) {\n\t        return (addr1 & 0xFF00) != (addr2 & 0xFF00);\n\t    },\n\t\n\t    haltCycles: function haltCycles(cycles) {\n\t        this.cyclesToHalt += cycles;\n\t    },\n\t\n\t    doNonMaskableInterrupt: function doNonMaskableInterrupt(status) {\n\t        if ((this.nes.mmap.load(0x2000) & 128) != 0) {\n\t            // Check whether VBlank Interrupts are enabled\n\t\n\t            this.REG_PC_NEW++;\n\t            this.push(this.REG_PC_NEW >> 8 & 0xFF);\n\t            this.push(this.REG_PC_NEW & 0xFF);\n\t            //this.F_INTERRUPT_NEW = 1;\n\t            this.push(status);\n\t\n\t            this.REG_PC_NEW = this.nes.mmap.load(0xFFFA) | this.nes.mmap.load(0xFFFB) << 8;\n\t            this.REG_PC_NEW--;\n\t        }\n\t    },\n\t\n\t    doResetInterrupt: function doResetInterrupt() {\n\t        this.REG_PC_NEW = this.nes.mmap.load(0xFFFC) | this.nes.mmap.load(0xFFFD) << 8;\n\t        this.REG_PC_NEW--;\n\t    },\n\t\n\t    doIrq: function doIrq(status) {\n\t        this.REG_PC_NEW++;\n\t        this.push(this.REG_PC_NEW >> 8 & 0xFF);\n\t        this.push(this.REG_PC_NEW & 0xFF);\n\t        this.push(status);\n\t        this.F_INTERRUPT_NEW = 1;\n\t        this.F_BRK_NEW = 0;\n\t\n\t        this.REG_PC_NEW = this.nes.mmap.load(0xFFFE) | this.nes.mmap.load(0xFFFF) << 8;\n\t        this.REG_PC_NEW--;\n\t    },\n\t\n\t    getStatus: function getStatus() {\n\t        return this.F_CARRY | this.F_ZERO << 1 | this.F_INTERRUPT << 2 | this.F_DECIMAL << 3 | this.F_BRK << 4 | this.F_NOTUSED << 5 | this.F_OVERFLOW << 6 | this.F_SIGN << 7;\n\t    },\n\t\n\t    setStatus: function setStatus(st) {\n\t        this.F_CARRY = st & 1;\n\t        this.F_ZERO = st >> 1 & 1;\n\t        this.F_INTERRUPT = st >> 2 & 1;\n\t        this.F_DECIMAL = st >> 3 & 1;\n\t        this.F_BRK = st >> 4 & 1;\n\t        this.F_NOTUSED = st >> 5 & 1;\n\t        this.F_OVERFLOW = st >> 6 & 1;\n\t        this.F_SIGN = st >> 7 & 1;\n\t    },\n\t\n\t    JSON_PROPERTIES: ['mem', 'cyclesToHalt', 'irqRequested', 'irqType',\n\t    // Registers\n\t    'REG_ACC', 'REG_X', 'REG_Y', 'REG_SP', 'REG_PC', 'REG_PC_NEW', 'REG_STATUS',\n\t    // Status\n\t    'F_CARRY', 'F_DECIMAL', 'F_INTERRUPT', 'F_INTERRUPT_NEW', 'F_OVERFLOW', 'F_SIGN', 'F_ZERO', 'F_NOTUSED', 'F_NOTUSED_NEW', 'F_BRK', 'F_BRK_NEW'],\n\t\n\t    toJSON: function toJSON() {\n\t        return _utils2.default.toJSON(this);\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        _utils2.default.fromJSON(this, s);\n\t    }\n\t};\n\t\n\t// Generates and provides an array of details about instructions\n\tCPU.OpData = function () {\n\t    this.opdata = new Array(256);\n\t\n\t    // Set all to invalid instruction (to detect crashes):\n\t    for (var i = 0; i < 256; i++) {\n\t        this.opdata[i] = 0xFF;\n\t    } // Now fill in all valid opcodes:\n\t\n\t    // ADC:\n\t    this.setOp(this.INS_ADC, 0x69, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_ADC, 0x65, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_ADC, 0x75, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_ADC, 0x6D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_ADC, 0x7D, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_ADC, 0x79, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_ADC, 0x61, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_ADC, 0x71, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // AND:\n\t    this.setOp(this.INS_AND, 0x29, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_AND, 0x25, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_AND, 0x35, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_AND, 0x2D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_AND, 0x3D, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_AND, 0x39, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_AND, 0x21, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_AND, 0x31, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // ASL:\n\t    this.setOp(this.INS_ASL, 0x0A, this.ADDR_ACC, 1, 2);\n\t    this.setOp(this.INS_ASL, 0x06, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_ASL, 0x16, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_ASL, 0x0E, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_ASL, 0x1E, this.ADDR_ABSX, 3, 7);\n\t\n\t    // BCC:\n\t    this.setOp(this.INS_BCC, 0x90, this.ADDR_REL, 2, 2);\n\t\n\t    // BCS:\n\t    this.setOp(this.INS_BCS, 0xB0, this.ADDR_REL, 2, 2);\n\t\n\t    // BEQ:\n\t    this.setOp(this.INS_BEQ, 0xF0, this.ADDR_REL, 2, 2);\n\t\n\t    // BIT:\n\t    this.setOp(this.INS_BIT, 0x24, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_BIT, 0x2C, this.ADDR_ABS, 3, 4);\n\t\n\t    // BMI:\n\t    this.setOp(this.INS_BMI, 0x30, this.ADDR_REL, 2, 2);\n\t\n\t    // BNE:\n\t    this.setOp(this.INS_BNE, 0xD0, this.ADDR_REL, 2, 2);\n\t\n\t    // BPL:\n\t    this.setOp(this.INS_BPL, 0x10, this.ADDR_REL, 2, 2);\n\t\n\t    // BRK:\n\t    this.setOp(this.INS_BRK, 0x00, this.ADDR_IMP, 1, 7);\n\t\n\t    // BVC:\n\t    this.setOp(this.INS_BVC, 0x50, this.ADDR_REL, 2, 2);\n\t\n\t    // BVS:\n\t    this.setOp(this.INS_BVS, 0x70, this.ADDR_REL, 2, 2);\n\t\n\t    // CLC:\n\t    this.setOp(this.INS_CLC, 0x18, this.ADDR_IMP, 1, 2);\n\t\n\t    // CLD:\n\t    this.setOp(this.INS_CLD, 0xD8, this.ADDR_IMP, 1, 2);\n\t\n\t    // CLI:\n\t    this.setOp(this.INS_CLI, 0x58, this.ADDR_IMP, 1, 2);\n\t\n\t    // CLV:\n\t    this.setOp(this.INS_CLV, 0xB8, this.ADDR_IMP, 1, 2);\n\t\n\t    // CMP:\n\t    this.setOp(this.INS_CMP, 0xC9, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_CMP, 0xC5, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_CMP, 0xD5, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_CMP, 0xCD, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_CMP, 0xDD, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_CMP, 0xD9, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_CMP, 0xC1, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_CMP, 0xD1, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // CPX:\n\t    this.setOp(this.INS_CPX, 0xE0, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_CPX, 0xE4, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_CPX, 0xEC, this.ADDR_ABS, 3, 4);\n\t\n\t    // CPY:\n\t    this.setOp(this.INS_CPY, 0xC0, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_CPY, 0xC4, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_CPY, 0xCC, this.ADDR_ABS, 3, 4);\n\t\n\t    // DEC:\n\t    this.setOp(this.INS_DEC, 0xC6, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_DEC, 0xD6, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_DEC, 0xCE, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_DEC, 0xDE, this.ADDR_ABSX, 3, 7);\n\t\n\t    // DEX:\n\t    this.setOp(this.INS_DEX, 0xCA, this.ADDR_IMP, 1, 2);\n\t\n\t    // DEY:\n\t    this.setOp(this.INS_DEY, 0x88, this.ADDR_IMP, 1, 2);\n\t\n\t    // EOR:\n\t    this.setOp(this.INS_EOR, 0x49, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_EOR, 0x45, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_EOR, 0x55, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_EOR, 0x4D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_EOR, 0x5D, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_EOR, 0x59, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_EOR, 0x41, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_EOR, 0x51, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // INC:\n\t    this.setOp(this.INS_INC, 0xE6, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_INC, 0xF6, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_INC, 0xEE, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_INC, 0xFE, this.ADDR_ABSX, 3, 7);\n\t\n\t    // INX:\n\t    this.setOp(this.INS_INX, 0xE8, this.ADDR_IMP, 1, 2);\n\t\n\t    // INY:\n\t    this.setOp(this.INS_INY, 0xC8, this.ADDR_IMP, 1, 2);\n\t\n\t    // JMP:\n\t    this.setOp(this.INS_JMP, 0x4C, this.ADDR_ABS, 3, 3);\n\t    this.setOp(this.INS_JMP, 0x6C, this.ADDR_INDABS, 3, 5);\n\t\n\t    // JSR:\n\t    this.setOp(this.INS_JSR, 0x20, this.ADDR_ABS, 3, 6);\n\t\n\t    // LDA:\n\t    this.setOp(this.INS_LDA, 0xA9, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_LDA, 0xA5, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_LDA, 0xB5, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_LDA, 0xAD, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_LDA, 0xBD, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_LDA, 0xB9, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_LDA, 0xA1, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_LDA, 0xB1, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // LDX:\n\t    this.setOp(this.INS_LDX, 0xA2, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_LDX, 0xA6, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_LDX, 0xB6, this.ADDR_ZPY, 2, 4);\n\t    this.setOp(this.INS_LDX, 0xAE, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_LDX, 0xBE, this.ADDR_ABSY, 3, 4);\n\t\n\t    // LDY:\n\t    this.setOp(this.INS_LDY, 0xA0, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_LDY, 0xA4, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_LDY, 0xB4, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_LDY, 0xAC, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_LDY, 0xBC, this.ADDR_ABSX, 3, 4);\n\t\n\t    // LSR:\n\t    this.setOp(this.INS_LSR, 0x4A, this.ADDR_ACC, 1, 2);\n\t    this.setOp(this.INS_LSR, 0x46, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_LSR, 0x56, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_LSR, 0x4E, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_LSR, 0x5E, this.ADDR_ABSX, 3, 7);\n\t\n\t    // NOP:\n\t    this.setOp(this.INS_NOP, 0xEA, this.ADDR_IMP, 1, 2);\n\t\n\t    // ORA:\n\t    this.setOp(this.INS_ORA, 0x09, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_ORA, 0x05, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_ORA, 0x15, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_ORA, 0x0D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_ORA, 0x1D, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_ORA, 0x19, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_ORA, 0x01, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_ORA, 0x11, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // PHA:\n\t    this.setOp(this.INS_PHA, 0x48, this.ADDR_IMP, 1, 3);\n\t\n\t    // PHP:\n\t    this.setOp(this.INS_PHP, 0x08, this.ADDR_IMP, 1, 3);\n\t\n\t    // PLA:\n\t    this.setOp(this.INS_PLA, 0x68, this.ADDR_IMP, 1, 4);\n\t\n\t    // PLP:\n\t    this.setOp(this.INS_PLP, 0x28, this.ADDR_IMP, 1, 4);\n\t\n\t    // ROL:\n\t    this.setOp(this.INS_ROL, 0x2A, this.ADDR_ACC, 1, 2);\n\t    this.setOp(this.INS_ROL, 0x26, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_ROL, 0x36, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_ROL, 0x2E, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_ROL, 0x3E, this.ADDR_ABSX, 3, 7);\n\t\n\t    // ROR:\n\t    this.setOp(this.INS_ROR, 0x6A, this.ADDR_ACC, 1, 2);\n\t    this.setOp(this.INS_ROR, 0x66, this.ADDR_ZP, 2, 5);\n\t    this.setOp(this.INS_ROR, 0x76, this.ADDR_ZPX, 2, 6);\n\t    this.setOp(this.INS_ROR, 0x6E, this.ADDR_ABS, 3, 6);\n\t    this.setOp(this.INS_ROR, 0x7E, this.ADDR_ABSX, 3, 7);\n\t\n\t    // RTI:\n\t    this.setOp(this.INS_RTI, 0x40, this.ADDR_IMP, 1, 6);\n\t\n\t    // RTS:\n\t    this.setOp(this.INS_RTS, 0x60, this.ADDR_IMP, 1, 6);\n\t\n\t    // SBC:\n\t    this.setOp(this.INS_SBC, 0xE9, this.ADDR_IMM, 2, 2);\n\t    this.setOp(this.INS_SBC, 0xE5, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_SBC, 0xF5, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_SBC, 0xED, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_SBC, 0xFD, this.ADDR_ABSX, 3, 4);\n\t    this.setOp(this.INS_SBC, 0xF9, this.ADDR_ABSY, 3, 4);\n\t    this.setOp(this.INS_SBC, 0xE1, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_SBC, 0xF1, this.ADDR_POSTIDXIND, 2, 5);\n\t\n\t    // SEC:\n\t    this.setOp(this.INS_SEC, 0x38, this.ADDR_IMP, 1, 2);\n\t\n\t    // SED:\n\t    this.setOp(this.INS_SED, 0xF8, this.ADDR_IMP, 1, 2);\n\t\n\t    // SEI:\n\t    this.setOp(this.INS_SEI, 0x78, this.ADDR_IMP, 1, 2);\n\t\n\t    // STA:\n\t    this.setOp(this.INS_STA, 0x85, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_STA, 0x95, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_STA, 0x8D, this.ADDR_ABS, 3, 4);\n\t    this.setOp(this.INS_STA, 0x9D, this.ADDR_ABSX, 3, 5);\n\t    this.setOp(this.INS_STA, 0x99, this.ADDR_ABSY, 3, 5);\n\t    this.setOp(this.INS_STA, 0x81, this.ADDR_PREIDXIND, 2, 6);\n\t    this.setOp(this.INS_STA, 0x91, this.ADDR_POSTIDXIND, 2, 6);\n\t\n\t    // STX:\n\t    this.setOp(this.INS_STX, 0x86, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_STX, 0x96, this.ADDR_ZPY, 2, 4);\n\t    this.setOp(this.INS_STX, 0x8E, this.ADDR_ABS, 3, 4);\n\t\n\t    // STY:\n\t    this.setOp(this.INS_STY, 0x84, this.ADDR_ZP, 2, 3);\n\t    this.setOp(this.INS_STY, 0x94, this.ADDR_ZPX, 2, 4);\n\t    this.setOp(this.INS_STY, 0x8C, this.ADDR_ABS, 3, 4);\n\t\n\t    // TAX:\n\t    this.setOp(this.INS_TAX, 0xAA, this.ADDR_IMP, 1, 2);\n\t\n\t    // TAY:\n\t    this.setOp(this.INS_TAY, 0xA8, this.ADDR_IMP, 1, 2);\n\t\n\t    // TSX:\n\t    this.setOp(this.INS_TSX, 0xBA, this.ADDR_IMP, 1, 2);\n\t\n\t    // TXA:\n\t    this.setOp(this.INS_TXA, 0x8A, this.ADDR_IMP, 1, 2);\n\t\n\t    // TXS:\n\t    this.setOp(this.INS_TXS, 0x9A, this.ADDR_IMP, 1, 2);\n\t\n\t    // TYA:\n\t    this.setOp(this.INS_TYA, 0x98, this.ADDR_IMP, 1, 2);\n\t\n\t    this.cycTable = new Array(\n\t    /*0x00*/7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6,\n\t    /*0x10*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0x20*/6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6,\n\t    /*0x30*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0x40*/6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6,\n\t    /*0x50*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0x60*/6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6,\n\t    /*0x70*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0x80*/2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,\n\t    /*0x90*/2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5,\n\t    /*0xA0*/2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,\n\t    /*0xB0*/2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4,\n\t    /*0xC0*/2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,\n\t    /*0xD0*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,\n\t    /*0xE0*/2, 6, 3, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,\n\t    /*0xF0*/2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7);\n\t\n\t    this.instname = new Array(56);\n\t\n\t    // Instruction Names:\n\t    this.instname[0] = \"ADC\";\n\t    this.instname[1] = \"AND\";\n\t    this.instname[2] = \"ASL\";\n\t    this.instname[3] = \"BCC\";\n\t    this.instname[4] = \"BCS\";\n\t    this.instname[5] = \"BEQ\";\n\t    this.instname[6] = \"BIT\";\n\t    this.instname[7] = \"BMI\";\n\t    this.instname[8] = \"BNE\";\n\t    this.instname[9] = \"BPL\";\n\t    this.instname[10] = \"BRK\";\n\t    this.instname[11] = \"BVC\";\n\t    this.instname[12] = \"BVS\";\n\t    this.instname[13] = \"CLC\";\n\t    this.instname[14] = \"CLD\";\n\t    this.instname[15] = \"CLI\";\n\t    this.instname[16] = \"CLV\";\n\t    this.instname[17] = \"CMP\";\n\t    this.instname[18] = \"CPX\";\n\t    this.instname[19] = \"CPY\";\n\t    this.instname[20] = \"DEC\";\n\t    this.instname[21] = \"DEX\";\n\t    this.instname[22] = \"DEY\";\n\t    this.instname[23] = \"EOR\";\n\t    this.instname[24] = \"INC\";\n\t    this.instname[25] = \"INX\";\n\t    this.instname[26] = \"INY\";\n\t    this.instname[27] = \"JMP\";\n\t    this.instname[28] = \"JSR\";\n\t    this.instname[29] = \"LDA\";\n\t    this.instname[30] = \"LDX\";\n\t    this.instname[31] = \"LDY\";\n\t    this.instname[32] = \"LSR\";\n\t    this.instname[33] = \"NOP\";\n\t    this.instname[34] = \"ORA\";\n\t    this.instname[35] = \"PHA\";\n\t    this.instname[36] = \"PHP\";\n\t    this.instname[37] = \"PLA\";\n\t    this.instname[38] = \"PLP\";\n\t    this.instname[39] = \"ROL\";\n\t    this.instname[40] = \"ROR\";\n\t    this.instname[41] = \"RTI\";\n\t    this.instname[42] = \"RTS\";\n\t    this.instname[43] = \"SBC\";\n\t    this.instname[44] = \"SEC\";\n\t    this.instname[45] = \"SED\";\n\t    this.instname[46] = \"SEI\";\n\t    this.instname[47] = \"STA\";\n\t    this.instname[48] = \"STX\";\n\t    this.instname[49] = \"STY\";\n\t    this.instname[50] = \"TAX\";\n\t    this.instname[51] = \"TAY\";\n\t    this.instname[52] = \"TSX\";\n\t    this.instname[53] = \"TXA\";\n\t    this.instname[54] = \"TXS\";\n\t    this.instname[55] = \"TYA\";\n\t\n\t    this.addrDesc = new Array(\"Zero Page           \", \"Relative            \", \"Implied             \", \"Absolute            \", \"Accumulator         \", \"Immediate           \", \"Zero Page,X         \", \"Zero Page,Y         \", \"Absolute,X          \", \"Absolute,Y          \", \"Preindexed Indirect \", \"Postindexed Indirect\", \"Indirect Absolute   \");\n\t};\n\t\n\tCPU.OpData.prototype = {\n\t    INS_ADC: 0,\n\t    INS_AND: 1,\n\t    INS_ASL: 2,\n\t\n\t    INS_BCC: 3,\n\t    INS_BCS: 4,\n\t    INS_BEQ: 5,\n\t    INS_BIT: 6,\n\t    INS_BMI: 7,\n\t    INS_BNE: 8,\n\t    INS_BPL: 9,\n\t    INS_BRK: 10,\n\t    INS_BVC: 11,\n\t    INS_BVS: 12,\n\t\n\t    INS_CLC: 13,\n\t    INS_CLD: 14,\n\t    INS_CLI: 15,\n\t    INS_CLV: 16,\n\t    INS_CMP: 17,\n\t    INS_CPX: 18,\n\t    INS_CPY: 19,\n\t\n\t    INS_DEC: 20,\n\t    INS_DEX: 21,\n\t    INS_DEY: 22,\n\t\n\t    INS_EOR: 23,\n\t\n\t    INS_INC: 24,\n\t    INS_INX: 25,\n\t    INS_INY: 26,\n\t\n\t    INS_JMP: 27,\n\t    INS_JSR: 28,\n\t\n\t    INS_LDA: 29,\n\t    INS_LDX: 30,\n\t    INS_LDY: 31,\n\t    INS_LSR: 32,\n\t\n\t    INS_NOP: 33,\n\t\n\t    INS_ORA: 34,\n\t\n\t    INS_PHA: 35,\n\t    INS_PHP: 36,\n\t    INS_PLA: 37,\n\t    INS_PLP: 38,\n\t\n\t    INS_ROL: 39,\n\t    INS_ROR: 40,\n\t    INS_RTI: 41,\n\t    INS_RTS: 42,\n\t\n\t    INS_SBC: 43,\n\t    INS_SEC: 44,\n\t    INS_SED: 45,\n\t    INS_SEI: 46,\n\t    INS_STA: 47,\n\t    INS_STX: 48,\n\t    INS_STY: 49,\n\t\n\t    INS_TAX: 50,\n\t    INS_TAY: 51,\n\t    INS_TSX: 52,\n\t    INS_TXA: 53,\n\t    INS_TXS: 54,\n\t    INS_TYA: 55,\n\t\n\t    INS_DUMMY: 56, // dummy instruction used for 'halting' the processor some cycles\n\t\n\t    // -------------------------------- //\n\t\n\t    // Addressing modes:\n\t    ADDR_ZP: 0,\n\t    ADDR_REL: 1,\n\t    ADDR_IMP: 2,\n\t    ADDR_ABS: 3,\n\t    ADDR_ACC: 4,\n\t    ADDR_IMM: 5,\n\t    ADDR_ZPX: 6,\n\t    ADDR_ZPY: 7,\n\t    ADDR_ABSX: 8,\n\t    ADDR_ABSY: 9,\n\t    ADDR_PREIDXIND: 10,\n\t    ADDR_POSTIDXIND: 11,\n\t    ADDR_INDABS: 12,\n\t\n\t    setOp: function setOp(inst, op, addr, size, cycles) {\n\t        this.opdata[op] = inst & 0xFF | (addr & 0xFF) << 8 | (size & 0xFF) << 16 | (cycles & 0xFF) << 24;\n\t    }\n\t};\n\t\n\texports.default = CPU;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar utils = {\n\t    copyArrayElements: function copyArrayElements(src, srcPos, dest, destPos, length) {\n\t        for (var i = 0; i < length; ++i) {\n\t            dest[destPos + i] = src[srcPos + i];\n\t        }\n\t    },\n\t\n\t    copyArray: function copyArray(src) {\n\t        var dest = new Array(src.length);\n\t        for (var i = 0; i < src.length; i++) {\n\t            dest[i] = src[i];\n\t        }\n\t        return dest;\n\t    },\n\t\n\t    fromJSON: function fromJSON(obj, state) {\n\t        for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n\t            obj[obj.JSON_PROPERTIES[i]] = state[obj.JSON_PROPERTIES[i]];\n\t        }\n\t    },\n\t\n\t    toJSON: function toJSON(obj) {\n\t        var state = {};\n\t        for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n\t            state[obj.JSON_PROPERTIES[i]] = obj[obj.JSON_PROPERTIES[i]];\n\t        }\n\t        return state;\n\t    },\n\t\n\t    isIE: function isIE() {\n\t        return (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)\n\t        );\n\t    }\n\t};\n\t\n\texports.default = utils;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar PPU = function PPU(nes) {\n\t    this.nes = nes;\n\t\n\t    // Keep Chrome happy\n\t    this.vramMem = null;\n\t    this.spriteMem = null;\n\t    this.vramAddress = null;\n\t    this.vramTmpAddress = null;\n\t    this.vramBufferedReadValue = null;\n\t    this.firstWrite = null;\n\t    this.sramAddress = null;\n\t    this.currentMirroring = null;\n\t    this.requestEndFrame = null;\n\t    this.nmiOk = null;\n\t    this.dummyCycleToggle = null;\n\t    this.validTileData = null;\n\t    this.nmiCounter = null;\n\t    this.scanlineAlreadyRendered = null;\n\t    this.f_nmiOnVblank = null;\n\t    this.f_spriteSize = null;\n\t    this.f_bgPatternTable = null;\n\t    this.f_spPatternTable = null;\n\t    this.f_addrInc = null;\n\t    this.f_nTblAddress = null;\n\t    this.f_color = null;\n\t    this.f_spVisibility = null;\n\t    this.f_bgVisibility = null;\n\t    this.f_spClipping = null;\n\t    this.f_bgClipping = null;\n\t    this.f_dispType = null;\n\t    this.cntFV = null;\n\t    this.cntV = null;\n\t    this.cntH = null;\n\t    this.cntVT = null;\n\t    this.cntHT = null;\n\t    this.regFV = null;\n\t    this.regV = null;\n\t    this.regH = null;\n\t    this.regVT = null;\n\t    this.regHT = null;\n\t    this.regFH = null;\n\t    this.regS = null;\n\t    this.curNt = null;\n\t    this.attrib = null;\n\t    this.buffer = null;\n\t    this.prevBuffer = null;\n\t    this.bgbuffer = null;\n\t    this.pixrendered = null;\n\t\n\t    this.validTileData = null;\n\t    this.scantile = null;\n\t    this.scanline = null;\n\t    this.lastRenderedScanline = null;\n\t    this.curX = null;\n\t    this.sprX = null;\n\t    this.sprY = null;\n\t    this.sprTile = null;\n\t    this.sprCol = null;\n\t    this.vertFlip = null;\n\t    this.horiFlip = null;\n\t    this.bgPriority = null;\n\t    this.spr0HitX = null;\n\t    this.spr0HitY = null;\n\t    this.hitSpr0 = null;\n\t    this.sprPalette = null;\n\t    this.imgPalette = null;\n\t    this.ptTile = null;\n\t    this.ntable1 = null;\n\t    this.currentMirroring = null;\n\t    this.nameTable = null;\n\t    this.vramMirrorTable = null;\n\t    this.palTable = null;\n\t\n\t    // Rendering Options:\n\t    this.showSpr0Hit = false;\n\t    this.clipToTvSize = true;\n\t\n\t    this.reset();\n\t}; /*\n\t   JSNES, based on Jamie Sanders' vNES\n\t   Copyright (C) 2010 Ben Firshman\n\t   \n\t   This program is free software: you can redistribute it and/or modify\n\t   it under the terms of the GNU General Public License as published by\n\t   the Free Software Foundation, either version 3 of the License, or\n\t   (at your option) any later version.\n\t   \n\t   This program is distributed in the hope that it will be useful,\n\t   but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t   GNU General Public License for more details.\n\t   \n\t   You should have received a copy of the GNU General Public License\n\t   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t   */\n\t\n\tPPU.prototype = {\n\t    // Status flags:\n\t    STATUS_VRAMWRITE: 4,\n\t    STATUS_SLSPRITECOUNT: 5,\n\t    STATUS_SPRITE0HIT: 6,\n\t    STATUS_VBLANK: 7,\n\t\n\t    reset: function reset() {\n\t        var i;\n\t\n\t        // Memory\n\t        this.vramMem = new Array(0x8000);\n\t        this.spriteMem = new Array(0x100);\n\t        for (i = 0; i < this.vramMem.length; i++) {\n\t            this.vramMem[i] = 0;\n\t        }\n\t        for (i = 0; i < this.spriteMem.length; i++) {\n\t            this.spriteMem[i] = 0;\n\t        }\n\t\n\t        // VRAM I/O:\n\t        this.vramAddress = null;\n\t        this.vramTmpAddress = null;\n\t        this.vramBufferedReadValue = 0;\n\t        this.firstWrite = true; // VRAM/Scroll Hi/Lo latch\n\t\n\t        // SPR-RAM I/O:\n\t        this.sramAddress = 0; // 8-bit only.\n\t\n\t        this.currentMirroring = -1;\n\t        this.requestEndFrame = false;\n\t        this.nmiOk = false;\n\t        this.dummyCycleToggle = false;\n\t        this.validTileData = false;\n\t        this.nmiCounter = 0;\n\t        this.scanlineAlreadyRendered = null;\n\t\n\t        // Control Flags Register 1:\n\t        this.f_nmiOnVblank = 0; // NMI on VBlank. 0=disable, 1=enable\n\t        this.f_spriteSize = 0; // Sprite size. 0=8x8, 1=8x16\n\t        this.f_bgPatternTable = 0; // Background Pattern Table address. 0=0x0000,1=0x1000\n\t        this.f_spPatternTable = 0; // Sprite Pattern Table address. 0=0x0000,1=0x1000\n\t        this.f_addrInc = 0; // PPU Address Increment. 0=1,1=32\n\t        this.f_nTblAddress = 0; // Name Table Address. 0=0x2000,1=0x2400,2=0x2800,3=0x2C00\n\t\n\t        // Control Flags Register 2:\n\t        this.f_color = 0; // Background color. 0=black, 1=blue, 2=green, 4=red\n\t        this.f_spVisibility = 0; // Sprite visibility. 0=not displayed,1=displayed\n\t        this.f_bgVisibility = 0; // Background visibility. 0=Not Displayed,1=displayed\n\t        this.f_spClipping = 0; // Sprite clipping. 0=Sprites invisible in left 8-pixel column,1=No clipping\n\t        this.f_bgClipping = 0; // Background clipping. 0=BG invisible in left 8-pixel column, 1=No clipping\n\t        this.f_dispType = 0; // Display type. 0=color, 1=monochrome\n\t\n\t        // Counters:\n\t        this.cntFV = 0;\n\t        this.cntV = 0;\n\t        this.cntH = 0;\n\t        this.cntVT = 0;\n\t        this.cntHT = 0;\n\t\n\t        // Registers:\n\t        this.regFV = 0;\n\t        this.regV = 0;\n\t        this.regH = 0;\n\t        this.regVT = 0;\n\t        this.regHT = 0;\n\t        this.regFH = 0;\n\t        this.regS = 0;\n\t\n\t        // These are temporary variables used in rendering and sound procedures.\n\t        // Their states outside of those procedures can be ignored.\n\t        // TODO: the use of this is a bit weird, investigate\n\t        this.curNt = null;\n\t\n\t        // Variables used when rendering:\n\t        this.attrib = new Array(32);\n\t        this.buffer = new Array(256 * 240);\n\t        this.prevBuffer = new Array(256 * 240);\n\t        this.bgbuffer = new Array(256 * 240);\n\t        this.pixrendered = new Array(256 * 240);\n\t\n\t        this.validTileData = null;\n\t\n\t        this.scantile = new Array(32);\n\t\n\t        // Initialize misc vars:\n\t        this.scanline = 0;\n\t        this.lastRenderedScanline = -1;\n\t        this.curX = 0;\n\t\n\t        // Sprite data:\n\t        this.sprX = new Array(64); // X coordinate\n\t        this.sprY = new Array(64); // Y coordinate\n\t        this.sprTile = new Array(64); // Tile Index (into pattern table)\n\t        this.sprCol = new Array(64); // Upper two bits of color\n\t        this.vertFlip = new Array(64); // Vertical Flip\n\t        this.horiFlip = new Array(64); // Horizontal Flip\n\t        this.bgPriority = new Array(64); // Background priority\n\t        this.spr0HitX = 0; // Sprite #0 hit X coordinate\n\t        this.spr0HitY = 0; // Sprite #0 hit Y coordinate\n\t        this.hitSpr0 = false;\n\t\n\t        // Palette data:\n\t        this.sprPalette = new Array(16);\n\t        this.imgPalette = new Array(16);\n\t\n\t        // Create pattern table tile buffers:\n\t        this.ptTile = new Array(512);\n\t        for (i = 0; i < 512; i++) {\n\t            this.ptTile[i] = new PPU.Tile();\n\t        }\n\t\n\t        // Create nametable buffers:\n\t        // Name table data:\n\t        this.ntable1 = new Array(4);\n\t        this.currentMirroring = -1;\n\t        this.nameTable = new Array(4);\n\t        for (i = 0; i < 4; i++) {\n\t            this.nameTable[i] = new PPU.NameTable(32, 32, \"Nt\" + i);\n\t        }\n\t\n\t        // Initialize mirroring lookup table:\n\t        this.vramMirrorTable = new Array(0x8000);\n\t        for (i = 0; i < 0x8000; i++) {\n\t            this.vramMirrorTable[i] = i;\n\t        }\n\t\n\t        this.palTable = new PPU.PaletteTable();\n\t        this.palTable.loadNTSCPalette();\n\t        //this.palTable.loadDefaultPalette();\n\t\n\t        this.updateControlReg1(0);\n\t        this.updateControlReg2(0);\n\t    },\n\t\n\t    // Sets Nametable mirroring.\n\t    setMirroring: function setMirroring(mirroring) {\n\t\n\t        if (mirroring == this.currentMirroring) {\n\t            return;\n\t        }\n\t\n\t        this.currentMirroring = mirroring;\n\t        this.triggerRendering();\n\t\n\t        // Remove mirroring:\n\t        if (this.vramMirrorTable === null) {\n\t            this.vramMirrorTable = new Array(0x8000);\n\t        }\n\t        for (var i = 0; i < 0x8000; i++) {\n\t            this.vramMirrorTable[i] = i;\n\t        }\n\t\n\t        // Palette mirroring:\n\t        this.defineMirrorRegion(0x3f20, 0x3f00, 0x20);\n\t        this.defineMirrorRegion(0x3f40, 0x3f00, 0x20);\n\t        this.defineMirrorRegion(0x3f80, 0x3f00, 0x20);\n\t        this.defineMirrorRegion(0x3fc0, 0x3f00, 0x20);\n\t\n\t        // Additional mirroring:\n\t        this.defineMirrorRegion(0x3000, 0x2000, 0xf00);\n\t        this.defineMirrorRegion(0x4000, 0x0000, 0x4000);\n\t\n\t        if (mirroring == this.nes.rom.HORIZONTAL_MIRRORING) {\n\t            // Horizontal mirroring.\n\t\n\t            this.ntable1[0] = 0;\n\t            this.ntable1[1] = 0;\n\t            this.ntable1[2] = 1;\n\t            this.ntable1[3] = 1;\n\t\n\t            this.defineMirrorRegion(0x2400, 0x2000, 0x400);\n\t            this.defineMirrorRegion(0x2c00, 0x2800, 0x400);\n\t        } else if (mirroring == this.nes.rom.VERTICAL_MIRRORING) {\n\t            // Vertical mirroring.\n\t\n\t            this.ntable1[0] = 0;\n\t            this.ntable1[1] = 1;\n\t            this.ntable1[2] = 0;\n\t            this.ntable1[3] = 1;\n\t\n\t            this.defineMirrorRegion(0x2800, 0x2000, 0x400);\n\t            this.defineMirrorRegion(0x2c00, 0x2400, 0x400);\n\t        } else if (mirroring == this.nes.rom.SINGLESCREEN_MIRRORING) {\n\t\n\t            // Single Screen mirroring\n\t\n\t            this.ntable1[0] = 0;\n\t            this.ntable1[1] = 0;\n\t            this.ntable1[2] = 0;\n\t            this.ntable1[3] = 0;\n\t\n\t            this.defineMirrorRegion(0x2400, 0x2000, 0x400);\n\t            this.defineMirrorRegion(0x2800, 0x2000, 0x400);\n\t            this.defineMirrorRegion(0x2c00, 0x2000, 0x400);\n\t        } else if (mirroring == this.nes.rom.SINGLESCREEN_MIRRORING2) {\n\t\n\t            this.ntable1[0] = 1;\n\t            this.ntable1[1] = 1;\n\t            this.ntable1[2] = 1;\n\t            this.ntable1[3] = 1;\n\t\n\t            this.defineMirrorRegion(0x2400, 0x2400, 0x400);\n\t            this.defineMirrorRegion(0x2800, 0x2400, 0x400);\n\t            this.defineMirrorRegion(0x2c00, 0x2400, 0x400);\n\t        } else {\n\t\n\t            // Assume Four-screen mirroring.\n\t\n\t            this.ntable1[0] = 0;\n\t            this.ntable1[1] = 1;\n\t            this.ntable1[2] = 2;\n\t            this.ntable1[3] = 3;\n\t        }\n\t    },\n\t\n\t    // Define a mirrored area in the address lookup table.\n\t    // Assumes the regions don't overlap.\n\t    // The 'to' region is the region that is physically in memory.\n\t    defineMirrorRegion: function defineMirrorRegion(fromStart, toStart, size) {\n\t        for (var i = 0; i < size; i++) {\n\t            this.vramMirrorTable[fromStart + i] = toStart + i;\n\t        }\n\t    },\n\t\n\t    startVBlank: function startVBlank() {\n\t\n\t        // Do NMI:\n\t        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n\t\n\t        // Make sure everything is rendered:\n\t        if (this.lastRenderedScanline < 239) {\n\t            this.renderFramePartially(this.lastRenderedScanline + 1, 240 - this.lastRenderedScanline);\n\t        }\n\t\n\t        // End frame:\n\t        this.endFrame();\n\t\n\t        // Reset scanline counter:\n\t        this.lastRenderedScanline = -1;\n\t    },\n\t\n\t    endScanline: function endScanline() {\n\t        switch (this.scanline) {\n\t            case 19:\n\t                // Dummy scanline.\n\t                // May be variable length:\n\t                if (this.dummyCycleToggle) {\n\t\n\t                    // Remove dead cycle at end of scanline,\n\t                    // for next scanline:\n\t                    this.curX = 1;\n\t                    this.dummyCycleToggle = !this.dummyCycleToggle;\n\t                }\n\t                break;\n\t\n\t            case 20:\n\t                // Clear VBlank flag:\n\t                this.setStatusFlag(this.STATUS_VBLANK, false);\n\t\n\t                // Clear Sprite #0 hit flag:\n\t                this.setStatusFlag(this.STATUS_SPRITE0HIT, false);\n\t                this.hitSpr0 = false;\n\t                this.spr0HitX = -1;\n\t                this.spr0HitY = -1;\n\t\n\t                if (this.f_bgVisibility == 1 || this.f_spVisibility == 1) {\n\t\n\t                    // Update counters:\n\t                    this.cntFV = this.regFV;\n\t                    this.cntV = this.regV;\n\t                    this.cntH = this.regH;\n\t                    this.cntVT = this.regVT;\n\t                    this.cntHT = this.regHT;\n\t\n\t                    if (this.f_bgVisibility == 1) {\n\t                        // Render dummy scanline:\n\t                        this.renderBgScanline(false, 0);\n\t                    }\n\t                }\n\t\n\t                if (this.f_bgVisibility == 1 && this.f_spVisibility == 1) {\n\t\n\t                    // Check sprite 0 hit for first scanline:\n\t                    this.checkSprite0(0);\n\t                }\n\t\n\t                if (this.f_bgVisibility == 1 || this.f_spVisibility == 1) {\n\t                    // Clock mapper IRQ Counter:\n\t                    this.nes.mmap.clockIrqCounter();\n\t                }\n\t                break;\n\t\n\t            case 261:\n\t                // Dead scanline, no rendering.\n\t                // Set VINT:\n\t                this.setStatusFlag(this.STATUS_VBLANK, true);\n\t                this.requestEndFrame = true;\n\t                this.nmiCounter = 9;\n\t\n\t                // Wrap around:\n\t                this.scanline = -1; // will be incremented to 0\n\t\n\t                break;\n\t\n\t            default:\n\t                if (this.scanline >= 21 && this.scanline <= 260) {\n\t\n\t                    // Render normally:\n\t                    if (this.f_bgVisibility == 1) {\n\t\n\t                        if (!this.scanlineAlreadyRendered) {\n\t                            // update scroll:\n\t                            this.cntHT = this.regHT;\n\t                            this.cntH = this.regH;\n\t                            this.renderBgScanline(true, this.scanline + 1 - 21);\n\t                        }\n\t                        this.scanlineAlreadyRendered = false;\n\t\n\t                        // Check for sprite 0 (next scanline):\n\t                        if (!this.hitSpr0 && this.f_spVisibility == 1) {\n\t                            if (this.sprX[0] >= -7 && this.sprX[0] < 256 && this.sprY[0] + 1 <= this.scanline - 20 && this.sprY[0] + 1 + (this.f_spriteSize === 0 ? 8 : 16) >= this.scanline - 20) {\n\t                                if (this.checkSprite0(this.scanline - 20)) {\n\t                                    this.hitSpr0 = true;\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    if (this.f_bgVisibility == 1 || this.f_spVisibility == 1) {\n\t                        // Clock mapper IRQ Counter:\n\t                        this.nes.mmap.clockIrqCounter();\n\t                    }\n\t                }\n\t        }\n\t\n\t        this.scanline++;\n\t        this.regsToAddress();\n\t        this.cntsToAddress();\n\t    },\n\t\n\t    startFrame: function startFrame() {\n\t        // Set background color:\n\t        var bgColor = 0;\n\t\n\t        if (this.f_dispType === 0) {\n\t            // Color display.\n\t            // f_color determines color emphasis.\n\t            // Use first entry of image palette as BG color.\n\t            bgColor = this.imgPalette[0];\n\t        } else {\n\t            // Monochrome display.\n\t            // f_color determines the bg color.\n\t            switch (this.f_color) {\n\t                case 0:\n\t                    // Black\n\t                    bgColor = 0x00000;\n\t                    break;\n\t                case 1:\n\t                    // Green\n\t                    bgColor = 0x00FF00;\n\t                    break;\n\t                case 2:\n\t                    // Blue\n\t                    bgColor = 0xFF0000;\n\t                    break;\n\t                case 3:\n\t                    // Invalid. Use black.\n\t                    bgColor = 0x000000;\n\t                    break;\n\t                case 4:\n\t                    // Red\n\t                    bgColor = 0x0000FF;\n\t                    break;\n\t                default:\n\t                    // Invalid. Use black.\n\t                    bgColor = 0x0;\n\t            }\n\t        }\n\t\n\t        var buffer = this.buffer;\n\t        var i;\n\t        for (i = 0; i < 256 * 240; i++) {\n\t            buffer[i] = bgColor;\n\t        }\n\t        var pixrendered = this.pixrendered;\n\t        for (i = 0; i < pixrendered.length; i++) {\n\t            pixrendered[i] = 65;\n\t        }\n\t    },\n\t\n\t    endFrame: function endFrame() {\n\t        var i, x, y;\n\t        var buffer = this.buffer;\n\t\n\t        // Draw spr#0 hit coordinates:\n\t        if (this.showSpr0Hit) {\n\t            // Spr 0 position:\n\t            if (this.sprX[0] >= 0 && this.sprX[0] < 256 && this.sprY[0] >= 0 && this.sprY[0] < 240) {\n\t                for (i = 0; i < 256; i++) {\n\t                    buffer[(this.sprY[0] << 8) + i] = 0xFF5555;\n\t                }\n\t                for (i = 0; i < 240; i++) {\n\t                    buffer[(i << 8) + this.sprX[0]] = 0xFF5555;\n\t                }\n\t            }\n\t            // Hit position:\n\t            if (this.spr0HitX >= 0 && this.spr0HitX < 256 && this.spr0HitY >= 0 && this.spr0HitY < 240) {\n\t                for (i = 0; i < 256; i++) {\n\t                    buffer[(this.spr0HitY << 8) + i] = 0x55FF55;\n\t                }\n\t                for (i = 0; i < 240; i++) {\n\t                    buffer[(i << 8) + this.spr0HitX] = 0x55FF55;\n\t                }\n\t            }\n\t        }\n\t\n\t        // This is a bit lazy..\n\t        // if either the sprites or the background should be clipped,\n\t        // both are clipped after rendering is finished.\n\t        if (this.clipToTvSize || this.f_bgClipping === 0 || this.f_spClipping === 0) {\n\t            // Clip left 8-pixels column:\n\t            for (y = 0; y < 240; y++) {\n\t                for (x = 0; x < 8; x++) {\n\t                    buffer[(y << 8) + x] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (this.clipToTvSize) {\n\t            // Clip right 8-pixels column too:\n\t            for (y = 0; y < 240; y++) {\n\t                for (x = 0; x < 8; x++) {\n\t                    buffer[(y << 8) + 255 - x] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        // Clip top and bottom 8 pixels:\n\t        if (this.clipToTvSize) {\n\t            for (y = 0; y < 8; y++) {\n\t                for (x = 0; x < 256; x++) {\n\t                    buffer[(y << 8) + x] = 0;\n\t                    buffer[(239 - y << 8) + x] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (this.nes.opts.showDisplay) {\n\t            this.nes.ui.writeFrame(buffer, this.prevBuffer);\n\t        }\n\t    },\n\t\n\t    updateControlReg1: function updateControlReg1(value) {\n\t\n\t        this.triggerRendering();\n\t\n\t        this.f_nmiOnVblank = value >> 7 & 1;\n\t        this.f_spriteSize = value >> 5 & 1;\n\t        this.f_bgPatternTable = value >> 4 & 1;\n\t        this.f_spPatternTable = value >> 3 & 1;\n\t        this.f_addrInc = value >> 2 & 1;\n\t        this.f_nTblAddress = value & 3;\n\t\n\t        this.regV = value >> 1 & 1;\n\t        this.regH = value & 1;\n\t        this.regS = value >> 4 & 1;\n\t    },\n\t\n\t    updateControlReg2: function updateControlReg2(value) {\n\t\n\t        this.triggerRendering();\n\t\n\t        this.f_color = value >> 5 & 7;\n\t        this.f_spVisibility = value >> 4 & 1;\n\t        this.f_bgVisibility = value >> 3 & 1;\n\t        this.f_spClipping = value >> 2 & 1;\n\t        this.f_bgClipping = value >> 1 & 1;\n\t        this.f_dispType = value & 1;\n\t\n\t        if (this.f_dispType === 0) {\n\t            this.palTable.setEmphasis(this.f_color);\n\t        }\n\t        this.updatePalettes();\n\t    },\n\t\n\t    setStatusFlag: function setStatusFlag(flag, value) {\n\t        var n = 1 << flag;\n\t        this.nes.cpu.mem[0x2002] = this.nes.cpu.mem[0x2002] & 255 - n | (value ? n : 0);\n\t    },\n\t\n\t    // CPU Register $2002:\n\t    // Read the Status Register.\n\t    readStatusRegister: function readStatusRegister() {\n\t\n\t        var tmp = this.nes.cpu.mem[0x2002];\n\t\n\t        // Reset scroll & VRAM Address toggle:\n\t        this.firstWrite = true;\n\t\n\t        // Clear VBlank flag:\n\t        this.setStatusFlag(this.STATUS_VBLANK, false);\n\t\n\t        // Fetch status data:\n\t        return tmp;\n\t    },\n\t\n\t    // CPU Register $2003:\n\t    // Write the SPR-RAM address that is used for sramWrite (Register 0x2004 in CPU memory map)\n\t    writeSRAMAddress: function writeSRAMAddress(address) {\n\t        this.sramAddress = address;\n\t    },\n\t\n\t    // CPU Register $2004 (R):\n\t    // Read from SPR-RAM (Sprite RAM).\n\t    // The address should be set first.\n\t    sramLoad: function sramLoad() {\n\t        /*short tmp = sprMem.load(sramAddress);\n\t        sramAddress++; // Increment address\n\t        sramAddress%=0x100;\n\t        return tmp;*/\n\t        return this.spriteMem[this.sramAddress];\n\t    },\n\t\n\t    // CPU Register $2004 (W):\n\t    // Write to SPR-RAM (Sprite RAM).\n\t    // The address should be set first.\n\t    sramWrite: function sramWrite(value) {\n\t        this.spriteMem[this.sramAddress] = value;\n\t        this.spriteRamWriteUpdate(this.sramAddress, value);\n\t        this.sramAddress++; // Increment address\n\t        this.sramAddress %= 0x100;\n\t    },\n\t\n\t    // CPU Register $2005:\n\t    // Write to scroll registers.\n\t    // The first write is the vertical offset, the second is the\n\t    // horizontal offset:\n\t    scrollWrite: function scrollWrite(value) {\n\t        this.triggerRendering();\n\t\n\t        if (this.firstWrite) {\n\t            // First write, horizontal scroll:\n\t            this.regHT = value >> 3 & 31;\n\t            this.regFH = value & 7;\n\t        } else {\n\t\n\t            // Second write, vertical scroll:\n\t            this.regFV = value & 7;\n\t            this.regVT = value >> 3 & 31;\n\t        }\n\t        this.firstWrite = !this.firstWrite;\n\t    },\n\t\n\t    // CPU Register $2006:\n\t    // Sets the adress used when reading/writing from/to VRAM.\n\t    // The first write sets the high byte, the second the low byte.\n\t    writeVRAMAddress: function writeVRAMAddress(address) {\n\t\n\t        if (this.firstWrite) {\n\t\n\t            this.regFV = address >> 4 & 3;\n\t            this.regV = address >> 3 & 1;\n\t            this.regH = address >> 2 & 1;\n\t            this.regVT = this.regVT & 7 | (address & 3) << 3;\n\t        } else {\n\t            this.triggerRendering();\n\t\n\t            this.regVT = this.regVT & 24 | address >> 5 & 7;\n\t            this.regHT = address & 31;\n\t\n\t            this.cntFV = this.regFV;\n\t            this.cntV = this.regV;\n\t            this.cntH = this.regH;\n\t            this.cntVT = this.regVT;\n\t            this.cntHT = this.regHT;\n\t\n\t            this.checkSprite0(this.scanline - 20);\n\t        }\n\t\n\t        this.firstWrite = !this.firstWrite;\n\t\n\t        // Invoke mapper latch:\n\t        this.cntsToAddress();\n\t        if (this.vramAddress < 0x2000) {\n\t            this.nes.mmap.latchAccess(this.vramAddress);\n\t        }\n\t    },\n\t\n\t    // CPU Register $2007(R):\n\t    // Read from PPU memory. The address should be set first.\n\t    vramLoad: function vramLoad() {\n\t        var tmp;\n\t\n\t        this.cntsToAddress();\n\t        this.regsToAddress();\n\t\n\t        // If address is in range 0x0000-0x3EFF, return buffered values:\n\t        if (this.vramAddress <= 0x3EFF) {\n\t            tmp = this.vramBufferedReadValue;\n\t\n\t            // Update buffered value:\n\t            if (this.vramAddress < 0x2000) {\n\t                this.vramBufferedReadValue = this.vramMem[this.vramAddress];\n\t            } else {\n\t                this.vramBufferedReadValue = this.mirroredLoad(this.vramAddress);\n\t            }\n\t\n\t            // Mapper latch access:\n\t            if (this.vramAddress < 0x2000) {\n\t                this.nes.mmap.latchAccess(this.vramAddress);\n\t            }\n\t\n\t            // Increment by either 1 or 32, depending on d2 of Control Register 1:\n\t            this.vramAddress += this.f_addrInc == 1 ? 32 : 1;\n\t\n\t            this.cntsFromAddress();\n\t            this.regsFromAddress();\n\t\n\t            return tmp; // Return the previous buffered value.\n\t        }\n\t\n\t        // No buffering in this mem range. Read normally.\n\t        tmp = this.mirroredLoad(this.vramAddress);\n\t\n\t        // Increment by either 1 or 32, depending on d2 of Control Register 1:\n\t        this.vramAddress += this.f_addrInc == 1 ? 32 : 1;\n\t\n\t        this.cntsFromAddress();\n\t        this.regsFromAddress();\n\t\n\t        return tmp;\n\t    },\n\t\n\t    // CPU Register $2007(W):\n\t    // Write to PPU memory. The address should be set first.\n\t    vramWrite: function vramWrite(value) {\n\t\n\t        this.triggerRendering();\n\t        this.cntsToAddress();\n\t        this.regsToAddress();\n\t\n\t        if (this.vramAddress >= 0x2000) {\n\t            // Mirroring is used.\n\t            this.mirroredWrite(this.vramAddress, value);\n\t        } else {\n\t\n\t            // Write normally.\n\t            this.writeMem(this.vramAddress, value);\n\t\n\t            // Invoke mapper latch:\n\t            this.nes.mmap.latchAccess(this.vramAddress);\n\t        }\n\t\n\t        // Increment by either 1 or 32, depending on d2 of Control Register 1:\n\t        this.vramAddress += this.f_addrInc == 1 ? 32 : 1;\n\t        this.regsFromAddress();\n\t        this.cntsFromAddress();\n\t    },\n\t\n\t    // CPU Register $4014:\n\t    // Write 256 bytes of main memory\n\t    // into Sprite RAM.\n\t    sramDMA: function sramDMA(value) {\n\t        var baseAddress = value * 0x100;\n\t        var data;\n\t        for (var i = this.sramAddress; i < 256; i++) {\n\t            data = this.nes.cpu.mem[baseAddress + i];\n\t            this.spriteMem[i] = data;\n\t            this.spriteRamWriteUpdate(i, data);\n\t        }\n\t\n\t        this.nes.cpu.haltCycles(513);\n\t    },\n\t\n\t    // Updates the scroll registers from a new VRAM address.\n\t    regsFromAddress: function regsFromAddress() {\n\t\n\t        var address = this.vramTmpAddress >> 8 & 0xFF;\n\t        this.regFV = address >> 4 & 7;\n\t        this.regV = address >> 3 & 1;\n\t        this.regH = address >> 2 & 1;\n\t        this.regVT = this.regVT & 7 | (address & 3) << 3;\n\t\n\t        address = this.vramTmpAddress & 0xFF;\n\t        this.regVT = this.regVT & 24 | address >> 5 & 7;\n\t        this.regHT = address & 31;\n\t    },\n\t\n\t    // Updates the scroll registers from a new VRAM address.\n\t    cntsFromAddress: function cntsFromAddress() {\n\t\n\t        var address = this.vramAddress >> 8 & 0xFF;\n\t        this.cntFV = address >> 4 & 3;\n\t        this.cntV = address >> 3 & 1;\n\t        this.cntH = address >> 2 & 1;\n\t        this.cntVT = this.cntVT & 7 | (address & 3) << 3;\n\t\n\t        address = this.vramAddress & 0xFF;\n\t        this.cntVT = this.cntVT & 24 | address >> 5 & 7;\n\t        this.cntHT = address & 31;\n\t    },\n\t\n\t    regsToAddress: function regsToAddress() {\n\t        var b1 = (this.regFV & 7) << 4;\n\t        b1 |= (this.regV & 1) << 3;\n\t        b1 |= (this.regH & 1) << 2;\n\t        b1 |= this.regVT >> 3 & 3;\n\t\n\t        var b2 = (this.regVT & 7) << 5;\n\t        b2 |= this.regHT & 31;\n\t\n\t        this.vramTmpAddress = (b1 << 8 | b2) & 0x7FFF;\n\t    },\n\t\n\t    cntsToAddress: function cntsToAddress() {\n\t        var b1 = (this.cntFV & 7) << 4;\n\t        b1 |= (this.cntV & 1) << 3;\n\t        b1 |= (this.cntH & 1) << 2;\n\t        b1 |= this.cntVT >> 3 & 3;\n\t\n\t        var b2 = (this.cntVT & 7) << 5;\n\t        b2 |= this.cntHT & 31;\n\t\n\t        this.vramAddress = (b1 << 8 | b2) & 0x7FFF;\n\t    },\n\t\n\t    incTileCounter: function incTileCounter(count) {\n\t        for (var i = count; i !== 0; i--) {\n\t            this.cntHT++;\n\t            if (this.cntHT == 32) {\n\t                this.cntHT = 0;\n\t                this.cntVT++;\n\t                if (this.cntVT >= 30) {\n\t                    this.cntH++;\n\t                    if (this.cntH == 2) {\n\t                        this.cntH = 0;\n\t                        this.cntV++;\n\t                        if (this.cntV == 2) {\n\t                            this.cntV = 0;\n\t                            this.cntFV++;\n\t                            this.cntFV &= 0x7;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    // Reads from memory, taking into account\n\t    // mirroring/mapping of address ranges.\n\t    mirroredLoad: function mirroredLoad(address) {\n\t        return this.vramMem[this.vramMirrorTable[address]];\n\t    },\n\t\n\t    // Writes to memory, taking into account\n\t    // mirroring/mapping of address ranges.\n\t    mirroredWrite: function mirroredWrite(address, value) {\n\t        if (address >= 0x3f00 && address < 0x3f20) {\n\t            // Palette write mirroring.\n\t            if (address == 0x3F00 || address == 0x3F10) {\n\t                this.writeMem(0x3F00, value);\n\t                this.writeMem(0x3F10, value);\n\t            } else if (address == 0x3F04 || address == 0x3F14) {\n\t\n\t                this.writeMem(0x3F04, value);\n\t                this.writeMem(0x3F14, value);\n\t            } else if (address == 0x3F08 || address == 0x3F18) {\n\t\n\t                this.writeMem(0x3F08, value);\n\t                this.writeMem(0x3F18, value);\n\t            } else if (address == 0x3F0C || address == 0x3F1C) {\n\t\n\t                this.writeMem(0x3F0C, value);\n\t                this.writeMem(0x3F1C, value);\n\t            } else {\n\t                this.writeMem(address, value);\n\t            }\n\t        } else {\n\t\n\t            // Use lookup table for mirrored address:\n\t            if (address < this.vramMirrorTable.length) {\n\t                this.writeMem(this.vramMirrorTable[address], value);\n\t            } else {\n\t                // FIXME\n\t                alert(\"Invalid VRAM address: \" + address.toString(16));\n\t            }\n\t        }\n\t    },\n\t\n\t    triggerRendering: function triggerRendering() {\n\t        if (this.scanline >= 21 && this.scanline <= 260) {\n\t            // Render sprites, and combine:\n\t            this.renderFramePartially(this.lastRenderedScanline + 1, this.scanline - 21 - this.lastRenderedScanline);\n\t\n\t            // Set last rendered scanline:\n\t            this.lastRenderedScanline = this.scanline - 21;\n\t        }\n\t    },\n\t\n\t    renderFramePartially: function renderFramePartially(startScan, scanCount) {\n\t        if (this.f_spVisibility == 1) {\n\t            this.renderSpritesPartially(startScan, scanCount, true);\n\t        }\n\t\n\t        if (this.f_bgVisibility == 1) {\n\t            var si = startScan << 8;\n\t            var ei = startScan + scanCount << 8;\n\t            if (ei > 0xF000) {\n\t                ei = 0xF000;\n\t            }\n\t            var buffer = this.buffer;\n\t            var bgbuffer = this.bgbuffer;\n\t            var pixrendered = this.pixrendered;\n\t            for (var destIndex = si; destIndex < ei; destIndex++) {\n\t                if (pixrendered[destIndex] > 0xFF) {\n\t                    buffer[destIndex] = bgbuffer[destIndex];\n\t                }\n\t            }\n\t        }\n\t\n\t        if (this.f_spVisibility == 1) {\n\t            this.renderSpritesPartially(startScan, scanCount, false);\n\t        }\n\t\n\t        this.validTileData = false;\n\t    },\n\t\n\t    renderBgScanline: function renderBgScanline(bgbuffer, scan) {\n\t        var baseTile = this.regS === 0 ? 0 : 256;\n\t        var destIndex = (scan << 8) - this.regFH;\n\t\n\t        this.curNt = this.ntable1[this.cntV + this.cntV + this.cntH];\n\t\n\t        this.cntHT = this.regHT;\n\t        this.cntH = this.regH;\n\t        this.curNt = this.ntable1[this.cntV + this.cntV + this.cntH];\n\t\n\t        if (scan < 240 && scan - this.cntFV >= 0) {\n\t\n\t            var tscanoffset = this.cntFV << 3;\n\t            var scantile = this.scantile;\n\t            var attrib = this.attrib;\n\t            var ptTile = this.ptTile;\n\t            var nameTable = this.nameTable;\n\t            var imgPalette = this.imgPalette;\n\t            var pixrendered = this.pixrendered;\n\t            var targetBuffer = bgbuffer ? this.bgbuffer : this.buffer;\n\t\n\t            var t, tpix, att, col;\n\t\n\t            for (var tile = 0; tile < 32; tile++) {\n\t\n\t                if (scan >= 0) {\n\t\n\t                    // Fetch tile & attrib data:\n\t                    if (this.validTileData) {\n\t                        // Get data from array:\n\t                        t = scantile[tile];\n\t                        tpix = t.pix;\n\t                        att = attrib[tile];\n\t                    } else {\n\t                        // Fetch data:\n\t                        t = ptTile[baseTile + nameTable[this.curNt].getTileIndex(this.cntHT, this.cntVT)];\n\t                        tpix = t.pix;\n\t                        att = nameTable[this.curNt].getAttrib(this.cntHT, this.cntVT);\n\t                        scantile[tile] = t;\n\t                        attrib[tile] = att;\n\t                    }\n\t\n\t                    // Render tile scanline:\n\t                    var sx = 0;\n\t                    var x = (tile << 3) - this.regFH;\n\t\n\t                    if (x > -8) {\n\t                        if (x < 0) {\n\t                            destIndex -= x;\n\t                            sx = -x;\n\t                        }\n\t                        if (t.opaque[this.cntFV]) {\n\t                            for (; sx < 8; sx++) {\n\t                                targetBuffer[destIndex] = imgPalette[tpix[tscanoffset + sx] + att];\n\t                                pixrendered[destIndex] |= 256;\n\t                                destIndex++;\n\t                            }\n\t                        } else {\n\t                            for (; sx < 8; sx++) {\n\t                                col = tpix[tscanoffset + sx];\n\t                                if (col !== 0) {\n\t                                    targetBuffer[destIndex] = imgPalette[col + att];\n\t                                    pixrendered[destIndex] |= 256;\n\t                                }\n\t                                destIndex++;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                // Increase Horizontal Tile Counter:\n\t                if (++this.cntHT == 32) {\n\t                    this.cntHT = 0;\n\t                    this.cntH++;\n\t                    this.cntH %= 2;\n\t                    this.curNt = this.ntable1[(this.cntV << 1) + this.cntH];\n\t                }\n\t            }\n\t\n\t            // Tile data for one row should now have been fetched,\n\t            // so the data in the array is valid.\n\t            this.validTileData = true;\n\t        }\n\t\n\t        // update vertical scroll:\n\t        this.cntFV++;\n\t        if (this.cntFV == 8) {\n\t            this.cntFV = 0;\n\t            this.cntVT++;\n\t            if (this.cntVT == 30) {\n\t                this.cntVT = 0;\n\t                this.cntV++;\n\t                this.cntV %= 2;\n\t                this.curNt = this.ntable1[(this.cntV << 1) + this.cntH];\n\t            } else if (this.cntVT == 32) {\n\t                this.cntVT = 0;\n\t            }\n\t\n\t            // Invalidate fetched data:\n\t            this.validTileData = false;\n\t        }\n\t    },\n\t\n\t    renderSpritesPartially: function renderSpritesPartially(startscan, scancount, bgPri) {\n\t        if (this.f_spVisibility === 1) {\n\t\n\t            for (var i = 0; i < 64; i++) {\n\t                if (this.bgPriority[i] == bgPri && this.sprX[i] >= 0 && this.sprX[i] < 256 && this.sprY[i] + 8 >= startscan && this.sprY[i] < startscan + scancount) {\n\t                    // Show sprite.\n\t                    if (this.f_spriteSize === 0) {\n\t                        // 8x8 sprites\n\t\n\t                        this.srcy1 = 0;\n\t                        this.srcy2 = 8;\n\t\n\t                        if (this.sprY[i] < startscan) {\n\t                            this.srcy1 = startscan - this.sprY[i] - 1;\n\t                        }\n\t\n\t                        if (this.sprY[i] + 8 > startscan + scancount) {\n\t                            this.srcy2 = startscan + scancount - this.sprY[i] + 1;\n\t                        }\n\t\n\t                        if (this.f_spPatternTable === 0) {\n\t                            this.ptTile[this.sprTile[i]].render(this.buffer, 0, this.srcy1, 8, this.srcy2, this.sprX[i], this.sprY[i] + 1, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n\t                        } else {\n\t                            this.ptTile[this.sprTile[i] + 256].render(this.buffer, 0, this.srcy1, 8, this.srcy2, this.sprX[i], this.sprY[i] + 1, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n\t                        }\n\t                    } else {\n\t                        // 8x16 sprites\n\t                        var top = this.sprTile[i];\n\t                        if ((top & 1) !== 0) {\n\t                            top = this.sprTile[i] - 1 + 256;\n\t                        }\n\t\n\t                        var srcy1 = 0;\n\t                        var srcy2 = 8;\n\t\n\t                        if (this.sprY[i] < startscan) {\n\t                            srcy1 = startscan - this.sprY[i] - 1;\n\t                        }\n\t\n\t                        if (this.sprY[i] + 8 > startscan + scancount) {\n\t                            srcy2 = startscan + scancount - this.sprY[i];\n\t                        }\n\t\n\t                        this.ptTile[top + (this.vertFlip[i] ? 1 : 0)].render(this.buffer, 0, srcy1, 8, srcy2, this.sprX[i], this.sprY[i] + 1, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n\t\n\t                        srcy1 = 0;\n\t                        srcy2 = 8;\n\t\n\t                        if (this.sprY[i] + 8 < startscan) {\n\t                            srcy1 = startscan - (this.sprY[i] + 8 + 1);\n\t                        }\n\t\n\t                        if (this.sprY[i] + 16 > startscan + scancount) {\n\t                            srcy2 = startscan + scancount - (this.sprY[i] + 8);\n\t                        }\n\t\n\t                        this.ptTile[top + (this.vertFlip[i] ? 0 : 1)].render(this.buffer, 0, srcy1, 8, srcy2, this.sprX[i], this.sprY[i] + 1 + 8, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    checkSprite0: function checkSprite0(scan) {\n\t\n\t        this.spr0HitX = -1;\n\t        this.spr0HitY = -1;\n\t\n\t        var toffset;\n\t        var tIndexAdd = this.f_spPatternTable === 0 ? 0 : 256;\n\t        var x, y, t, i;\n\t        var bufferIndex;\n\t        var col;\n\t        var bgPri;\n\t\n\t        x = this.sprX[0];\n\t        y = this.sprY[0] + 1;\n\t\n\t        if (this.f_spriteSize === 0) {\n\t            // 8x8 sprites.\n\t\n\t            // Check range:\n\t            if (y <= scan && y + 8 > scan && x >= -7 && x < 256) {\n\t\n\t                // Sprite is in range.\n\t                // Draw scanline:\n\t                t = this.ptTile[this.sprTile[0] + tIndexAdd];\n\t                col = this.sprCol[0];\n\t                bgPri = this.bgPriority[0];\n\t\n\t                if (this.vertFlip[0]) {\n\t                    toffset = 7 - (scan - y);\n\t                } else {\n\t                    toffset = scan - y;\n\t                }\n\t                toffset *= 8;\n\t\n\t                bufferIndex = scan * 256 + x;\n\t                if (this.horiFlip[0]) {\n\t                    for (i = 7; i >= 0; i--) {\n\t                        if (x >= 0 && x < 256) {\n\t                            if (bufferIndex >= 0 && bufferIndex < 61440 && this.pixrendered[bufferIndex] !== 0) {\n\t                                if (t.pix[toffset + i] !== 0) {\n\t                                    this.spr0HitX = bufferIndex % 256;\n\t                                    this.spr0HitY = scan;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }\n\t                        x++;\n\t                        bufferIndex++;\n\t                    }\n\t                } else {\n\t                    for (i = 0; i < 8; i++) {\n\t                        if (x >= 0 && x < 256) {\n\t                            if (bufferIndex >= 0 && bufferIndex < 61440 && this.pixrendered[bufferIndex] !== 0) {\n\t                                if (t.pix[toffset + i] !== 0) {\n\t                                    this.spr0HitX = bufferIndex % 256;\n\t                                    this.spr0HitY = scan;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }\n\t                        x++;\n\t                        bufferIndex++;\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            // 8x16 sprites:\n\t\n\t            // Check range:\n\t            if (y <= scan && y + 16 > scan && x >= -7 && x < 256) {\n\t                // Sprite is in range.\n\t                // Draw scanline:\n\t\n\t                if (this.vertFlip[0]) {\n\t                    toffset = 15 - (scan - y);\n\t                } else {\n\t                    toffset = scan - y;\n\t                }\n\t\n\t                if (toffset < 8) {\n\t                    // first half of sprite.\n\t                    t = this.ptTile[this.sprTile[0] + (this.vertFlip[0] ? 1 : 0) + ((this.sprTile[0] & 1) !== 0 ? 255 : 0)];\n\t                } else {\n\t                    // second half of sprite.\n\t                    t = this.ptTile[this.sprTile[0] + (this.vertFlip[0] ? 0 : 1) + ((this.sprTile[0] & 1) !== 0 ? 255 : 0)];\n\t                    if (this.vertFlip[0]) {\n\t                        toffset = 15 - toffset;\n\t                    } else {\n\t                        toffset -= 8;\n\t                    }\n\t                }\n\t                toffset *= 8;\n\t                col = this.sprCol[0];\n\t                bgPri = this.bgPriority[0];\n\t\n\t                bufferIndex = scan * 256 + x;\n\t                if (this.horiFlip[0]) {\n\t                    for (i = 7; i >= 0; i--) {\n\t                        if (x >= 0 && x < 256) {\n\t                            if (bufferIndex >= 0 && bufferIndex < 61440 && this.pixrendered[bufferIndex] !== 0) {\n\t                                if (t.pix[toffset + i] !== 0) {\n\t                                    this.spr0HitX = bufferIndex % 256;\n\t                                    this.spr0HitY = scan;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }\n\t                        x++;\n\t                        bufferIndex++;\n\t                    }\n\t                } else {\n\t\n\t                    for (i = 0; i < 8; i++) {\n\t                        if (x >= 0 && x < 256) {\n\t                            if (bufferIndex >= 0 && bufferIndex < 61440 && this.pixrendered[bufferIndex] !== 0) {\n\t                                if (t.pix[toffset + i] !== 0) {\n\t                                    this.spr0HitX = bufferIndex % 256;\n\t                                    this.spr0HitY = scan;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }\n\t                        x++;\n\t                        bufferIndex++;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        return false;\n\t    },\n\t\n\t    // This will write to PPU memory, and\n\t    // update internally buffered data\n\t    // appropriately.\n\t    writeMem: function writeMem(address, value) {\n\t        this.vramMem[address] = value;\n\t\n\t        // Update internally buffered data:\n\t        if (address < 0x2000) {\n\t            this.vramMem[address] = value;\n\t            this.patternWrite(address, value);\n\t        } else if (address >= 0x2000 && address < 0x23c0) {\n\t            this.nameTableWrite(this.ntable1[0], address - 0x2000, value);\n\t        } else if (address >= 0x23c0 && address < 0x2400) {\n\t            this.attribTableWrite(this.ntable1[0], address - 0x23c0, value);\n\t        } else if (address >= 0x2400 && address < 0x27c0) {\n\t            this.nameTableWrite(this.ntable1[1], address - 0x2400, value);\n\t        } else if (address >= 0x27c0 && address < 0x2800) {\n\t            this.attribTableWrite(this.ntable1[1], address - 0x27c0, value);\n\t        } else if (address >= 0x2800 && address < 0x2bc0) {\n\t            this.nameTableWrite(this.ntable1[2], address - 0x2800, value);\n\t        } else if (address >= 0x2bc0 && address < 0x2c00) {\n\t            this.attribTableWrite(this.ntable1[2], address - 0x2bc0, value);\n\t        } else if (address >= 0x2c00 && address < 0x2fc0) {\n\t            this.nameTableWrite(this.ntable1[3], address - 0x2c00, value);\n\t        } else if (address >= 0x2fc0 && address < 0x3000) {\n\t            this.attribTableWrite(this.ntable1[3], address - 0x2fc0, value);\n\t        } else if (address >= 0x3f00 && address < 0x3f20) {\n\t            this.updatePalettes();\n\t        }\n\t    },\n\t\n\t    // Reads data from $3f00 to $f20\n\t    // into the two buffered palettes.\n\t    updatePalettes: function updatePalettes() {\n\t        var i;\n\t\n\t        for (i = 0; i < 16; i++) {\n\t            if (this.f_dispType === 0) {\n\t                this.imgPalette[i] = this.palTable.getEntry(this.vramMem[0x3f00 + i] & 63);\n\t            } else {\n\t                this.imgPalette[i] = this.palTable.getEntry(this.vramMem[0x3f00 + i] & 32);\n\t            }\n\t        }\n\t        for (i = 0; i < 16; i++) {\n\t            if (this.f_dispType === 0) {\n\t                this.sprPalette[i] = this.palTable.getEntry(this.vramMem[0x3f10 + i] & 63);\n\t            } else {\n\t                this.sprPalette[i] = this.palTable.getEntry(this.vramMem[0x3f10 + i] & 32);\n\t            }\n\t        }\n\t    },\n\t\n\t    // Updates the internal pattern\n\t    // table buffers with this new byte.\n\t    // In vNES, there is a version of this with 4 arguments which isn't used.\n\t    patternWrite: function patternWrite(address, value) {\n\t        var tileIndex = Math.floor(address / 16);\n\t        var leftOver = address % 16;\n\t        if (leftOver < 8) {\n\t            this.ptTile[tileIndex].setScanline(leftOver, value, this.vramMem[address + 8]);\n\t        } else {\n\t            this.ptTile[tileIndex].setScanline(leftOver - 8, this.vramMem[address - 8], value);\n\t        }\n\t    },\n\t\n\t    // Updates the internal name table buffers\n\t    // with this new byte.\n\t    nameTableWrite: function nameTableWrite(index, address, value) {\n\t        this.nameTable[index].tile[address] = value;\n\t\n\t        // Update Sprite #0 hit:\n\t        //updateSpr0Hit();\n\t        this.checkSprite0(this.scanline - 20);\n\t    },\n\t\n\t    // Updates the internal pattern\n\t    // table buffers with this new attribute\n\t    // table byte.\n\t    attribTableWrite: function attribTableWrite(index, address, value) {\n\t        this.nameTable[index].writeAttrib(address, value);\n\t    },\n\t\n\t    // Updates the internally buffered sprite\n\t    // data with this new byte of info.\n\t    spriteRamWriteUpdate: function spriteRamWriteUpdate(address, value) {\n\t        var tIndex = Math.floor(address / 4);\n\t\n\t        if (tIndex === 0) {\n\t            //updateSpr0Hit();\n\t            this.checkSprite0(this.scanline - 20);\n\t        }\n\t\n\t        if (address % 4 === 0) {\n\t            // Y coordinate\n\t            this.sprY[tIndex] = value;\n\t        } else if (address % 4 == 1) {\n\t            // Tile index\n\t            this.sprTile[tIndex] = value;\n\t        } else if (address % 4 == 2) {\n\t            // Attributes\n\t            this.vertFlip[tIndex] = (value & 0x80) !== 0;\n\t            this.horiFlip[tIndex] = (value & 0x40) !== 0;\n\t            this.bgPriority[tIndex] = (value & 0x20) !== 0;\n\t            this.sprCol[tIndex] = (value & 3) << 2;\n\t        } else if (address % 4 == 3) {\n\t            // X coordinate\n\t            this.sprX[tIndex] = value;\n\t        }\n\t    },\n\t\n\t    doNMI: function doNMI() {\n\t        // Set VBlank flag:\n\t        this.setStatusFlag(this.STATUS_VBLANK, true);\n\t        //nes.getCpu().doNonMaskableInterrupt();\n\t        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n\t    },\n\t\n\t    JSON_PROPERTIES: [\n\t    // Memory\n\t    'vramMem', 'spriteMem',\n\t    // Counters\n\t    'cntFV', 'cntV', 'cntH', 'cntVT', 'cntHT',\n\t    // Registers\n\t    'regFV', 'regV', 'regH', 'regVT', 'regHT', 'regFH', 'regS',\n\t    // VRAM addr\n\t    'vramAddress', 'vramTmpAddress',\n\t    // Control/Status registers\n\t    'f_nmiOnVblank', 'f_spriteSize', 'f_bgPatternTable', 'f_spPatternTable', 'f_addrInc', 'f_nTblAddress', 'f_color', 'f_spVisibility', 'f_bgVisibility', 'f_spClipping', 'f_bgClipping', 'f_dispType',\n\t    // VRAM I/O\n\t    'vramBufferedReadValue', 'firstWrite',\n\t    // Mirroring\n\t    'currentMirroring', 'vramMirrorTable', 'ntable1',\n\t    // SPR-RAM I/O\n\t    'sramAddress',\n\t    // Sprites. Most sprite data is rebuilt from spriteMem\n\t    'hitSpr0',\n\t    // Palettes\n\t    'sprPalette', 'imgPalette',\n\t    // Rendering progression\n\t    'curX', 'scanline', 'lastRenderedScanline', 'curNt', 'scantile',\n\t    // Used during rendering\n\t    'attrib', 'buffer', 'bgbuffer', 'pixrendered',\n\t    // Misc\n\t    'requestEndFrame', 'nmiOk', 'dummyCycleToggle', 'nmiCounter', 'validTileData', 'scanlineAlreadyRendered'],\n\t\n\t    toJSON: function toJSON() {\n\t        var i;\n\t        var state = _utils2.default.toJSON(this);\n\t\n\t        state.nameTable = [];\n\t        for (i = 0; i < this.nameTable.length; i++) {\n\t            state.nameTable[i] = this.nameTable[i].toJSON();\n\t        }\n\t\n\t        state.ptTile = [];\n\t        for (i = 0; i < this.ptTile.length; i++) {\n\t            state.ptTile[i] = this.ptTile[i].toJSON();\n\t        }\n\t\n\t        return state;\n\t    },\n\t\n\t    fromJSON: function fromJSON(state) {\n\t        var i;\n\t\n\t        _utils2.default.fromJSON(this, state);\n\t\n\t        for (i = 0; i < this.nameTable.length; i++) {\n\t            this.nameTable[i].fromJSON(state.nameTable[i]);\n\t        }\n\t\n\t        for (i = 0; i < this.ptTile.length; i++) {\n\t            this.ptTile[i].fromJSON(state.ptTile[i]);\n\t        }\n\t\n\t        // Sprite data:\n\t        for (i = 0; i < this.spriteMem.length; i++) {\n\t            this.spriteRamWriteUpdate(i, this.spriteMem[i]);\n\t        }\n\t    }\n\t};\n\t\n\tPPU.NameTable = function (width, height, name) {\n\t    this.width = width;\n\t    this.height = height;\n\t    this.name = name;\n\t\n\t    this.tile = new Array(width * height);\n\t    this.attrib = new Array(width * height);\n\t};\n\t\n\tPPU.NameTable.prototype = {\n\t    getTileIndex: function getTileIndex(x, y) {\n\t        return this.tile[y * this.width + x];\n\t    },\n\t\n\t    getAttrib: function getAttrib(x, y) {\n\t        return this.attrib[y * this.width + x];\n\t    },\n\t\n\t    writeAttrib: function writeAttrib(index, value) {\n\t        var basex = index % 8 * 4;\n\t        var basey = Math.floor(index / 8) * 4;\n\t        var add;\n\t        var tx, ty;\n\t        var attindex;\n\t\n\t        for (var sqy = 0; sqy < 2; sqy++) {\n\t            for (var sqx = 0; sqx < 2; sqx++) {\n\t                add = value >> 2 * (sqy * 2 + sqx) & 3;\n\t                for (var y = 0; y < 2; y++) {\n\t                    for (var x = 0; x < 2; x++) {\n\t                        tx = basex + sqx * 2 + x;\n\t                        ty = basey + sqy * 2 + y;\n\t                        attindex = ty * this.width + tx;\n\t                        this.attrib[ty * this.width + tx] = add << 2 & 12;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    toJSON: function toJSON() {\n\t        return {\n\t            'tile': this.tile,\n\t            'attrib': this.attrib\n\t        };\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        this.tile = s.tile;\n\t        this.attrib = s.attrib;\n\t    }\n\t};\n\t\n\tPPU.PaletteTable = function () {\n\t    this.curTable = new Array(64);\n\t    this.emphTable = new Array(8);\n\t    this.currentEmph = -1;\n\t};\n\t\n\tPPU.PaletteTable.prototype = {\n\t    reset: function reset() {\n\t        this.setEmphasis(0);\n\t    },\n\t\n\t    loadNTSCPalette: function loadNTSCPalette() {\n\t        this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n\t        this.makeTables();\n\t        this.setEmphasis(0);\n\t    },\n\t\n\t    loadPALPalette: function loadPALPalette() {\n\t        this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n\t        this.makeTables();\n\t        this.setEmphasis(0);\n\t    },\n\t\n\t    makeTables: function makeTables() {\n\t        var r, g, b, col, i, rFactor, gFactor, bFactor;\n\t\n\t        // Calculate a table for each possible emphasis setting:\n\t        for (var emph = 0; emph < 8; emph++) {\n\t\n\t            // Determine color component factors:\n\t            rFactor = 1.0;\n\t            gFactor = 1.0;\n\t            bFactor = 1.0;\n\t\n\t            if ((emph & 1) !== 0) {\n\t                rFactor = 0.75;\n\t                bFactor = 0.75;\n\t            }\n\t            if ((emph & 2) !== 0) {\n\t                rFactor = 0.75;\n\t                gFactor = 0.75;\n\t            }\n\t            if ((emph & 4) !== 0) {\n\t                gFactor = 0.75;\n\t                bFactor = 0.75;\n\t            }\n\t\n\t            this.emphTable[emph] = new Array(64);\n\t\n\t            // Calculate table:\n\t            for (i = 0; i < 64; i++) {\n\t                col = this.curTable[i];\n\t                r = Math.floor(this.getRed(col) * rFactor);\n\t                g = Math.floor(this.getGreen(col) * gFactor);\n\t                b = Math.floor(this.getBlue(col) * bFactor);\n\t                this.emphTable[emph][i] = this.getRgb(r, g, b);\n\t            }\n\t        }\n\t    },\n\t\n\t    setEmphasis: function setEmphasis(emph) {\n\t        if (emph != this.currentEmph) {\n\t            this.currentEmph = emph;\n\t            for (var i = 0; i < 64; i++) {\n\t                this.curTable[i] = this.emphTable[emph][i];\n\t            }\n\t        }\n\t    },\n\t\n\t    getEntry: function getEntry(yiq) {\n\t        return this.curTable[yiq];\n\t    },\n\t\n\t    getRed: function getRed(rgb) {\n\t        return rgb >> 16 & 0xFF;\n\t    },\n\t\n\t    getGreen: function getGreen(rgb) {\n\t        return rgb >> 8 & 0xFF;\n\t    },\n\t\n\t    getBlue: function getBlue(rgb) {\n\t        return rgb & 0xFF;\n\t    },\n\t\n\t    getRgb: function getRgb(r, g, b) {\n\t        return r << 16 | g << 8 | b;\n\t    },\n\t\n\t    loadDefaultPalette: function loadDefaultPalette() {\n\t        this.curTable[0] = this.getRgb(117, 117, 117);\n\t        this.curTable[1] = this.getRgb(39, 27, 143);\n\t        this.curTable[2] = this.getRgb(0, 0, 171);\n\t        this.curTable[3] = this.getRgb(71, 0, 159);\n\t        this.curTable[4] = this.getRgb(143, 0, 119);\n\t        this.curTable[5] = this.getRgb(171, 0, 19);\n\t        this.curTable[6] = this.getRgb(167, 0, 0);\n\t        this.curTable[7] = this.getRgb(127, 11, 0);\n\t        this.curTable[8] = this.getRgb(67, 47, 0);\n\t        this.curTable[9] = this.getRgb(0, 71, 0);\n\t        this.curTable[10] = this.getRgb(0, 81, 0);\n\t        this.curTable[11] = this.getRgb(0, 63, 23);\n\t        this.curTable[12] = this.getRgb(27, 63, 95);\n\t        this.curTable[13] = this.getRgb(0, 0, 0);\n\t        this.curTable[14] = this.getRgb(0, 0, 0);\n\t        this.curTable[15] = this.getRgb(0, 0, 0);\n\t        this.curTable[16] = this.getRgb(188, 188, 188);\n\t        this.curTable[17] = this.getRgb(0, 115, 239);\n\t        this.curTable[18] = this.getRgb(35, 59, 239);\n\t        this.curTable[19] = this.getRgb(131, 0, 243);\n\t        this.curTable[20] = this.getRgb(191, 0, 191);\n\t        this.curTable[21] = this.getRgb(231, 0, 91);\n\t        this.curTable[22] = this.getRgb(219, 43, 0);\n\t        this.curTable[23] = this.getRgb(203, 79, 15);\n\t        this.curTable[24] = this.getRgb(139, 115, 0);\n\t        this.curTable[25] = this.getRgb(0, 151, 0);\n\t        this.curTable[26] = this.getRgb(0, 171, 0);\n\t        this.curTable[27] = this.getRgb(0, 147, 59);\n\t        this.curTable[28] = this.getRgb(0, 131, 139);\n\t        this.curTable[29] = this.getRgb(0, 0, 0);\n\t        this.curTable[30] = this.getRgb(0, 0, 0);\n\t        this.curTable[31] = this.getRgb(0, 0, 0);\n\t        this.curTable[32] = this.getRgb(255, 255, 255);\n\t        this.curTable[33] = this.getRgb(63, 191, 255);\n\t        this.curTable[34] = this.getRgb(95, 151, 255);\n\t        this.curTable[35] = this.getRgb(167, 139, 253);\n\t        this.curTable[36] = this.getRgb(247, 123, 255);\n\t        this.curTable[37] = this.getRgb(255, 119, 183);\n\t        this.curTable[38] = this.getRgb(255, 119, 99);\n\t        this.curTable[39] = this.getRgb(255, 155, 59);\n\t        this.curTable[40] = this.getRgb(243, 191, 63);\n\t        this.curTable[41] = this.getRgb(131, 211, 19);\n\t        this.curTable[42] = this.getRgb(79, 223, 75);\n\t        this.curTable[43] = this.getRgb(88, 248, 152);\n\t        this.curTable[44] = this.getRgb(0, 235, 219);\n\t        this.curTable[45] = this.getRgb(0, 0, 0);\n\t        this.curTable[46] = this.getRgb(0, 0, 0);\n\t        this.curTable[47] = this.getRgb(0, 0, 0);\n\t        this.curTable[48] = this.getRgb(255, 255, 255);\n\t        this.curTable[49] = this.getRgb(171, 231, 255);\n\t        this.curTable[50] = this.getRgb(199, 215, 255);\n\t        this.curTable[51] = this.getRgb(215, 203, 255);\n\t        this.curTable[52] = this.getRgb(255, 199, 255);\n\t        this.curTable[53] = this.getRgb(255, 199, 219);\n\t        this.curTable[54] = this.getRgb(255, 191, 179);\n\t        this.curTable[55] = this.getRgb(255, 219, 171);\n\t        this.curTable[56] = this.getRgb(255, 231, 163);\n\t        this.curTable[57] = this.getRgb(227, 255, 163);\n\t        this.curTable[58] = this.getRgb(171, 243, 191);\n\t        this.curTable[59] = this.getRgb(179, 255, 207);\n\t        this.curTable[60] = this.getRgb(159, 255, 243);\n\t        this.curTable[61] = this.getRgb(0, 0, 0);\n\t        this.curTable[62] = this.getRgb(0, 0, 0);\n\t        this.curTable[63] = this.getRgb(0, 0, 0);\n\t\n\t        this.makeTables();\n\t        this.setEmphasis(0);\n\t    }\n\t};\n\t\n\tPPU.Tile = function () {\n\t    // Tile data:\n\t    this.pix = new Array(64);\n\t\n\t    this.fbIndex = null;\n\t    this.tIndex = null;\n\t    this.x = null;\n\t    this.y = null;\n\t    this.w = null;\n\t    this.h = null;\n\t    this.incX = null;\n\t    this.incY = null;\n\t    this.palIndex = null;\n\t    this.tpri = null;\n\t    this.c = null;\n\t    this.initialized = false;\n\t    this.opaque = new Array(8);\n\t};\n\t\n\tPPU.Tile.prototype = {\n\t    setBuffer: function setBuffer(scanline) {\n\t        for (this.y = 0; this.y < 8; this.y++) {\n\t            this.setScanline(this.y, scanline[this.y], scanline[this.y + 8]);\n\t        }\n\t    },\n\t\n\t    setScanline: function setScanline(sline, b1, b2) {\n\t        this.initialized = true;\n\t        this.tIndex = sline << 3;\n\t        for (this.x = 0; this.x < 8; this.x++) {\n\t            this.pix[this.tIndex + this.x] = (b1 >> 7 - this.x & 1) + ((b2 >> 7 - this.x & 1) << 1);\n\t            if (this.pix[this.tIndex + this.x] === 0) {\n\t                this.opaque[sline] = false;\n\t            }\n\t        }\n\t    },\n\t\n\t    render: function render(buffer, srcx1, srcy1, srcx2, srcy2, dx, dy, palAdd, palette, flipHorizontal, flipVertical, pri, priTable) {\n\t\n\t        if (dx < -7 || dx >= 256 || dy < -7 || dy >= 240) {\n\t            return;\n\t        }\n\t\n\t        this.w = srcx2 - srcx1;\n\t        this.h = srcy2 - srcy1;\n\t\n\t        if (dx < 0) {\n\t            srcx1 -= dx;\n\t        }\n\t        if (dx + srcx2 >= 256) {\n\t            srcx2 = 256 - dx;\n\t        }\n\t\n\t        if (dy < 0) {\n\t            srcy1 -= dy;\n\t        }\n\t        if (dy + srcy2 >= 240) {\n\t            srcy2 = 240 - dy;\n\t        }\n\t\n\t        if (!flipHorizontal && !flipVertical) {\n\t\n\t            this.fbIndex = (dy << 8) + dx;\n\t            this.tIndex = 0;\n\t            for (this.y = 0; this.y < 8; this.y++) {\n\t                for (this.x = 0; this.x < 8; this.x++) {\n\t                    if (this.x >= srcx1 && this.x < srcx2 && this.y >= srcy1 && this.y < srcy2) {\n\t                        this.palIndex = this.pix[this.tIndex];\n\t                        this.tpri = priTable[this.fbIndex];\n\t                        if (this.palIndex !== 0 && pri <= (this.tpri & 0xFF)) {\n\t                            //console.log(\"Rendering upright tile to buffer\");\n\t                            buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n\t                            this.tpri = this.tpri & 0xF00 | pri;\n\t                            priTable[this.fbIndex] = this.tpri;\n\t                        }\n\t                    }\n\t                    this.fbIndex++;\n\t                    this.tIndex++;\n\t                }\n\t                this.fbIndex -= 8;\n\t                this.fbIndex += 256;\n\t            }\n\t        } else if (flipHorizontal && !flipVertical) {\n\t\n\t            this.fbIndex = (dy << 8) + dx;\n\t            this.tIndex = 7;\n\t            for (this.y = 0; this.y < 8; this.y++) {\n\t                for (this.x = 0; this.x < 8; this.x++) {\n\t                    if (this.x >= srcx1 && this.x < srcx2 && this.y >= srcy1 && this.y < srcy2) {\n\t                        this.palIndex = this.pix[this.tIndex];\n\t                        this.tpri = priTable[this.fbIndex];\n\t                        if (this.palIndex !== 0 && pri <= (this.tpri & 0xFF)) {\n\t                            buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n\t                            this.tpri = this.tpri & 0xF00 | pri;\n\t                            priTable[this.fbIndex] = this.tpri;\n\t                        }\n\t                    }\n\t                    this.fbIndex++;\n\t                    this.tIndex--;\n\t                }\n\t                this.fbIndex -= 8;\n\t                this.fbIndex += 256;\n\t                this.tIndex += 16;\n\t            }\n\t        } else if (flipVertical && !flipHorizontal) {\n\t\n\t            this.fbIndex = (dy << 8) + dx;\n\t            this.tIndex = 56;\n\t            for (this.y = 0; this.y < 8; this.y++) {\n\t                for (this.x = 0; this.x < 8; this.x++) {\n\t                    if (this.x >= srcx1 && this.x < srcx2 && this.y >= srcy1 && this.y < srcy2) {\n\t                        this.palIndex = this.pix[this.tIndex];\n\t                        this.tpri = priTable[this.fbIndex];\n\t                        if (this.palIndex !== 0 && pri <= (this.tpri & 0xFF)) {\n\t                            buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n\t                            this.tpri = this.tpri & 0xF00 | pri;\n\t                            priTable[this.fbIndex] = this.tpri;\n\t                        }\n\t                    }\n\t                    this.fbIndex++;\n\t                    this.tIndex++;\n\t                }\n\t                this.fbIndex -= 8;\n\t                this.fbIndex += 256;\n\t                this.tIndex -= 16;\n\t            }\n\t        } else {\n\t            this.fbIndex = (dy << 8) + dx;\n\t            this.tIndex = 63;\n\t            for (this.y = 0; this.y < 8; this.y++) {\n\t                for (this.x = 0; this.x < 8; this.x++) {\n\t                    if (this.x >= srcx1 && this.x < srcx2 && this.y >= srcy1 && this.y < srcy2) {\n\t                        this.palIndex = this.pix[this.tIndex];\n\t                        this.tpri = priTable[this.fbIndex];\n\t                        if (this.palIndex !== 0 && pri <= (this.tpri & 0xFF)) {\n\t                            buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n\t                            this.tpri = this.tpri & 0xF00 | pri;\n\t                            priTable[this.fbIndex] = this.tpri;\n\t                        }\n\t                    }\n\t                    this.fbIndex++;\n\t                    this.tIndex--;\n\t                }\n\t                this.fbIndex -= 8;\n\t                this.fbIndex += 256;\n\t            }\n\t        }\n\t    },\n\t\n\t    isTransparent: function isTransparent(x, y) {\n\t        return this.pix[(y << 3) + x] === 0;\n\t    },\n\t\n\t    toJSON: function toJSON() {\n\t        return {\n\t            'opaque': this.opaque,\n\t            'pix': this.pix\n\t        };\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        this.opaque = s.opaque;\n\t        this.pix = s.pix;\n\t    }\n\t};\n\t\n\texports.default = PPU;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\tvar PAPU = function PAPU(nes) {\n\t    this.nes = nes;\n\t\n\t    this.square1 = new PAPU.ChannelSquare(this, true);\n\t    this.square2 = new PAPU.ChannelSquare(this, false);\n\t    this.triangle = new PAPU.ChannelTriangle(this);\n\t    this.noise = new PAPU.ChannelNoise(this);\n\t    this.dmc = new PAPU.ChannelDM(this);\n\t\n\t    this.frameIrqCounter = null;\n\t    this.frameIrqCounterMax = 4;\n\t    this.initCounter = 2048;\n\t    this.channelEnableValue = null;\n\t\n\t    this.bufferSize = 8192;\n\t    this.bufferIndex = 0;\n\t    this.sampleRate = 44100;\n\t\n\t    this.lengthLookup = null;\n\t    this.dmcFreqLookup = null;\n\t    this.noiseWavelengthLookup = null;\n\t    this.square_table = null;\n\t    this.tnd_table = null;\n\t    this.sampleBuffer = new Array(this.bufferSize * 2);\n\t\n\t    this.frameIrqEnabled = false;\n\t    this.frameIrqActive = null;\n\t    this.frameClockNow = null;\n\t    this.startedPlaying = false;\n\t    this.recordOutput = false;\n\t    this.initingHardware = false;\n\t\n\t    this.masterFrameCounter = null;\n\t    this.derivedFrameCounter = null;\n\t    this.countSequence = null;\n\t    this.sampleTimer = null;\n\t    this.frameTime = null;\n\t    this.sampleTimerMax = null;\n\t    this.sampleCount = null;\n\t    this.triValue = 0;\n\t\n\t    this.smpSquare1 = null;\n\t    this.smpSquare2 = null;\n\t    this.smpTriangle = null;\n\t    this.smpDmc = null;\n\t    this.accCount = null;\n\t\n\t    // DC removal vars:\n\t    this.prevSampleL = 0;\n\t    this.prevSampleR = 0;\n\t    this.smpAccumL = 0;\n\t    this.smpAccumR = 0;\n\t\n\t    // DAC range:\n\t    this.dacRange = 0;\n\t    this.dcValue = 0;\n\t\n\t    // Master volume:\n\t    this.masterVolume = 256;\n\t\n\t    // Stereo positioning:\n\t    this.stereoPosLSquare1 = null;\n\t    this.stereoPosLSquare2 = null;\n\t    this.stereoPosLTriangle = null;\n\t    this.stereoPosLNoise = null;\n\t    this.stereoPosLDMC = null;\n\t    this.stereoPosRSquare1 = null;\n\t    this.stereoPosRSquare2 = null;\n\t    this.stereoPosRTriangle = null;\n\t    this.stereoPosRNoise = null;\n\t    this.stereoPosRDMC = null;\n\t\n\t    this.extraCycles = null;\n\t\n\t    this.maxSample = null;\n\t    this.minSample = null;\n\t\n\t    // Panning:\n\t    this.panning = [80, 170, 100, 150, 128];\n\t    this.setPanning(this.panning);\n\t\n\t    // Initialize lookup tables:\n\t    this.initLengthLookup();\n\t    this.initDmcFrequencyLookup();\n\t    this.initNoiseWavelengthLookup();\n\t    this.initDACtables();\n\t\n\t    // Init sound registers:\n\t    for (var i = 0; i < 0x14; i++) {\n\t        if (i === 0x10) {\n\t            this.writeReg(0x4010, 0x10);\n\t        } else {\n\t            this.writeReg(0x4000 + i, 0);\n\t        }\n\t    }\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.prototype = {\n\t    reset: function reset() {\n\t        this.sampleRate = this.nes.opts.sampleRate;\n\t        this.sampleTimerMax = Math.floor(1024.0 * this.nes.opts.CPU_FREQ_NTSC * this.nes.opts.preferredFrameRate / (this.sampleRate * 60.0));\n\t\n\t        this.frameTime = Math.floor(14915.0 * this.nes.opts.preferredFrameRate / 60.0);\n\t\n\t        this.sampleTimer = 0;\n\t        this.bufferIndex = 0;\n\t\n\t        this.updateChannelEnable(0);\n\t        this.masterFrameCounter = 0;\n\t        this.derivedFrameCounter = 0;\n\t        this.countSequence = 0;\n\t        this.sampleCount = 0;\n\t        this.initCounter = 2048;\n\t        this.frameIrqEnabled = false;\n\t        this.initingHardware = false;\n\t\n\t        this.resetCounter();\n\t\n\t        this.square1.reset();\n\t        this.square2.reset();\n\t        this.triangle.reset();\n\t        this.noise.reset();\n\t        this.dmc.reset();\n\t\n\t        this.bufferIndex = 0;\n\t        this.accCount = 0;\n\t        this.smpSquare1 = 0;\n\t        this.smpSquare2 = 0;\n\t        this.smpTriangle = 0;\n\t        this.smpDmc = 0;\n\t\n\t        this.frameIrqEnabled = false;\n\t        this.frameIrqCounterMax = 4;\n\t\n\t        this.channelEnableValue = 0xFF;\n\t        this.startedPlaying = false;\n\t        this.prevSampleL = 0;\n\t        this.prevSampleR = 0;\n\t        this.smpAccumL = 0;\n\t        this.smpAccumR = 0;\n\t\n\t        this.maxSample = -500000;\n\t        this.minSample = 500000;\n\t    },\n\t\n\t    readReg: function readReg(address) {\n\t        // Read 0x4015:\n\t        var tmp = 0;\n\t        tmp |= this.square1.getLengthStatus();\n\t        tmp |= this.square2.getLengthStatus() << 1;\n\t        tmp |= this.triangle.getLengthStatus() << 2;\n\t        tmp |= this.noise.getLengthStatus() << 3;\n\t        tmp |= this.dmc.getLengthStatus() << 4;\n\t        tmp |= (this.frameIrqActive && this.frameIrqEnabled ? 1 : 0) << 6;\n\t        tmp |= this.dmc.getIrqStatus() << 7;\n\t\n\t        this.frameIrqActive = false;\n\t        this.dmc.irqGenerated = false;\n\t\n\t        return tmp & 0xFFFF;\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        if (address >= 0x4000 && address < 0x4004) {\n\t            // Square Wave 1 Control\n\t            this.square1.writeReg(address, value);\n\t            ////System.out.println(\"Square Write\");\n\t        } else if (address >= 0x4004 && address < 0x4008) {\n\t            // Square 2 Control\n\t            this.square2.writeReg(address, value);\n\t        } else if (address >= 0x4008 && address < 0x400C) {\n\t            // Triangle Control\n\t            this.triangle.writeReg(address, value);\n\t        } else if (address >= 0x400C && address <= 0x400F) {\n\t            // Noise Control\n\t            this.noise.writeReg(address, value);\n\t        } else if (address === 0x4010) {\n\t            // DMC Play mode & DMA frequency\n\t            this.dmc.writeReg(address, value);\n\t        } else if (address === 0x4011) {\n\t            // DMC Delta Counter\n\t            this.dmc.writeReg(address, value);\n\t        } else if (address === 0x4012) {\n\t            // DMC Play code starting address\n\t            this.dmc.writeReg(address, value);\n\t        } else if (address === 0x4013) {\n\t            // DMC Play code length\n\t            this.dmc.writeReg(address, value);\n\t        } else if (address === 0x4015) {\n\t            // Channel enable\n\t            this.updateChannelEnable(value);\n\t\n\t            if (value !== 0 && this.initCounter > 0) {\n\t                // Start hardware initialization\n\t                this.initingHardware = true;\n\t            }\n\t\n\t            // DMC/IRQ Status\n\t            this.dmc.writeReg(address, value);\n\t        } else if (address === 0x4017) {\n\t            // Frame counter control\n\t            this.countSequence = value >> 7 & 1;\n\t            this.masterFrameCounter = 0;\n\t            this.frameIrqActive = false;\n\t\n\t            if ((value >> 6 & 0x1) === 0) {\n\t                this.frameIrqEnabled = true;\n\t            } else {\n\t                this.frameIrqEnabled = false;\n\t            }\n\t\n\t            if (this.countSequence === 0) {\n\t                // NTSC:\n\t                this.frameIrqCounterMax = 4;\n\t                this.derivedFrameCounter = 4;\n\t            } else {\n\t                // PAL:\n\t                this.frameIrqCounterMax = 5;\n\t                this.derivedFrameCounter = 0;\n\t                this.frameCounterTick();\n\t            }\n\t        }\n\t    },\n\t\n\t    resetCounter: function resetCounter() {\n\t        if (this.countSequence === 0) {\n\t            this.derivedFrameCounter = 4;\n\t        } else {\n\t            this.derivedFrameCounter = 0;\n\t        }\n\t    },\n\t\n\t    // Updates channel enable status.\n\t    // This is done on writes to the\n\t    // channel enable register (0x4015),\n\t    // and when the user enables/disables channels\n\t    // in the GUI.\n\t    updateChannelEnable: function updateChannelEnable(value) {\n\t        this.channelEnableValue = value & 0xFFFF;\n\t        this.square1.setEnabled((value & 1) !== 0);\n\t        this.square2.setEnabled((value & 2) !== 0);\n\t        this.triangle.setEnabled((value & 4) !== 0);\n\t        this.noise.setEnabled((value & 8) !== 0);\n\t        this.dmc.setEnabled((value & 16) !== 0);\n\t    },\n\t\n\t    // Clocks the frame counter. It should be clocked at\n\t    // twice the cpu speed, so the cycles will be\n\t    // divided by 2 for those counters that are\n\t    // clocked at cpu speed.\n\t    clockFrameCounter: function clockFrameCounter(nCycles) {\n\t        if (this.initCounter > 0) {\n\t            if (this.initingHardware) {\n\t                this.initCounter -= nCycles;\n\t                if (this.initCounter <= 0) {\n\t                    this.initingHardware = false;\n\t                }\n\t                return;\n\t            }\n\t        }\n\t\n\t        // Don't process ticks beyond next sampling:\n\t        nCycles += this.extraCycles;\n\t        var maxCycles = this.sampleTimerMax - this.sampleTimer;\n\t        if (nCycles << 10 > maxCycles) {\n\t\n\t            this.extraCycles = (nCycles << 10) - maxCycles >> 10;\n\t            nCycles -= this.extraCycles;\n\t        } else {\n\t\n\t            this.extraCycles = 0;\n\t        }\n\t\n\t        var dmc = this.dmc;\n\t        var triangle = this.triangle;\n\t        var square1 = this.square1;\n\t        var square2 = this.square2;\n\t        var noise = this.noise;\n\t\n\t        // Clock DMC:\n\t        if (dmc.isEnabled) {\n\t\n\t            dmc.shiftCounter -= nCycles << 3;\n\t            while (dmc.shiftCounter <= 0 && dmc.dmaFrequency > 0) {\n\t                dmc.shiftCounter += dmc.dmaFrequency;\n\t                dmc.clockDmc();\n\t            }\n\t        }\n\t\n\t        // Clock Triangle channel Prog timer:\n\t        if (triangle.progTimerMax > 0) {\n\t\n\t            triangle.progTimerCount -= nCycles;\n\t            while (triangle.progTimerCount <= 0) {\n\t\n\t                triangle.progTimerCount += triangle.progTimerMax + 1;\n\t                if (triangle.linearCounter > 0 && triangle.lengthCounter > 0) {\n\t\n\t                    triangle.triangleCounter++;\n\t                    triangle.triangleCounter &= 0x1F;\n\t\n\t                    if (triangle.isEnabled) {\n\t                        if (triangle.triangleCounter >= 0x10) {\n\t                            // Normal value.\n\t                            triangle.sampleValue = triangle.triangleCounter & 0xF;\n\t                        } else {\n\t                            // Inverted value.\n\t                            triangle.sampleValue = 0xF - (triangle.triangleCounter & 0xF);\n\t                        }\n\t                        triangle.sampleValue <<= 4;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // Clock Square channel 1 Prog timer:\n\t        square1.progTimerCount -= nCycles;\n\t        if (square1.progTimerCount <= 0) {\n\t\n\t            square1.progTimerCount += square1.progTimerMax + 1 << 1;\n\t\n\t            square1.squareCounter++;\n\t            square1.squareCounter &= 0x7;\n\t            square1.updateSampleValue();\n\t        }\n\t\n\t        // Clock Square channel 2 Prog timer:\n\t        square2.progTimerCount -= nCycles;\n\t        if (square2.progTimerCount <= 0) {\n\t\n\t            square2.progTimerCount += square2.progTimerMax + 1 << 1;\n\t\n\t            square2.squareCounter++;\n\t            square2.squareCounter &= 0x7;\n\t            square2.updateSampleValue();\n\t        }\n\t\n\t        // Clock noise channel Prog timer:\n\t        var acc_c = nCycles;\n\t        if (noise.progTimerCount - acc_c > 0) {\n\t\n\t            // Do all cycles at once:\n\t            noise.progTimerCount -= acc_c;\n\t            noise.accCount += acc_c;\n\t            noise.accValue += acc_c * noise.sampleValue;\n\t        } else {\n\t\n\t            // Slow-step:\n\t            while (acc_c-- > 0) {\n\t\n\t                if (--noise.progTimerCount <= 0 && noise.progTimerMax > 0) {\n\t\n\t                    // Update noise shift register:\n\t                    noise.shiftReg <<= 1;\n\t                    noise.tmp = (noise.shiftReg << (noise.randomMode === 0 ? 1 : 6) ^ noise.shiftReg) & 0x8000;\n\t                    if (noise.tmp !== 0) {\n\t\n\t                        // Sample value must be 0.\n\t                        noise.shiftReg |= 0x01;\n\t                        noise.randomBit = 0;\n\t                        noise.sampleValue = 0;\n\t                    } else {\n\t\n\t                        // Find sample value:\n\t                        noise.randomBit = 1;\n\t                        if (noise.isEnabled && noise.lengthCounter > 0) {\n\t                            noise.sampleValue = noise.masterVolume;\n\t                        } else {\n\t                            noise.sampleValue = 0;\n\t                        }\n\t                    }\n\t\n\t                    noise.progTimerCount += noise.progTimerMax;\n\t                }\n\t\n\t                noise.accValue += noise.sampleValue;\n\t                noise.accCount++;\n\t            }\n\t        }\n\t\n\t        // Frame IRQ handling:\n\t        if (this.frameIrqEnabled && this.frameIrqActive) {\n\t            this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n\t        }\n\t\n\t        // Clock frame counter at double CPU speed:\n\t        this.masterFrameCounter += nCycles << 1;\n\t        if (this.masterFrameCounter >= this.frameTime) {\n\t            // 240Hz tick:\n\t            this.masterFrameCounter -= this.frameTime;\n\t            this.frameCounterTick();\n\t        }\n\t\n\t        // Accumulate sample value:\n\t        this.accSample(nCycles);\n\t\n\t        // Clock sample timer:\n\t        this.sampleTimer += nCycles << 10;\n\t        if (this.sampleTimer >= this.sampleTimerMax) {\n\t            // Sample channels:\n\t            this.sample();\n\t            this.sampleTimer -= this.sampleTimerMax;\n\t        }\n\t    },\n\t\n\t    accSample: function accSample(cycles) {\n\t        // Special treatment for triangle channel - need to interpolate.\n\t        if (this.triangle.sampleCondition) {\n\t            this.triValue = Math.floor((this.triangle.progTimerCount << 4) / (this.triangle.progTimerMax + 1));\n\t            if (this.triValue > 16) {\n\t                this.triValue = 16;\n\t            }\n\t            if (this.triangle.triangleCounter >= 16) {\n\t                this.triValue = 16 - this.triValue;\n\t            }\n\t\n\t            // Add non-interpolated sample value:\n\t            this.triValue += this.triangle.sampleValue;\n\t        }\n\t\n\t        // Now sample normally:\n\t        if (cycles === 2) {\n\t\n\t            this.smpTriangle += this.triValue << 1;\n\t            this.smpDmc += this.dmc.sample << 1;\n\t            this.smpSquare1 += this.square1.sampleValue << 1;\n\t            this.smpSquare2 += this.square2.sampleValue << 1;\n\t            this.accCount += 2;\n\t        } else if (cycles === 4) {\n\t\n\t            this.smpTriangle += this.triValue << 2;\n\t            this.smpDmc += this.dmc.sample << 2;\n\t            this.smpSquare1 += this.square1.sampleValue << 2;\n\t            this.smpSquare2 += this.square2.sampleValue << 2;\n\t            this.accCount += 4;\n\t        } else {\n\t\n\t            this.smpTriangle += cycles * this.triValue;\n\t            this.smpDmc += cycles * this.dmc.sample;\n\t            this.smpSquare1 += cycles * this.square1.sampleValue;\n\t            this.smpSquare2 += cycles * this.square2.sampleValue;\n\t            this.accCount += cycles;\n\t        }\n\t    },\n\t\n\t    frameCounterTick: function frameCounterTick() {\n\t\n\t        this.derivedFrameCounter++;\n\t        if (this.derivedFrameCounter >= this.frameIrqCounterMax) {\n\t            this.derivedFrameCounter = 0;\n\t        }\n\t\n\t        if (this.derivedFrameCounter === 1 || this.derivedFrameCounter === 3) {\n\t\n\t            // Clock length & sweep:\n\t            this.triangle.clockLengthCounter();\n\t            this.square1.clockLengthCounter();\n\t            this.square2.clockLengthCounter();\n\t            this.noise.clockLengthCounter();\n\t            this.square1.clockSweep();\n\t            this.square2.clockSweep();\n\t        }\n\t\n\t        if (this.derivedFrameCounter >= 0 && this.derivedFrameCounter < 4) {\n\t\n\t            // Clock linear & decay:\n\t            this.square1.clockEnvDecay();\n\t            this.square2.clockEnvDecay();\n\t            this.noise.clockEnvDecay();\n\t            this.triangle.clockLinearCounter();\n\t        }\n\t\n\t        if (this.derivedFrameCounter === 3 && this.countSequence === 0) {\n\t\n\t            // Enable IRQ:\n\t            this.frameIrqActive = true;\n\t        }\n\t\n\t        // End of 240Hz tick\n\t    },\n\t\n\t    // Samples the channels, mixes the output together,\n\t    // writes to buffer and (if enabled) file.\n\t    sample: function sample() {\n\t        var sq_index, tnd_index;\n\t\n\t        if (this.accCount > 0) {\n\t\n\t            this.smpSquare1 <<= 4;\n\t            this.smpSquare1 = Math.floor(this.smpSquare1 / this.accCount);\n\t\n\t            this.smpSquare2 <<= 4;\n\t            this.smpSquare2 = Math.floor(this.smpSquare2 / this.accCount);\n\t\n\t            this.smpTriangle = Math.floor(this.smpTriangle / this.accCount);\n\t\n\t            this.smpDmc <<= 4;\n\t            this.smpDmc = Math.floor(this.smpDmc / this.accCount);\n\t\n\t            this.accCount = 0;\n\t        } else {\n\t            this.smpSquare1 = this.square1.sampleValue << 4;\n\t            this.smpSquare2 = this.square2.sampleValue << 4;\n\t            this.smpTriangle = this.triangle.sampleValue;\n\t            this.smpDmc = this.dmc.sample << 4;\n\t        }\n\t\n\t        var smpNoise = Math.floor((this.noise.accValue << 4) / this.noise.accCount);\n\t        this.noise.accValue = smpNoise >> 4;\n\t        this.noise.accCount = 1;\n\t\n\t        // Stereo sound.\n\t\n\t        // Left channel:\n\t        sq_index = this.smpSquare1 * this.stereoPosLSquare1 + this.smpSquare2 * this.stereoPosLSquare2 >> 8;\n\t        tnd_index = 3 * this.smpTriangle * this.stereoPosLTriangle + (smpNoise << 1) * this.stereoPosLNoise + this.smpDmc * this.stereoPosLDMC >> 8;\n\t        if (sq_index >= this.square_table.length) {\n\t            sq_index = this.square_table.length - 1;\n\t        }\n\t        if (tnd_index >= this.tnd_table.length) {\n\t            tnd_index = this.tnd_table.length - 1;\n\t        }\n\t        var sampleValueL = this.square_table[sq_index] + this.tnd_table[tnd_index] - this.dcValue;\n\t\n\t        // Right channel:\n\t        sq_index = this.smpSquare1 * this.stereoPosRSquare1 + this.smpSquare2 * this.stereoPosRSquare2 >> 8;\n\t        tnd_index = 3 * this.smpTriangle * this.stereoPosRTriangle + (smpNoise << 1) * this.stereoPosRNoise + this.smpDmc * this.stereoPosRDMC >> 8;\n\t        if (sq_index >= this.square_table.length) {\n\t            sq_index = this.square_table.length - 1;\n\t        }\n\t        if (tnd_index >= this.tnd_table.length) {\n\t            tnd_index = this.tnd_table.length - 1;\n\t        }\n\t        var sampleValueR = this.square_table[sq_index] + this.tnd_table[tnd_index] - this.dcValue;\n\t\n\t        // Remove DC from left channel:\n\t        var smpDiffL = sampleValueL - this.prevSampleL;\n\t        this.prevSampleL += smpDiffL;\n\t        this.smpAccumL += smpDiffL - (this.smpAccumL >> 10);\n\t        sampleValueL = this.smpAccumL;\n\t\n\t        // Remove DC from right channel:\n\t        var smpDiffR = sampleValueR - this.prevSampleR;\n\t        this.prevSampleR += smpDiffR;\n\t        this.smpAccumR += smpDiffR - (this.smpAccumR >> 10);\n\t        sampleValueR = this.smpAccumR;\n\t\n\t        // Write:\n\t        if (sampleValueL > this.maxSample) {\n\t            this.maxSample = sampleValueL;\n\t        }\n\t        if (sampleValueL < this.minSample) {\n\t            this.minSample = sampleValueL;\n\t        }\n\t        this.sampleBuffer[this.bufferIndex++] = sampleValueL;\n\t        this.sampleBuffer[this.bufferIndex++] = sampleValueR;\n\t\n\t        // Write full buffer\n\t        if (this.bufferIndex === this.sampleBuffer.length) {\n\t            this.nes.ui.writeAudio(this.sampleBuffer);\n\t            this.sampleBuffer = new Array(this.bufferSize * 2);\n\t            this.bufferIndex = 0;\n\t        }\n\t\n\t        // Reset sampled values:\n\t        this.smpSquare1 = 0;\n\t        this.smpSquare2 = 0;\n\t        this.smpTriangle = 0;\n\t        this.smpDmc = 0;\n\t    },\n\t\n\t    getLengthMax: function getLengthMax(value) {\n\t        return this.lengthLookup[value >> 3];\n\t    },\n\t\n\t    getDmcFrequency: function getDmcFrequency(value) {\n\t        if (value >= 0 && value < 0x10) {\n\t            return this.dmcFreqLookup[value];\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    getNoiseWaveLength: function getNoiseWaveLength(value) {\n\t        if (value >= 0 && value < 0x10) {\n\t            return this.noiseWavelengthLookup[value];\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    setPanning: function setPanning(pos) {\n\t        for (var i = 0; i < 5; i++) {\n\t            this.panning[i] = pos[i];\n\t        }\n\t        this.updateStereoPos();\n\t    },\n\t\n\t    setMasterVolume: function setMasterVolume(value) {\n\t        if (value < 0) {\n\t            value = 0;\n\t        }\n\t        if (value > 256) {\n\t            value = 256;\n\t        }\n\t        this.masterVolume = value;\n\t        this.updateStereoPos();\n\t    },\n\t\n\t    updateStereoPos: function updateStereoPos() {\n\t        this.stereoPosLSquare1 = this.panning[0] * this.masterVolume >> 8;\n\t        this.stereoPosLSquare2 = this.panning[1] * this.masterVolume >> 8;\n\t        this.stereoPosLTriangle = this.panning[2] * this.masterVolume >> 8;\n\t        this.stereoPosLNoise = this.panning[3] * this.masterVolume >> 8;\n\t        this.stereoPosLDMC = this.panning[4] * this.masterVolume >> 8;\n\t\n\t        this.stereoPosRSquare1 = this.masterVolume - this.stereoPosLSquare1;\n\t        this.stereoPosRSquare2 = this.masterVolume - this.stereoPosLSquare2;\n\t        this.stereoPosRTriangle = this.masterVolume - this.stereoPosLTriangle;\n\t        this.stereoPosRNoise = this.masterVolume - this.stereoPosLNoise;\n\t        this.stereoPosRDMC = this.masterVolume - this.stereoPosLDMC;\n\t    },\n\t\n\t    initLengthLookup: function initLengthLookup() {\n\t\n\t        this.lengthLookup = [0x0A, 0xFE, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06, 0xA0, 0x08, 0x3C, 0x0A, 0x0E, 0x0C, 0x1A, 0x0E, 0x0C, 0x10, 0x18, 0x12, 0x30, 0x14, 0x60, 0x16, 0xC0, 0x18, 0x48, 0x1A, 0x10, 0x1C, 0x20, 0x1E];\n\t    },\n\t\n\t    initDmcFrequencyLookup: function initDmcFrequencyLookup() {\n\t\n\t        this.dmcFreqLookup = new Array(16);\n\t\n\t        this.dmcFreqLookup[0x0] = 0xD60;\n\t        this.dmcFreqLookup[0x1] = 0xBE0;\n\t        this.dmcFreqLookup[0x2] = 0xAA0;\n\t        this.dmcFreqLookup[0x3] = 0xA00;\n\t        this.dmcFreqLookup[0x4] = 0x8F0;\n\t        this.dmcFreqLookup[0x5] = 0x7F0;\n\t        this.dmcFreqLookup[0x6] = 0x710;\n\t        this.dmcFreqLookup[0x7] = 0x6B0;\n\t        this.dmcFreqLookup[0x8] = 0x5F0;\n\t        this.dmcFreqLookup[0x9] = 0x500;\n\t        this.dmcFreqLookup[0xA] = 0x470;\n\t        this.dmcFreqLookup[0xB] = 0x400;\n\t        this.dmcFreqLookup[0xC] = 0x350;\n\t        this.dmcFreqLookup[0xD] = 0x2A0;\n\t        this.dmcFreqLookup[0xE] = 0x240;\n\t        this.dmcFreqLookup[0xF] = 0x1B0;\n\t        //for(int i=0;i<16;i++)dmcFreqLookup[i]/=8;\n\t    },\n\t\n\t    initNoiseWavelengthLookup: function initNoiseWavelengthLookup() {\n\t\n\t        this.noiseWavelengthLookup = new Array(16);\n\t\n\t        this.noiseWavelengthLookup[0x0] = 0x004;\n\t        this.noiseWavelengthLookup[0x1] = 0x008;\n\t        this.noiseWavelengthLookup[0x2] = 0x010;\n\t        this.noiseWavelengthLookup[0x3] = 0x020;\n\t        this.noiseWavelengthLookup[0x4] = 0x040;\n\t        this.noiseWavelengthLookup[0x5] = 0x060;\n\t        this.noiseWavelengthLookup[0x6] = 0x080;\n\t        this.noiseWavelengthLookup[0x7] = 0x0A0;\n\t        this.noiseWavelengthLookup[0x8] = 0x0CA;\n\t        this.noiseWavelengthLookup[0x9] = 0x0FE;\n\t        this.noiseWavelengthLookup[0xA] = 0x17C;\n\t        this.noiseWavelengthLookup[0xB] = 0x1FC;\n\t        this.noiseWavelengthLookup[0xC] = 0x2FA;\n\t        this.noiseWavelengthLookup[0xD] = 0x3F8;\n\t        this.noiseWavelengthLookup[0xE] = 0x7F2;\n\t        this.noiseWavelengthLookup[0xF] = 0xFE4;\n\t    },\n\t\n\t    initDACtables: function initDACtables() {\n\t        var value, ival, i;\n\t        var max_sqr = 0;\n\t        var max_tnd = 0;\n\t\n\t        this.square_table = new Array(32 * 16);\n\t        this.tnd_table = new Array(204 * 16);\n\t\n\t        for (i = 0; i < 32 * 16; i++) {\n\t            value = 95.52 / (8128.0 / (i / 16.0) + 100.0);\n\t            value *= 0.98411;\n\t            value *= 50000.0;\n\t            ival = Math.floor(value);\n\t\n\t            this.square_table[i] = ival;\n\t            if (ival > max_sqr) {\n\t                max_sqr = ival;\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < 204 * 16; i++) {\n\t            value = 163.67 / (24329.0 / (i / 16.0) + 100.0);\n\t            value *= 0.98411;\n\t            value *= 50000.0;\n\t            ival = Math.floor(value);\n\t\n\t            this.tnd_table[i] = ival;\n\t            if (ival > max_tnd) {\n\t                max_tnd = ival;\n\t            }\n\t        }\n\t\n\t        this.dacRange = max_sqr + max_tnd;\n\t        this.dcValue = this.dacRange / 2;\n\t    }\n\t};\n\t\n\tPAPU.ChannelDM = function (papu) {\n\t    this.papu = papu;\n\t\n\t    this.MODE_NORMAL = 0;\n\t    this.MODE_LOOP = 1;\n\t    this.MODE_IRQ = 2;\n\t\n\t    this.isEnabled = null;\n\t    this.hasSample = null;\n\t    this.irqGenerated = false;\n\t\n\t    this.playMode = null;\n\t    this.dmaFrequency = null;\n\t    this.dmaCounter = null;\n\t    this.deltaCounter = null;\n\t    this.playStartAddress = null;\n\t    this.playAddress = null;\n\t    this.playLength = null;\n\t    this.playLengthCounter = null;\n\t    this.shiftCounter = null;\n\t    this.reg4012 = null;\n\t    this.reg4013 = null;\n\t    this.sample = null;\n\t    this.dacLsb = null;\n\t    this.data = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.ChannelDM.prototype = {\n\t    clockDmc: function clockDmc() {\n\t\n\t        // Only alter DAC value if the sample buffer has data:\n\t        if (this.hasSample) {\n\t\n\t            if ((this.data & 1) === 0) {\n\t\n\t                // Decrement delta:\n\t                if (this.deltaCounter > 0) {\n\t                    this.deltaCounter--;\n\t                }\n\t            } else {\n\t                // Increment delta:\n\t                if (this.deltaCounter < 63) {\n\t                    this.deltaCounter++;\n\t                }\n\t            }\n\t\n\t            // Update sample value:\n\t            this.sample = this.isEnabled ? (this.deltaCounter << 1) + this.dacLsb : 0;\n\t\n\t            // Update shift register:\n\t            this.data >>= 1;\n\t        }\n\t\n\t        this.dmaCounter--;\n\t        if (this.dmaCounter <= 0) {\n\t\n\t            // No more sample bits.\n\t            this.hasSample = false;\n\t            this.endOfSample();\n\t            this.dmaCounter = 8;\n\t        }\n\t\n\t        if (this.irqGenerated) {\n\t            this.papu.nes.cpu.requestIrq(this.papu.nes.cpu.IRQ_NORMAL);\n\t        }\n\t    },\n\t\n\t    endOfSample: function endOfSample() {\n\t        if (this.playLengthCounter === 0 && this.playMode === this.MODE_LOOP) {\n\t\n\t            // Start from beginning of sample:\n\t            this.playAddress = this.playStartAddress;\n\t            this.playLengthCounter = this.playLength;\n\t        }\n\t\n\t        if (this.playLengthCounter > 0) {\n\t\n\t            // Fetch next sample:\n\t            this.nextSample();\n\t\n\t            if (this.playLengthCounter === 0) {\n\t\n\t                // Last byte of sample fetched, generate IRQ:\n\t                if (this.playMode === this.MODE_IRQ) {\n\t\n\t                    // Generate IRQ:\n\t                    this.irqGenerated = true;\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    nextSample: function nextSample() {\n\t        // Fetch byte:\n\t        this.data = this.papu.nes.mmap.load(this.playAddress);\n\t        this.papu.nes.cpu.haltCycles(4);\n\t\n\t        this.playLengthCounter--;\n\t        this.playAddress++;\n\t        if (this.playAddress > 0xFFFF) {\n\t            this.playAddress = 0x8000;\n\t        }\n\t\n\t        this.hasSample = true;\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        if (address === 0x4010) {\n\t\n\t            // Play mode, DMA Frequency\n\t            if (value >> 6 === 0) {\n\t                this.playMode = this.MODE_NORMAL;\n\t            } else if ((value >> 6 & 1) === 1) {\n\t                this.playMode = this.MODE_LOOP;\n\t            } else if (value >> 6 === 2) {\n\t                this.playMode = this.MODE_IRQ;\n\t            }\n\t\n\t            if ((value & 0x80) === 0) {\n\t                this.irqGenerated = false;\n\t            }\n\t\n\t            this.dmaFrequency = this.papu.getDmcFrequency(value & 0xF);\n\t        } else if (address === 0x4011) {\n\t\n\t            // Delta counter load register:\n\t            this.deltaCounter = value >> 1 & 63;\n\t            this.dacLsb = value & 1;\n\t            this.sample = (this.deltaCounter << 1) + this.dacLsb; // update sample value\n\t        } else if (address === 0x4012) {\n\t\n\t            // DMA address load register\n\t            this.playStartAddress = value << 6 | 0x0C000;\n\t            this.playAddress = this.playStartAddress;\n\t            this.reg4012 = value;\n\t        } else if (address === 0x4013) {\n\t\n\t            // Length of play code\n\t            this.playLength = (value << 4) + 1;\n\t            this.playLengthCounter = this.playLength;\n\t            this.reg4013 = value;\n\t        } else if (address === 0x4015) {\n\t\n\t            // DMC/IRQ Status\n\t            if ((value >> 4 & 1) === 0) {\n\t                // Disable:\n\t                this.playLengthCounter = 0;\n\t            } else {\n\t                // Restart:\n\t                this.playAddress = this.playStartAddress;\n\t                this.playLengthCounter = this.playLength;\n\t            }\n\t            this.irqGenerated = false;\n\t        }\n\t    },\n\t\n\t    setEnabled: function setEnabled(value) {\n\t        if (!this.isEnabled && value) {\n\t            this.playLengthCounter = this.playLength;\n\t        }\n\t        this.isEnabled = value;\n\t    },\n\t\n\t    getLengthStatus: function getLengthStatus() {\n\t        return this.playLengthCounter === 0 || !this.isEnabled ? 0 : 1;\n\t    },\n\t\n\t    getIrqStatus: function getIrqStatus() {\n\t        return this.irqGenerated ? 1 : 0;\n\t    },\n\t\n\t    reset: function reset() {\n\t        this.isEnabled = false;\n\t        this.irqGenerated = false;\n\t        this.playMode = this.MODE_NORMAL;\n\t        this.dmaFrequency = 0;\n\t        this.dmaCounter = 0;\n\t        this.deltaCounter = 0;\n\t        this.playStartAddress = 0;\n\t        this.playAddress = 0;\n\t        this.playLength = 0;\n\t        this.playLengthCounter = 0;\n\t        this.sample = 0;\n\t        this.dacLsb = 0;\n\t        this.shiftCounter = 0;\n\t        this.reg4012 = 0;\n\t        this.reg4013 = 0;\n\t        this.data = 0;\n\t    }\n\t};\n\t\n\tPAPU.ChannelNoise = function (papu) {\n\t    this.papu = papu;\n\t\n\t    this.isEnabled = null;\n\t    this.envDecayDisable = null;\n\t    this.envDecayLoopEnable = null;\n\t    this.lengthCounterEnable = null;\n\t    this.envReset = null;\n\t    this.shiftNow = null;\n\t\n\t    this.lengthCounter = null;\n\t    this.progTimerCount = null;\n\t    this.progTimerMax = null;\n\t    this.envDecayRate = null;\n\t    this.envDecayCounter = null;\n\t    this.envVolume = null;\n\t    this.masterVolume = null;\n\t    this.shiftReg = 1 << 14;\n\t    this.randomBit = null;\n\t    this.randomMode = null;\n\t    this.sampleValue = null;\n\t    this.accValue = 0;\n\t    this.accCount = 1;\n\t    this.tmp = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.ChannelNoise.prototype = {\n\t    reset: function reset() {\n\t        this.progTimerCount = 0;\n\t        this.progTimerMax = 0;\n\t        this.isEnabled = false;\n\t        this.lengthCounter = 0;\n\t        this.lengthCounterEnable = false;\n\t        this.envDecayDisable = false;\n\t        this.envDecayLoopEnable = false;\n\t        this.shiftNow = false;\n\t        this.envDecayRate = 0;\n\t        this.envDecayCounter = 0;\n\t        this.envVolume = 0;\n\t        this.masterVolume = 0;\n\t        this.shiftReg = 1;\n\t        this.randomBit = 0;\n\t        this.randomMode = 0;\n\t        this.sampleValue = 0;\n\t        this.tmp = 0;\n\t    },\n\t\n\t    clockLengthCounter: function clockLengthCounter() {\n\t        if (this.lengthCounterEnable && this.lengthCounter > 0) {\n\t            this.lengthCounter--;\n\t            if (this.lengthCounter === 0) {\n\t                this.updateSampleValue();\n\t            }\n\t        }\n\t    },\n\t\n\t    clockEnvDecay: function clockEnvDecay() {\n\t        if (this.envReset) {\n\t            // Reset envelope:\n\t            this.envReset = false;\n\t            this.envDecayCounter = this.envDecayRate + 1;\n\t            this.envVolume = 0xF;\n\t        } else if (--this.envDecayCounter <= 0) {\n\t            // Normal handling:\n\t            this.envDecayCounter = this.envDecayRate + 1;\n\t            if (this.envVolume > 0) {\n\t                this.envVolume--;\n\t            } else {\n\t                this.envVolume = this.envDecayLoopEnable ? 0xF : 0;\n\t            }\n\t        }\n\t        this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n\t        this.updateSampleValue();\n\t    },\n\t\n\t    updateSampleValue: function updateSampleValue() {\n\t        if (this.isEnabled && this.lengthCounter > 0) {\n\t            this.sampleValue = this.randomBit * this.masterVolume;\n\t        }\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        if (address === 0x400C) {\n\t            // Volume/Envelope decay:\n\t            this.envDecayDisable = (value & 0x10) !== 0;\n\t            this.envDecayRate = value & 0xF;\n\t            this.envDecayLoopEnable = (value & 0x20) !== 0;\n\t            this.lengthCounterEnable = (value & 0x20) === 0;\n\t            this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n\t        } else if (address === 0x400E) {\n\t            // Programmable timer:\n\t            this.progTimerMax = this.papu.getNoiseWaveLength(value & 0xF);\n\t            this.randomMode = value >> 7;\n\t        } else if (address === 0x400F) {\n\t            // Length counter\n\t            this.lengthCounter = this.papu.getLengthMax(value & 248);\n\t            this.envReset = true;\n\t        }\n\t        // Update:\n\t        //updateSampleValue();\n\t    },\n\t\n\t    setEnabled: function setEnabled(value) {\n\t        this.isEnabled = value;\n\t        if (!value) {\n\t            this.lengthCounter = 0;\n\t        }\n\t        this.updateSampleValue();\n\t    },\n\t\n\t    getLengthStatus: function getLengthStatus() {\n\t        return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n\t    }\n\t};\n\t\n\tPAPU.ChannelSquare = function (papu, square1) {\n\t    this.papu = papu;\n\t\n\t    this.dutyLookup = [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1];\n\t    this.impLookup = [1, -1, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0];\n\t\n\t    this.sqr1 = square1;\n\t    this.isEnabled = null;\n\t    this.lengthCounterEnable = null;\n\t    this.sweepActive = null;\n\t    this.envDecayDisable = null;\n\t    this.envDecayLoopEnable = null;\n\t    this.envReset = null;\n\t    this.sweepCarry = null;\n\t    this.updateSweepPeriod = null;\n\t\n\t    this.progTimerCount = null;\n\t    this.progTimerMax = null;\n\t    this.lengthCounter = null;\n\t    this.squareCounter = null;\n\t    this.sweepCounter = null;\n\t    this.sweepCounterMax = null;\n\t    this.sweepMode = null;\n\t    this.sweepShiftAmount = null;\n\t    this.envDecayRate = null;\n\t    this.envDecayCounter = null;\n\t    this.envVolume = null;\n\t    this.masterVolume = null;\n\t    this.dutyMode = null;\n\t    this.sweepResult = null;\n\t    this.sampleValue = null;\n\t    this.vol = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.ChannelSquare.prototype = {\n\t    reset: function reset() {\n\t        this.progTimerCount = 0;\n\t        this.progTimerMax = 0;\n\t        this.lengthCounter = 0;\n\t        this.squareCounter = 0;\n\t        this.sweepCounter = 0;\n\t        this.sweepCounterMax = 0;\n\t        this.sweepMode = 0;\n\t        this.sweepShiftAmount = 0;\n\t        this.envDecayRate = 0;\n\t        this.envDecayCounter = 0;\n\t        this.envVolume = 0;\n\t        this.masterVolume = 0;\n\t        this.dutyMode = 0;\n\t        this.vol = 0;\n\t\n\t        this.isEnabled = false;\n\t        this.lengthCounterEnable = false;\n\t        this.sweepActive = false;\n\t        this.sweepCarry = false;\n\t        this.envDecayDisable = false;\n\t        this.envDecayLoopEnable = false;\n\t    },\n\t\n\t    clockLengthCounter: function clockLengthCounter() {\n\t        if (this.lengthCounterEnable && this.lengthCounter > 0) {\n\t            this.lengthCounter--;\n\t            if (this.lengthCounter === 0) {\n\t                this.updateSampleValue();\n\t            }\n\t        }\n\t    },\n\t\n\t    clockEnvDecay: function clockEnvDecay() {\n\t        if (this.envReset) {\n\t            // Reset envelope:\n\t            this.envReset = false;\n\t            this.envDecayCounter = this.envDecayRate + 1;\n\t            this.envVolume = 0xF;\n\t        } else if (--this.envDecayCounter <= 0) {\n\t            // Normal handling:\n\t            this.envDecayCounter = this.envDecayRate + 1;\n\t            if (this.envVolume > 0) {\n\t                this.envVolume--;\n\t            } else {\n\t                this.envVolume = this.envDecayLoopEnable ? 0xF : 0;\n\t            }\n\t        }\n\t\n\t        this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n\t        this.updateSampleValue();\n\t    },\n\t\n\t    clockSweep: function clockSweep() {\n\t        if (--this.sweepCounter <= 0) {\n\t\n\t            this.sweepCounter = this.sweepCounterMax + 1;\n\t            if (this.sweepActive && this.sweepShiftAmount > 0 && this.progTimerMax > 7) {\n\t\n\t                // Calculate result from shifter:\n\t                this.sweepCarry = false;\n\t                if (this.sweepMode === 0) {\n\t                    this.progTimerMax += this.progTimerMax >> this.sweepShiftAmount;\n\t                    if (this.progTimerMax > 4095) {\n\t                        this.progTimerMax = 4095;\n\t                        this.sweepCarry = true;\n\t                    }\n\t                } else {\n\t                    this.progTimerMax = this.progTimerMax - ((this.progTimerMax >> this.sweepShiftAmount) - (this.sqr1 ? 1 : 0));\n\t                }\n\t            }\n\t        }\n\t\n\t        if (this.updateSweepPeriod) {\n\t            this.updateSweepPeriod = false;\n\t            this.sweepCounter = this.sweepCounterMax + 1;\n\t        }\n\t    },\n\t\n\t    updateSampleValue: function updateSampleValue() {\n\t        if (this.isEnabled && this.lengthCounter > 0 && this.progTimerMax > 7) {\n\t\n\t            if (this.sweepMode === 0 && this.progTimerMax + (this.progTimerMax >> this.sweepShiftAmount) > 4095) {\n\t                //if (this.sweepCarry) {\n\t                this.sampleValue = 0;\n\t            } else {\n\t                this.sampleValue = this.masterVolume * this.dutyLookup[(this.dutyMode << 3) + this.squareCounter];\n\t            }\n\t        } else {\n\t            this.sampleValue = 0;\n\t        }\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        var addrAdd = this.sqr1 ? 0 : 4;\n\t        if (address === 0x4000 + addrAdd) {\n\t            // Volume/Envelope decay:\n\t            this.envDecayDisable = (value & 0x10) !== 0;\n\t            this.envDecayRate = value & 0xF;\n\t            this.envDecayLoopEnable = (value & 0x20) !== 0;\n\t            this.dutyMode = value >> 6 & 0x3;\n\t            this.lengthCounterEnable = (value & 0x20) === 0;\n\t            this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n\t            this.updateSampleValue();\n\t        } else if (address === 0x4001 + addrAdd) {\n\t            // Sweep:\n\t            this.sweepActive = (value & 0x80) !== 0;\n\t            this.sweepCounterMax = value >> 4 & 7;\n\t            this.sweepMode = value >> 3 & 1;\n\t            this.sweepShiftAmount = value & 7;\n\t            this.updateSweepPeriod = true;\n\t        } else if (address === 0x4002 + addrAdd) {\n\t            // Programmable timer:\n\t            this.progTimerMax &= 0x700;\n\t            this.progTimerMax |= value;\n\t        } else if (address === 0x4003 + addrAdd) {\n\t            // Programmable timer, length counter\n\t            this.progTimerMax &= 0xFF;\n\t            this.progTimerMax |= (value & 0x7) << 8;\n\t\n\t            if (this.isEnabled) {\n\t                this.lengthCounter = this.papu.getLengthMax(value & 0xF8);\n\t            }\n\t\n\t            this.envReset = true;\n\t        }\n\t    },\n\t\n\t    setEnabled: function setEnabled(value) {\n\t        this.isEnabled = value;\n\t        if (!value) {\n\t            this.lengthCounter = 0;\n\t        }\n\t        this.updateSampleValue();\n\t    },\n\t\n\t    getLengthStatus: function getLengthStatus() {\n\t        return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n\t    }\n\t};\n\t\n\tPAPU.ChannelTriangle = function (papu) {\n\t    this.papu = papu;\n\t\n\t    this.isEnabled = null;\n\t    this.sampleCondition = null;\n\t    this.lengthCounterEnable = null;\n\t    this.lcHalt = null;\n\t    this.lcControl = null;\n\t\n\t    this.progTimerCount = null;\n\t    this.progTimerMax = null;\n\t    this.triangleCounter = null;\n\t    this.lengthCounter = null;\n\t    this.linearCounter = null;\n\t    this.lcLoadValue = null;\n\t    this.sampleValue = null;\n\t    this.tmp = null;\n\t\n\t    this.reset();\n\t};\n\t\n\tPAPU.ChannelTriangle.prototype = {\n\t    reset: function reset() {\n\t        this.progTimerCount = 0;\n\t        this.progTimerMax = 0;\n\t        this.triangleCounter = 0;\n\t        this.isEnabled = false;\n\t        this.sampleCondition = false;\n\t        this.lengthCounter = 0;\n\t        this.lengthCounterEnable = false;\n\t        this.linearCounter = 0;\n\t        this.lcLoadValue = 0;\n\t        this.lcHalt = true;\n\t        this.lcControl = false;\n\t        this.tmp = 0;\n\t        this.sampleValue = 0xF;\n\t    },\n\t\n\t    clockLengthCounter: function clockLengthCounter() {\n\t        if (this.lengthCounterEnable && this.lengthCounter > 0) {\n\t            this.lengthCounter--;\n\t            if (this.lengthCounter === 0) {\n\t                this.updateSampleCondition();\n\t            }\n\t        }\n\t    },\n\t\n\t    clockLinearCounter: function clockLinearCounter() {\n\t        if (this.lcHalt) {\n\t            // Load:\n\t            this.linearCounter = this.lcLoadValue;\n\t            this.updateSampleCondition();\n\t        } else if (this.linearCounter > 0) {\n\t            // Decrement:\n\t            this.linearCounter--;\n\t            this.updateSampleCondition();\n\t        }\n\t        if (!this.lcControl) {\n\t            // Clear halt flag:\n\t            this.lcHalt = false;\n\t        }\n\t    },\n\t\n\t    getLengthStatus: function getLengthStatus() {\n\t        return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n\t    },\n\t\n\t    readReg: function readReg(address) {\n\t        return 0;\n\t    },\n\t\n\t    writeReg: function writeReg(address, value) {\n\t        if (address === 0x4008) {\n\t            // New values for linear counter:\n\t            this.lcControl = (value & 0x80) !== 0;\n\t            this.lcLoadValue = value & 0x7F;\n\t\n\t            // Length counter enable:\n\t            this.lengthCounterEnable = !this.lcControl;\n\t        } else if (address === 0x400A) {\n\t            // Programmable timer:\n\t            this.progTimerMax &= 0x700;\n\t            this.progTimerMax |= value;\n\t        } else if (address === 0x400B) {\n\t            // Programmable timer, length counter\n\t            this.progTimerMax &= 0xFF;\n\t            this.progTimerMax |= (value & 0x07) << 8;\n\t            this.lengthCounter = this.papu.getLengthMax(value & 0xF8);\n\t            this.lcHalt = true;\n\t        }\n\t\n\t        this.updateSampleCondition();\n\t    },\n\t\n\t    clockProgrammableTimer: function clockProgrammableTimer(nCycles) {\n\t        if (this.progTimerMax > 0) {\n\t            this.progTimerCount += nCycles;\n\t            while (this.progTimerMax > 0 && this.progTimerCount >= this.progTimerMax) {\n\t                this.progTimerCount -= this.progTimerMax;\n\t                if (this.isEnabled && this.lengthCounter > 0 && this.linearCounter > 0) {\n\t                    this.clockTriangleGenerator();\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    clockTriangleGenerator: function clockTriangleGenerator() {\n\t        this.triangleCounter++;\n\t        this.triangleCounter &= 0x1F;\n\t    },\n\t\n\t    setEnabled: function setEnabled(value) {\n\t        this.isEnabled = value;\n\t        if (!value) {\n\t            this.lengthCounter = 0;\n\t        }\n\t        this.updateSampleCondition();\n\t    },\n\t\n\t    updateSampleCondition: function updateSampleCondition() {\n\t        this.sampleCondition = this.isEnabled && this.progTimerMax > 7 && this.linearCounter > 0 && this.lengthCounter > 0;\n\t    }\n\t};\n\t\n\texports.default = PAPU;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _ppu = __webpack_require__(5);\n\t\n\tvar _ppu2 = _interopRequireDefault(_ppu);\n\t\n\tvar _mappers = __webpack_require__(8);\n\t\n\tvar _mappers2 = _interopRequireDefault(_mappers);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/*\n\tJSNES, based on Jamie Sanders' vNES\n\tCopyright (C) 2010 Ben Firshman\n\t\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\t\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\t\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t*/\n\t\n\t\n\tvar ROM = function ROM(nes) {\n\t    this.nes = nes;\n\t\n\t    this.mapperName = new Array(92);\n\t\n\t    for (var i = 0; i < 92; i++) {\n\t        this.mapperName[i] = \"Unknown Mapper\";\n\t    }\n\t    this.mapperName[0] = \"Direct Access\";\n\t    this.mapperName[1] = \"Nintendo MMC1\";\n\t    this.mapperName[2] = \"UNROM\";\n\t    this.mapperName[3] = \"CNROM\";\n\t    this.mapperName[4] = \"Nintendo MMC3\";\n\t    this.mapperName[5] = \"Nintendo MMC5\";\n\t    this.mapperName[6] = \"FFE F4xxx\";\n\t    this.mapperName[7] = \"AOROM\";\n\t    this.mapperName[8] = \"FFE F3xxx\";\n\t    this.mapperName[9] = \"Nintendo MMC2\";\n\t    this.mapperName[10] = \"Nintendo MMC4\";\n\t    this.mapperName[11] = \"Color Dreams Chip\";\n\t    this.mapperName[12] = \"FFE F6xxx\";\n\t    this.mapperName[15] = \"100-in-1 switch\";\n\t    this.mapperName[16] = \"Bandai chip\";\n\t    this.mapperName[17] = \"FFE F8xxx\";\n\t    this.mapperName[18] = \"Jaleco SS8806 chip\";\n\t    this.mapperName[19] = \"Namcot 106 chip\";\n\t    this.mapperName[20] = \"Famicom Disk System\";\n\t    this.mapperName[21] = \"Konami VRC4a\";\n\t    this.mapperName[22] = \"Konami VRC2a\";\n\t    this.mapperName[23] = \"Konami VRC2a\";\n\t    this.mapperName[24] = \"Konami VRC6\";\n\t    this.mapperName[25] = \"Konami VRC4b\";\n\t    this.mapperName[32] = \"Irem G-101 chip\";\n\t    this.mapperName[33] = \"Taito TC0190/TC0350\";\n\t    this.mapperName[34] = \"32kB ROM switch\";\n\t\n\t    this.mapperName[64] = \"Tengen RAMBO-1 chip\";\n\t    this.mapperName[65] = \"Irem H-3001 chip\";\n\t    this.mapperName[66] = \"GNROM switch\";\n\t    this.mapperName[67] = \"SunSoft3 chip\";\n\t    this.mapperName[68] = \"SunSoft4 chip\";\n\t    this.mapperName[69] = \"SunSoft5 FME-7 chip\";\n\t    this.mapperName[71] = \"Camerica chip\";\n\t    this.mapperName[78] = \"Irem 74HC161/32-based\";\n\t    this.mapperName[91] = \"Pirate HK-SF3 chip\";\n\t};\n\t\n\tROM.prototype = {\n\t    // Mirroring types:\n\t    VERTICAL_MIRRORING: 0,\n\t    HORIZONTAL_MIRRORING: 1,\n\t    FOURSCREEN_MIRRORING: 2,\n\t    SINGLESCREEN_MIRRORING: 3,\n\t    SINGLESCREEN_MIRRORING2: 4,\n\t    SINGLESCREEN_MIRRORING3: 5,\n\t    SINGLESCREEN_MIRRORING4: 6,\n\t    CHRROM_MIRRORING: 7,\n\t\n\t    header: null,\n\t    rom: null,\n\t    vrom: null,\n\t    vromTile: null,\n\t\n\t    romCount: null,\n\t    vromCount: null,\n\t    mirroring: null,\n\t    batteryRam: null,\n\t    trainer: null,\n\t    fourScreen: null,\n\t    mapperType: null,\n\t    valid: false,\n\t\n\t    load: function load(data) {\n\t        var i, j, v;\n\t\n\t        if (data.indexOf(\"NES\\x1a\") === -1) {\n\t            this.nes.ui.updateStatus(\"Not a valid NES ROM.\");\n\t            return;\n\t        }\n\t        this.header = new Array(16);\n\t        for (i = 0; i < 16; i++) {\n\t            this.header[i] = data.charCodeAt(i) & 0xFF;\n\t        }\n\t        this.romCount = this.header[4];\n\t        this.vromCount = this.header[5] * 2; // Get the number of 4kB banks, not 8kB\n\t        this.mirroring = (this.header[6] & 1) !== 0 ? 1 : 0;\n\t        this.batteryRam = (this.header[6] & 2) !== 0;\n\t        this.trainer = (this.header[6] & 4) !== 0;\n\t        this.fourScreen = (this.header[6] & 8) !== 0;\n\t        this.mapperType = this.header[6] >> 4 | this.header[7] & 0xF0;\n\t        /* TODO\n\t        if (this.batteryRam)\n\t            this.loadBatteryRam();*/\n\t        // Check whether byte 8-15 are zero's:\n\t        var foundError = false;\n\t        for (i = 8; i < 16; i++) {\n\t            if (this.header[i] !== 0) {\n\t                foundError = true;\n\t                break;\n\t            }\n\t        }\n\t        if (foundError) {\n\t            this.mapperType &= 0xF; // Ignore byte 7\n\t        }\n\t        // Load PRG-ROM banks:\n\t        this.rom = new Array(this.romCount);\n\t        var offset = 16;\n\t        for (i = 0; i < this.romCount; i++) {\n\t            this.rom[i] = new Array(16384);\n\t            for (j = 0; j < 16384; j++) {\n\t                if (offset + j >= data.length) {\n\t                    break;\n\t                }\n\t                this.rom[i][j] = data.charCodeAt(offset + j) & 0xFF;\n\t            }\n\t            offset += 16384;\n\t        }\n\t        // Load CHR-ROM banks:\n\t        this.vrom = new Array(this.vromCount);\n\t        for (i = 0; i < this.vromCount; i++) {\n\t            this.vrom[i] = new Array(4096);\n\t            for (j = 0; j < 4096; j++) {\n\t                if (offset + j >= data.length) {\n\t                    break;\n\t                }\n\t                this.vrom[i][j] = data.charCodeAt(offset + j) & 0xFF;\n\t            }\n\t            offset += 4096;\n\t        }\n\t\n\t        // Create VROM tiles:\n\t        this.vromTile = new Array(this.vromCount);\n\t        for (i = 0; i < this.vromCount; i++) {\n\t            this.vromTile[i] = new Array(256);\n\t            for (j = 0; j < 256; j++) {\n\t                this.vromTile[i][j] = new _ppu2.default.Tile();\n\t            }\n\t        }\n\t\n\t        // Convert CHR-ROM banks to tiles:\n\t        var tileIndex;\n\t        var leftOver;\n\t        for (v = 0; v < this.vromCount; v++) {\n\t            for (i = 0; i < 4096; i++) {\n\t                tileIndex = i >> 4;\n\t                leftOver = i % 16;\n\t                if (leftOver < 8) {\n\t                    this.vromTile[v][tileIndex].setScanline(leftOver, this.vrom[v][i], this.vrom[v][i + 8]);\n\t                } else {\n\t                    this.vromTile[v][tileIndex].setScanline(leftOver - 8, this.vrom[v][i - 8], this.vrom[v][i]);\n\t                }\n\t            }\n\t        }\n\t\n\t        this.valid = true;\n\t    },\n\t\n\t    getMirroringType: function getMirroringType() {\n\t        if (this.fourScreen) {\n\t            return this.FOURSCREEN_MIRRORING;\n\t        }\n\t        if (this.mirroring === 0) {\n\t            return this.HORIZONTAL_MIRRORING;\n\t        }\n\t        return this.VERTICAL_MIRRORING;\n\t    },\n\t\n\t    getMapperName: function getMapperName() {\n\t        if (this.mapperType >= 0 && this.mapperType < this.mapperName.length) {\n\t            return this.mapperName[this.mapperType];\n\t        }\n\t        return \"Unknown Mapper, \" + this.mapperType;\n\t    },\n\t\n\t    mapperSupported: function mapperSupported() {\n\t        return typeof _mappers2.default[this.mapperType] !== 'undefined';\n\t    },\n\t\n\t    createMapper: function createMapper() {\n\t        if (this.mapperSupported()) {\n\t            return new _mappers2.default[this.mapperType](this.nes);\n\t        } else {\n\t            this.nes.ui.updateStatus(\"This ROM uses a mapper not supported by JSNES: \" + this.getMapperName() + \"(\" + this.mapperType + \")\");\n\t            return null;\n\t        }\n\t    }\n\t};\n\t\n\texports.default = ROM;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Mappers = {}; /*\n\t                  JSNES, based on Jamie Sanders' vNES\n\t                  Copyright (C) 2010 Ben Firshman\n\t                  \n\t                  This program is free software: you can redistribute it and/or modify\n\t                  it under the terms of the GNU General Public License as published by\n\t                  the Free Software Foundation, either version 3 of the License, or\n\t                  (at your option) any later version.\n\t                  \n\t                  This program is distributed in the hope that it will be useful,\n\t                  but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t                  GNU General Public License for more details.\n\t                  \n\t                  You should have received a copy of the GNU General Public License\n\t                  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t                  */\n\t\n\tMappers[0] = function (nes) {\n\t    this.nes = nes;\n\t};\n\t\n\tMappers[0].prototype = {\n\t    reset: function reset() {\n\t        this.joy1StrobeState = 0;\n\t        this.joy2StrobeState = 0;\n\t        this.joypadLastWrite = 0;\n\t\n\t        this.mousePressed = false;\n\t        this.mouseX = null;\n\t        this.mouseY = null;\n\t    },\n\t\n\t    write: function write(address, value) {\n\t        if (address < 0x2000) {\n\t            // Mirroring of RAM:\n\t            this.nes.cpu.mem[address & 0x7FF] = value;\n\t        } else if (address > 0x4017) {\n\t            this.nes.cpu.mem[address] = value;\n\t            if (address >= 0x6000 && address < 0x8000) {\n\t                // Write to SaveRAM. Store in file:\n\t                // TODO: not yet\n\t                //if(this.nes.rom!=null)\n\t                //    this.nes.rom.writeBatteryRam(address,value);\n\t            }\n\t        } else if (address > 0x2007 && address < 0x4000) {\n\t            this.regWrite(0x2000 + (address & 0x7), value);\n\t        } else {\n\t            this.regWrite(address, value);\n\t        }\n\t    },\n\t\n\t    writelow: function writelow(address, value) {\n\t        if (address < 0x2000) {\n\t            // Mirroring of RAM:\n\t            this.nes.cpu.mem[address & 0x7FF] = value;\n\t        } else if (address > 0x4017) {\n\t            this.nes.cpu.mem[address] = value;\n\t        } else if (address > 0x2007 && address < 0x4000) {\n\t            this.regWrite(0x2000 + (address & 0x7), value);\n\t        } else {\n\t            this.regWrite(address, value);\n\t        }\n\t    },\n\t\n\t    load: function load(address) {\n\t        // Wrap around:\n\t        address &= 0xFFFF;\n\t\n\t        // Check address range:\n\t        if (address > 0x4017) {\n\t            // ROM:\n\t            return this.nes.cpu.mem[address];\n\t        } else if (address >= 0x2000) {\n\t            // I/O Ports.\n\t            return this.regLoad(address);\n\t        } else {\n\t            // RAM (mirrored)\n\t            return this.nes.cpu.mem[address & 0x7FF];\n\t        }\n\t    },\n\t\n\t    regLoad: function regLoad(address) {\n\t        switch (address >> 12) {// use fourth nibble (0xF000)\n\t            case 0:\n\t                break;\n\t\n\t            case 1:\n\t                break;\n\t\n\t            case 2:\n\t            // Fall through to case 3\n\t            case 3:\n\t                // PPU Registers\n\t                switch (address & 0x7) {\n\t                    case 0x0:\n\t                        // 0x2000:\n\t                        // PPU Control Register 1.\n\t                        // (the value is stored both\n\t                        // in main memory and in the\n\t                        // PPU as flags):\n\t                        // (not in the real NES)\n\t                        return this.nes.cpu.mem[0x2000];\n\t\n\t                    case 0x1:\n\t                        // 0x2001:\n\t                        // PPU Control Register 2.\n\t                        // (the value is stored both\n\t                        // in main memory and in the\n\t                        // PPU as flags):\n\t                        // (not in the real NES)\n\t                        return this.nes.cpu.mem[0x2001];\n\t\n\t                    case 0x2:\n\t                        // 0x2002:\n\t                        // PPU Status Register.\n\t                        // The value is stored in\n\t                        // main memory in addition\n\t                        // to as flags in the PPU.\n\t                        // (not in the real NES)\n\t                        return this.nes.ppu.readStatusRegister();\n\t\n\t                    case 0x3:\n\t                        return 0;\n\t\n\t                    case 0x4:\n\t                        // 0x2004:\n\t                        // Sprite Memory read.\n\t                        return this.nes.ppu.sramLoad();\n\t                    case 0x5:\n\t                        return 0;\n\t\n\t                    case 0x6:\n\t                        return 0;\n\t\n\t                    case 0x7:\n\t                        // 0x2007:\n\t                        // VRAM read:\n\t                        return this.nes.ppu.vramLoad();\n\t                }\n\t                break;\n\t            case 4:\n\t                // Sound+Joypad registers\n\t                switch (address - 0x4015) {\n\t                    case 0:\n\t                        // 0x4015:\n\t                        // Sound channel enable, DMC Status\n\t                        return this.nes.papu.readReg(address);\n\t\n\t                    case 1:\n\t                        // 0x4016:\n\t                        // Joystick 1 + Strobe\n\t                        return this.joy1Read();\n\t\n\t                    case 2:\n\t                        // 0x4017:\n\t                        // Joystick 2 + Strobe\n\t                        if (this.mousePressed) {\n\t\n\t                            // Check for white pixel nearby:\n\t                            var sx = Math.max(0, this.mouseX - 4);\n\t                            var ex = Math.min(256, this.mouseX + 4);\n\t                            var sy = Math.max(0, this.mouseY - 4);\n\t                            var ey = Math.min(240, this.mouseY + 4);\n\t                            var w = 0;\n\t\n\t                            for (var y = sy; y < ey; y++) {\n\t                                for (var x = sx; x < ex; x++) {\n\t\n\t                                    if (this.nes.ppu.buffer[(y << 8) + x] == 0xFFFFFF) {\n\t                                        w |= 0x1 << 3;\n\t                                        console.debug(\"Clicked on white!\");\n\t                                        break;\n\t                                    }\n\t                                }\n\t                            }\n\t\n\t                            w |= this.mousePressed ? 0x1 << 4 : 0;\n\t                            return (this.joy2Read() | w) & 0xFFFF;\n\t                        } else {\n\t                            return this.joy2Read();\n\t                        }\n\t\n\t                }\n\t                break;\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    regWrite: function regWrite(address, value) {\n\t        switch (address) {\n\t            case 0x2000:\n\t                // PPU Control register 1\n\t                this.nes.cpu.mem[address] = value;\n\t                this.nes.ppu.updateControlReg1(value);\n\t                break;\n\t\n\t            case 0x2001:\n\t                // PPU Control register 2\n\t                this.nes.cpu.mem[address] = value;\n\t                this.nes.ppu.updateControlReg2(value);\n\t                break;\n\t\n\t            case 0x2003:\n\t                // Set Sprite RAM address:\n\t                this.nes.ppu.writeSRAMAddress(value);\n\t                break;\n\t\n\t            case 0x2004:\n\t                // Write to Sprite RAM:\n\t                this.nes.ppu.sramWrite(value);\n\t                break;\n\t\n\t            case 0x2005:\n\t                // Screen Scroll offsets:\n\t                this.nes.ppu.scrollWrite(value);\n\t                break;\n\t\n\t            case 0x2006:\n\t                // Set VRAM address:\n\t                this.nes.ppu.writeVRAMAddress(value);\n\t                break;\n\t\n\t            case 0x2007:\n\t                // Write to VRAM:\n\t                this.nes.ppu.vramWrite(value);\n\t                break;\n\t\n\t            case 0x4014:\n\t                // Sprite Memory DMA Access\n\t                this.nes.ppu.sramDMA(value);\n\t                break;\n\t\n\t            case 0x4015:\n\t                // Sound Channel Switch, DMC Status\n\t                this.nes.papu.writeReg(address, value);\n\t                break;\n\t\n\t            case 0x4016:\n\t                // Joystick 1 + Strobe\n\t                if ((value & 1) === 0 && (this.joypadLastWrite & 1) === 1) {\n\t                    this.joy1StrobeState = 0;\n\t                    this.joy2StrobeState = 0;\n\t                }\n\t                this.joypadLastWrite = value;\n\t                break;\n\t\n\t            case 0x4017:\n\t                // Sound channel frame sequencer:\n\t                this.nes.papu.writeReg(address, value);\n\t                break;\n\t\n\t            default:\n\t                // Sound registers\n\t                ////System.out.println(\"write to sound reg\");\n\t                if (address >= 0x4000 && address <= 0x4017) {\n\t                    this.nes.papu.writeReg(address, value);\n\t                }\n\t\n\t        }\n\t    },\n\t\n\t    joy1Read: function joy1Read() {\n\t        var ret;\n\t\n\t        switch (this.joy1StrobeState) {\n\t            case 0:\n\t            case 1:\n\t            case 2:\n\t            case 3:\n\t            case 4:\n\t            case 5:\n\t            case 6:\n\t            case 7:\n\t                ret = this.nes.controllers.state1[this.joy1StrobeState];\n\t                break;\n\t            case 8:\n\t            case 9:\n\t            case 10:\n\t            case 11:\n\t            case 12:\n\t            case 13:\n\t            case 14:\n\t            case 15:\n\t            case 16:\n\t            case 17:\n\t            case 18:\n\t                ret = 0;\n\t                break;\n\t            case 19:\n\t                ret = 1;\n\t                break;\n\t            default:\n\t                ret = 0;\n\t        }\n\t\n\t        this.joy1StrobeState++;\n\t        if (this.joy1StrobeState == 24) {\n\t            this.joy1StrobeState = 0;\n\t        }\n\t\n\t        return ret;\n\t    },\n\t\n\t    joy2Read: function joy2Read() {\n\t        var ret;\n\t\n\t        switch (this.joy2StrobeState) {\n\t            case 0:\n\t            case 1:\n\t            case 2:\n\t            case 3:\n\t            case 4:\n\t            case 5:\n\t            case 6:\n\t            case 7:\n\t                ret = this.nes.controllers.state2[this.joy2StrobeState];\n\t                break;\n\t            case 8:\n\t            case 9:\n\t            case 10:\n\t            case 11:\n\t            case 12:\n\t            case 13:\n\t            case 14:\n\t            case 15:\n\t            case 16:\n\t            case 17:\n\t            case 18:\n\t                ret = 0;\n\t                break;\n\t            case 19:\n\t                ret = 1;\n\t                break;\n\t            default:\n\t                ret = 0;\n\t        }\n\t\n\t        this.joy2StrobeState++;\n\t        if (this.joy2StrobeState == 24) {\n\t            this.joy2StrobeState = 0;\n\t        }\n\t\n\t        return ret;\n\t    },\n\t\n\t    loadROM: function loadROM() {\n\t        if (!this.nes.rom.valid || this.nes.rom.romCount < 1) {\n\t            alert(\"NoMapper: Invalid ROM! Unable to load.\");\n\t            return;\n\t        }\n\t\n\t        // Load ROM into memory:\n\t        this.loadPRGROM();\n\t\n\t        // Load CHR-ROM:\n\t        this.loadCHRROM();\n\t\n\t        // Load Battery RAM (if present):\n\t        this.loadBatteryRam();\n\t\n\t        // Reset IRQ:\n\t        //nes.getCpu().doResetInterrupt();\n\t        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n\t    },\n\t\n\t    loadPRGROM: function loadPRGROM() {\n\t        if (this.nes.rom.romCount > 1) {\n\t            // Load the two first banks into memory.\n\t            this.loadRomBank(0, 0x8000);\n\t            this.loadRomBank(1, 0xC000);\n\t        } else {\n\t            // Load the one bank into both memory locations:\n\t            this.loadRomBank(0, 0x8000);\n\t            this.loadRomBank(0, 0xC000);\n\t        }\n\t    },\n\t\n\t    loadCHRROM: function loadCHRROM() {\n\t        ////System.out.println(\"Loading CHR ROM..\");\n\t        if (this.nes.rom.vromCount > 0) {\n\t            if (this.nes.rom.vromCount == 1) {\n\t                this.loadVromBank(0, 0x0000);\n\t                this.loadVromBank(0, 0x1000);\n\t            } else {\n\t                this.loadVromBank(0, 0x0000);\n\t                this.loadVromBank(1, 0x1000);\n\t            }\n\t        } else {\n\t            //System.out.println(\"There aren't any CHR-ROM banks..\");\n\t        }\n\t    },\n\t\n\t    loadBatteryRam: function loadBatteryRam() {\n\t        if (this.nes.rom.batteryRam) {\n\t            var ram = this.nes.rom.batteryRam;\n\t            if (ram !== null && ram.length == 0x2000) {\n\t                // Load Battery RAM into memory:\n\t                _utils2.default.copyArrayElements(ram, 0, this.nes.cpu.mem, 0x6000, 0x2000);\n\t            }\n\t        }\n\t    },\n\t\n\t    loadRomBank: function loadRomBank(bank, address) {\n\t        // Loads a ROM bank into the specified address.\n\t        bank %= this.nes.rom.romCount;\n\t        //var data = this.nes.rom.rom[bank];\n\t        //cpuMem.write(address,data,data.length);\n\t        _utils2.default.copyArrayElements(this.nes.rom.rom[bank], 0, this.nes.cpu.mem, address, 16384);\n\t    },\n\t\n\t    loadVromBank: function loadVromBank(bank, address) {\n\t        if (this.nes.rom.vromCount === 0) {\n\t            return;\n\t        }\n\t        this.nes.ppu.triggerRendering();\n\t\n\t        _utils2.default.copyArrayElements(this.nes.rom.vrom[bank % this.nes.rom.vromCount], 0, this.nes.ppu.vramMem, address, 4096);\n\t\n\t        var vromTile = this.nes.rom.vromTile[bank % this.nes.rom.vromCount];\n\t        _utils2.default.copyArrayElements(vromTile, 0, this.nes.ppu.ptTile, address >> 4, 256);\n\t    },\n\t\n\t    load32kRomBank: function load32kRomBank(bank, address) {\n\t        this.loadRomBank(bank * 2 % this.nes.rom.romCount, address);\n\t        this.loadRomBank((bank * 2 + 1) % this.nes.rom.romCount, address + 16384);\n\t    },\n\t\n\t    load8kVromBank: function load8kVromBank(bank4kStart, address) {\n\t        if (this.nes.rom.vromCount === 0) {\n\t            return;\n\t        }\n\t        this.nes.ppu.triggerRendering();\n\t\n\t        this.loadVromBank(bank4kStart % this.nes.rom.vromCount, address);\n\t        this.loadVromBank((bank4kStart + 1) % this.nes.rom.vromCount, address + 4096);\n\t    },\n\t\n\t    load1kVromBank: function load1kVromBank(bank1k, address) {\n\t        if (this.nes.rom.vromCount === 0) {\n\t            return;\n\t        }\n\t        this.nes.ppu.triggerRendering();\n\t\n\t        var bank4k = Math.floor(bank1k / 4) % this.nes.rom.vromCount;\n\t        var bankoffset = bank1k % 4 * 1024;\n\t        _utils2.default.copyArrayElements(this.nes.rom.vrom[bank4k], 0, this.nes.ppu.vramMem, bankoffset, 1024);\n\t\n\t        // Update tiles:\n\t        var vromTile = this.nes.rom.vromTile[bank4k];\n\t        var baseIndex = address >> 4;\n\t        for (var i = 0; i < 64; i++) {\n\t            this.nes.ppu.ptTile[baseIndex + i] = vromTile[(bank1k % 4 << 6) + i];\n\t        }\n\t    },\n\t\n\t    load2kVromBank: function load2kVromBank(bank2k, address) {\n\t        if (this.nes.rom.vromCount === 0) {\n\t            return;\n\t        }\n\t        this.nes.ppu.triggerRendering();\n\t\n\t        var bank4k = Math.floor(bank2k / 2) % this.nes.rom.vromCount;\n\t        var bankoffset = bank2k % 2 * 2048;\n\t        _utils2.default.copyArrayElements(this.nes.rom.vrom[bank4k], bankoffset, this.nes.ppu.vramMem, address, 2048);\n\t\n\t        // Update tiles:\n\t        var vromTile = this.nes.rom.vromTile[bank4k];\n\t        var baseIndex = address >> 4;\n\t        for (var i = 0; i < 128; i++) {\n\t            this.nes.ppu.ptTile[baseIndex + i] = vromTile[(bank2k % 2 << 7) + i];\n\t        }\n\t    },\n\t\n\t    load8kRomBank: function load8kRomBank(bank8k, address) {\n\t        var bank16k = Math.floor(bank8k / 2) % this.nes.rom.romCount;\n\t        var offset = bank8k % 2 * 8192;\n\t\n\t        //this.nes.cpu.mem.write(address,this.nes.rom.rom[bank16k],offset,8192);\n\t        _utils2.default.copyArrayElements(this.nes.rom.rom[bank16k], offset, this.nes.cpu.mem, address, 8192);\n\t    },\n\t\n\t    clockIrqCounter: function clockIrqCounter() {\n\t        // Does nothing. This is used by the MMC3 mapper.\n\t    },\n\t\n\t    latchAccess: function latchAccess(address) {\n\t        // Does nothing. This is used by MMC2.\n\t    },\n\t\n\t    toJSON: function toJSON() {\n\t        return {\n\t            'joy1StrobeState': this.joy1StrobeState,\n\t            'joy2StrobeState': this.joy2StrobeState,\n\t            'joypadLastWrite': this.joypadLastWrite\n\t        };\n\t    },\n\t\n\t    fromJSON: function fromJSON(s) {\n\t        this.joy1StrobeState = s.joy1StrobeState;\n\t        this.joy2StrobeState = s.joy2StrobeState;\n\t        this.joypadLastWrite = s.joypadLastWrite;\n\t    }\n\t};\n\t\n\tMappers[1] = function (nes) {\n\t    this.nes = nes;\n\t};\n\t\n\tMappers[1].prototype = new Mappers[0]();\n\t\n\tMappers[1].prototype.reset = function () {\n\t    Mappers[0].prototype.reset.apply(this);\n\t\n\t    // 5-bit buffer:\n\t    this.regBuffer = 0;\n\t    this.regBufferCounter = 0;\n\t\n\t    // Register 0:\n\t    this.mirroring = 0;\n\t    this.oneScreenMirroring = 0;\n\t    this.prgSwitchingArea = 1;\n\t    this.prgSwitchingSize = 1;\n\t    this.vromSwitchingSize = 0;\n\t\n\t    // Register 1:\n\t    this.romSelectionReg0 = 0;\n\t\n\t    // Register 2:\n\t    this.romSelectionReg1 = 0;\n\t\n\t    // Register 3:\n\t    this.romBankSelect = 0;\n\t};\n\t\n\tMappers[1].prototype.write = function (address, value) {\n\t    // Writes to addresses other than MMC registers are handled by NoMapper.\n\t    if (address < 0x8000) {\n\t        Mappers[0].prototype.write.apply(this, arguments);\n\t        return;\n\t    }\n\t\n\t    // See what should be done with the written value:\n\t    if ((value & 128) !== 0) {\n\t\n\t        // Reset buffering:\n\t        this.regBufferCounter = 0;\n\t        this.regBuffer = 0;\n\t\n\t        // Reset register:\n\t        if (this.getRegNumber(address) === 0) {\n\t\n\t            this.prgSwitchingArea = 1;\n\t            this.prgSwitchingSize = 1;\n\t        }\n\t    } else {\n\t\n\t        // Continue buffering:\n\t        //regBuffer = (regBuffer & (0xFF-(1<<regBufferCounter))) | ((value & (1<<regBufferCounter))<<regBufferCounter);\n\t        this.regBuffer = this.regBuffer & 0xFF - (1 << this.regBufferCounter) | (value & 1) << this.regBufferCounter;\n\t        this.regBufferCounter++;\n\t\n\t        if (this.regBufferCounter == 5) {\n\t            // Use the buffered value:\n\t            this.setReg(this.getRegNumber(address), this.regBuffer);\n\t\n\t            // Reset buffer:\n\t            this.regBuffer = 0;\n\t            this.regBufferCounter = 0;\n\t        }\n\t    }\n\t};\n\t\n\tMappers[1].prototype.setReg = function (reg, value) {\n\t    var tmp;\n\t\n\t    switch (reg) {\n\t        case 0:\n\t            // Mirroring:\n\t            tmp = value & 3;\n\t            if (tmp !== this.mirroring) {\n\t                // Set mirroring:\n\t                this.mirroring = tmp;\n\t                if ((this.mirroring & 2) === 0) {\n\t                    // SingleScreen mirroring overrides the other setting:\n\t                    this.nes.ppu.setMirroring(this.nes.rom.SINGLESCREEN_MIRRORING);\n\t                }\n\t                // Not overridden by SingleScreen mirroring.\n\t                else if ((this.mirroring & 1) !== 0) {\n\t                        this.nes.ppu.setMirroring(this.nes.rom.HORIZONTAL_MIRRORING);\n\t                    } else {\n\t                        this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n\t                    }\n\t            }\n\t\n\t            // PRG Switching Area;\n\t            this.prgSwitchingArea = value >> 2 & 1;\n\t\n\t            // PRG Switching Size:\n\t            this.prgSwitchingSize = value >> 3 & 1;\n\t\n\t            // VROM Switching Size:\n\t            this.vromSwitchingSize = value >> 4 & 1;\n\t\n\t            break;\n\t\n\t        case 1:\n\t            // ROM selection:\n\t            this.romSelectionReg0 = value >> 4 & 1;\n\t\n\t            // Check whether the cart has VROM:\n\t            if (this.nes.rom.vromCount > 0) {\n\t\n\t                // Select VROM bank at 0x0000:\n\t                if (this.vromSwitchingSize === 0) {\n\t\n\t                    // Swap 8kB VROM:\n\t                    if (this.romSelectionReg0 === 0) {\n\t                        this.load8kVromBank(value & 0xF, 0x0000);\n\t                    } else {\n\t                        this.load8kVromBank(Math.floor(this.nes.rom.vromCount / 2) + (value & 0xF), 0x0000);\n\t                    }\n\t                } else {\n\t                    // Swap 4kB VROM:\n\t                    if (this.romSelectionReg0 === 0) {\n\t                        this.loadVromBank(value & 0xF, 0x0000);\n\t                    } else {\n\t                        this.loadVromBank(Math.floor(this.nes.rom.vromCount / 2) + (value & 0xF), 0x0000);\n\t                    }\n\t                }\n\t            }\n\t\n\t            break;\n\t\n\t        case 2:\n\t            // ROM selection:\n\t            this.romSelectionReg1 = value >> 4 & 1;\n\t\n\t            // Check whether the cart has VROM:\n\t            if (this.nes.rom.vromCount > 0) {\n\t\n\t                // Select VROM bank at 0x1000:\n\t                if (this.vromSwitchingSize === 1) {\n\t                    // Swap 4kB of VROM:\n\t                    if (this.romSelectionReg1 === 0) {\n\t                        this.loadVromBank(value & 0xF, 0x1000);\n\t                    } else {\n\t                        this.loadVromBank(Math.floor(this.nes.rom.vromCount / 2) + (value & 0xF), 0x1000);\n\t                    }\n\t                }\n\t            }\n\t            break;\n\t\n\t        default:\n\t            // Select ROM bank:\n\t            // -------------------------\n\t            tmp = value & 0xF;\n\t            var bank;\n\t            var baseBank = 0;\n\t\n\t            if (this.nes.rom.romCount >= 32) {\n\t                // 1024 kB cart\n\t                if (this.vromSwitchingSize === 0) {\n\t                    if (this.romSelectionReg0 === 1) {\n\t                        baseBank = 16;\n\t                    }\n\t                } else {\n\t                    baseBank = (this.romSelectionReg0 | this.romSelectionReg1 << 1) << 3;\n\t                }\n\t            } else if (this.nes.rom.romCount >= 16) {\n\t                // 512 kB cart\n\t                if (this.romSelectionReg0 === 1) {\n\t                    baseBank = 8;\n\t                }\n\t            }\n\t\n\t            if (this.prgSwitchingSize === 0) {\n\t                // 32kB\n\t                bank = baseBank + (value & 0xF);\n\t                this.load32kRomBank(bank, 0x8000);\n\t            } else {\n\t                // 16kB\n\t                bank = baseBank * 2 + (value & 0xF);\n\t                if (this.prgSwitchingArea === 0) {\n\t                    this.loadRomBank(bank, 0xC000);\n\t                } else {\n\t                    this.loadRomBank(bank, 0x8000);\n\t                }\n\t            }\n\t    }\n\t};\n\t\n\t// Returns the register number from the address written to:\n\tMappers[1].prototype.getRegNumber = function (address) {\n\t    if (address >= 0x8000 && address <= 0x9FFF) {\n\t        return 0;\n\t    } else if (address >= 0xA000 && address <= 0xBFFF) {\n\t        return 1;\n\t    } else if (address >= 0xC000 && address <= 0xDFFF) {\n\t        return 2;\n\t    } else {\n\t        return 3;\n\t    }\n\t};\n\t\n\tMappers[1].prototype.loadROM = function (rom) {\n\t    if (!this.nes.rom.valid) {\n\t        alert(\"MMC1: Invalid ROM! Unable to load.\");\n\t        return;\n\t    }\n\t\n\t    // Load PRG-ROM:\n\t    this.loadRomBank(0, 0x8000); //   First ROM bank..\n\t    this.loadRomBank(this.nes.rom.romCount - 1, 0xC000); // ..and last ROM bank.\n\t\n\t    // Load CHR-ROM:\n\t    this.loadCHRROM();\n\t\n\t    // Load Battery RAM (if present):\n\t    this.loadBatteryRam();\n\t\n\t    // Do Reset-Interrupt:\n\t    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n\t};\n\t\n\tMappers[1].prototype.switchLowHighPrgRom = function (oldSetting) {\n\t    // not yet.\n\t};\n\t\n\tMappers[1].prototype.switch16to32 = function () {\n\t    // not yet.\n\t};\n\t\n\tMappers[1].prototype.switch32to16 = function () {\n\t    // not yet.\n\t};\n\t\n\tMappers[1].prototype.toJSON = function () {\n\t    var s = Mappers[0].prototype.toJSON.apply(this);\n\t    s.mirroring = this.mirroring;\n\t    s.oneScreenMirroring = this.oneScreenMirroring;\n\t    s.prgSwitchingArea = this.prgSwitchingArea;\n\t    s.prgSwitchingSize = this.prgSwitchingSize;\n\t    s.vromSwitchingSize = this.vromSwitchingSize;\n\t    s.romSelectionReg0 = this.romSelectionReg0;\n\t    s.romSelectionReg1 = this.romSelectionReg1;\n\t    s.romBankSelect = this.romBankSelect;\n\t    s.regBuffer = this.regBuffer;\n\t    s.regBufferCounter = this.regBufferCounter;\n\t    return s;\n\t};\n\t\n\tMappers[1].prototype.fromJSON = function (s) {\n\t    Mappers[0].prototype.fromJSON.apply(this, s);\n\t    this.mirroring = s.mirroring;\n\t    this.oneScreenMirroring = s.oneScreenMirroring;\n\t    this.prgSwitchingArea = s.prgSwitchingArea;\n\t    this.prgSwitchingSize = s.prgSwitchingSize;\n\t    this.vromSwitchingSize = s.vromSwitchingSize;\n\t    this.romSelectionReg0 = s.romSelectionReg0;\n\t    this.romSelectionReg1 = s.romSelectionReg1;\n\t    this.romBankSelect = s.romBankSelect;\n\t    this.regBuffer = s.regBuffer;\n\t    this.regBufferCounter = s.regBufferCounter;\n\t};\n\t\n\tMappers[2] = function (nes) {\n\t    this.nes = nes;\n\t};\n\t\n\tMappers[2].prototype = new Mappers[0]();\n\t\n\tMappers[2].prototype.write = function (address, value) {\n\t    // Writes to addresses other than MMC registers are handled by NoMapper.\n\t    if (address < 0x8000) {\n\t        Mappers[0].prototype.write.apply(this, arguments);\n\t        return;\n\t    } else {\n\t        // This is a ROM bank select command.\n\t        // Swap in the given ROM bank at 0x8000:\n\t        this.loadRomBank(value, 0x8000);\n\t    }\n\t};\n\t\n\tMappers[2].prototype.loadROM = function (rom) {\n\t    if (!this.nes.rom.valid) {\n\t        alert(\"UNROM: Invalid ROM! Unable to load.\");\n\t        return;\n\t    }\n\t\n\t    // Load PRG-ROM:\n\t    this.loadRomBank(0, 0x8000);\n\t    this.loadRomBank(this.nes.rom.romCount - 1, 0xC000);\n\t\n\t    // Load CHR-ROM:\n\t    this.loadCHRROM();\n\t\n\t    // Do Reset-Interrupt:\n\t    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n\t};\n\t\n\tMappers[4] = function (nes) {\n\t    this.nes = nes;\n\t\n\t    this.CMD_SEL_2_1K_VROM_0000 = 0;\n\t    this.CMD_SEL_2_1K_VROM_0800 = 1;\n\t    this.CMD_SEL_1K_VROM_1000 = 2;\n\t    this.CMD_SEL_1K_VROM_1400 = 3;\n\t    this.CMD_SEL_1K_VROM_1800 = 4;\n\t    this.CMD_SEL_1K_VROM_1C00 = 5;\n\t    this.CMD_SEL_ROM_PAGE1 = 6;\n\t    this.CMD_SEL_ROM_PAGE2 = 7;\n\t\n\t    this.command = null;\n\t    this.prgAddressSelect = null;\n\t    this.chrAddressSelect = null;\n\t    this.pageNumber = null;\n\t    this.irqCounter = null;\n\t    this.irqLatchValue = null;\n\t    this.irqEnable = null;\n\t    this.prgAddressChanged = false;\n\t};\n\t\n\tMappers[4].prototype = new Mappers[0]();\n\t\n\tMappers[4].prototype.write = function (address, value) {\n\t    // Writes to addresses other than MMC registers are handled by NoMapper.\n\t    if (address < 0x8000) {\n\t        Mappers[0].prototype.write.apply(this, arguments);\n\t        return;\n\t    }\n\t\n\t    switch (address) {\n\t        case 0x8000:\n\t            // Command/Address Select register\n\t            this.command = value & 7;\n\t            var tmp = value >> 6 & 1;\n\t            if (tmp != this.prgAddressSelect) {\n\t                this.prgAddressChanged = true;\n\t            }\n\t            this.prgAddressSelect = tmp;\n\t            this.chrAddressSelect = value >> 7 & 1;\n\t            break;\n\t\n\t        case 0x8001:\n\t            // Page number for command\n\t            this.executeCommand(this.command, value);\n\t            break;\n\t\n\t        case 0xA000:\n\t            // Mirroring select\n\t            if ((value & 1) !== 0) {\n\t                this.nes.ppu.setMirroring(this.nes.rom.HORIZONTAL_MIRRORING);\n\t            } else {\n\t                this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n\t            }\n\t            break;\n\t\n\t        case 0xA001:\n\t            // SaveRAM Toggle\n\t            // TODO\n\t            //nes.getRom().setSaveState((value&1)!=0);\n\t            break;\n\t\n\t        case 0xC000:\n\t            // IRQ Counter register\n\t            this.irqCounter = value;\n\t            //nes.ppu.mapperIrqCounter = 0;\n\t            break;\n\t\n\t        case 0xC001:\n\t            // IRQ Latch register\n\t            this.irqLatchValue = value;\n\t            break;\n\t\n\t        case 0xE000:\n\t            // IRQ Control Reg 0 (disable)\n\t            //irqCounter = irqLatchValue;\n\t            this.irqEnable = 0;\n\t            break;\n\t\n\t        case 0xE001:\n\t            // IRQ Control Reg 1 (enable)\n\t            this.irqEnable = 1;\n\t            break;\n\t\n\t        default:\n\t        // Not a MMC3 register.\n\t        // The game has probably crashed,\n\t        // since it tries to write to ROM..\n\t        // IGNORE.\n\t    }\n\t};\n\t\n\tMappers[4].prototype.executeCommand = function (cmd, arg) {\n\t    switch (cmd) {\n\t        case this.CMD_SEL_2_1K_VROM_0000:\n\t            // Select 2 1KB VROM pages at 0x0000:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x0000);\n\t                this.load1kVromBank(arg + 1, 0x0400);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x1000);\n\t                this.load1kVromBank(arg + 1, 0x1400);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_2_1K_VROM_0800:\n\t            // Select 2 1KB VROM pages at 0x0800:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x0800);\n\t                this.load1kVromBank(arg + 1, 0x0C00);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x1800);\n\t                this.load1kVromBank(arg + 1, 0x1C00);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_1K_VROM_1000:\n\t            // Select 1K VROM Page at 0x1000:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x1000);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x0000);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_1K_VROM_1400:\n\t            // Select 1K VROM Page at 0x1400:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x1400);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x0400);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_1K_VROM_1800:\n\t            // Select 1K VROM Page at 0x1800:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x1800);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x0800);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_1K_VROM_1C00:\n\t            // Select 1K VROM Page at 0x1C00:\n\t            if (this.chrAddressSelect === 0) {\n\t                this.load1kVromBank(arg, 0x1C00);\n\t            } else {\n\t                this.load1kVromBank(arg, 0x0C00);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_ROM_PAGE1:\n\t            if (this.prgAddressChanged) {\n\t                // Load the two hardwired banks:\n\t                if (this.prgAddressSelect === 0) {\n\t                    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xC000);\n\t                } else {\n\t                    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0x8000);\n\t                }\n\t                this.prgAddressChanged = false;\n\t            }\n\t\n\t            // Select first switchable ROM page:\n\t            if (this.prgAddressSelect === 0) {\n\t                this.load8kRomBank(arg, 0x8000);\n\t            } else {\n\t                this.load8kRomBank(arg, 0xC000);\n\t            }\n\t            break;\n\t\n\t        case this.CMD_SEL_ROM_PAGE2:\n\t            // Select second switchable ROM page:\n\t            this.load8kRomBank(arg, 0xA000);\n\t\n\t            // hardwire appropriate bank:\n\t            if (this.prgAddressChanged) {\n\t                // Load the two hardwired banks:\n\t                if (this.prgAddressSelect === 0) {\n\t                    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xC000);\n\t                } else {\n\t                    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0x8000);\n\t                }\n\t                this.prgAddressChanged = false;\n\t            }\n\t    }\n\t};\n\t\n\tMappers[4].prototype.loadROM = function (rom) {\n\t    if (!this.nes.rom.valid) {\n\t        alert(\"MMC3: Invalid ROM! Unable to load.\");\n\t        return;\n\t    }\n\t\n\t    // Load hardwired PRG banks (0xC000 and 0xE000):\n\t    this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xC000);\n\t    this.load8kRomBank((this.nes.rom.romCount - 1) * 2 + 1, 0xE000);\n\t\n\t    // Load swappable PRG banks (0x8000 and 0xA000):\n\t    this.load8kRomBank(0, 0x8000);\n\t    this.load8kRomBank(1, 0xA000);\n\t\n\t    // Load CHR-ROM:\n\t    this.loadCHRROM();\n\t\n\t    // Load Battery RAM (if present):\n\t    this.loadBatteryRam();\n\t\n\t    // Do Reset-Interrupt:\n\t    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n\t};\n\t\n\tMappers[4].prototype.clockIrqCounter = function () {\n\t    if (this.irqEnable == 1) {\n\t        this.irqCounter--;\n\t        if (this.irqCounter < 0) {\n\t            // Trigger IRQ:\n\t            //nes.getCpu().doIrq();\n\t            this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n\t            this.irqCounter = this.irqLatchValue;\n\t        }\n\t    }\n\t};\n\t\n\tMappers[4].prototype.toJSON = function () {\n\t    var s = Mappers[0].prototype.toJSON.apply(this);\n\t    s.command = this.command;\n\t    s.prgAddressSelect = this.prgAddressSelect;\n\t    s.chrAddressSelect = this.chrAddressSelect;\n\t    s.pageNumber = this.pageNumber;\n\t    s.irqCounter = this.irqCounter;\n\t    s.irqLatchValue = this.irqLatchValue;\n\t    s.irqEnable = this.irqEnable;\n\t    s.prgAddressChanged = this.prgAddressChanged;\n\t    return s;\n\t};\n\t\n\tMappers[4].prototype.fromJSON = function (s) {\n\t    Mappers[0].prototype.fromJSON.apply(this, s);\n\t    this.command = s.command;\n\t    this.prgAddressSelect = s.prgAddressSelect;\n\t    this.chrAddressSelect = s.chrAddressSelect;\n\t    this.pageNumber = s.pageNumber;\n\t    this.irqCounter = s.irqCounter;\n\t    this.irqLatchValue = s.irqLatchValue;\n\t    this.irqEnable = s.irqEnable;\n\t    this.prgAddressChanged = s.prgAddressChanged;\n\t};\n\t\n\texports.default = Mappers;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar defaultConfig = {\n\t    player_one: {\n\t        type: 'keyboard',\n\t        mapping: {\n\t            A: 88,\n\t            B: 90,\n\t            SELECT: 17,\n\t            START: 13,\n\t            UP: 38,\n\t            DOWN: 40,\n\t            LEFT: 37,\n\t            RIGHT: 39\n\t        }\n\t    },\n\t    player_two: {\n\t        type: 'keyboard',\n\t        mapping: {\n\t            A: 103,\n\t            B: 105,\n\t            SELECT: 99,\n\t            START: 97,\n\t            UP: 104,\n\t            DOWN: 98,\n\t            LEFT: 100,\n\t            RIGHT: 102\n\t        }\n\t    }\n\t};\n\t\n\tvar Controllers = function Controllers() {\n\t    var config = arguments.length <= 0 || arguments[0] === undefined ? defaultConfig : arguments[0];\n\t\n\t\n\t    this.config = config;\n\t    this.buttons = {\n\t        A: 0,\n\t        B: 1,\n\t        SELECT: 2,\n\t        START: 3,\n\t        UP: 4,\n\t        DOWN: 5,\n\t        LEFT: 6,\n\t        RIGHT: 7\n\t    };\n\t\n\t    this.state1 = new Array(8);\n\t    for (var i = 0; i < this.state1.length; i++) {\n\t        this.state1[i] = 0x40;\n\t    }\n\t    this.state2 = new Array(8);\n\t    for (var _i = 0; _i < this.state2.length; _i++) {\n\t        this.state2[_i] = 0x40;\n\t    }\n\t};\n\t\n\tControllers.prototype = {\n\t    setButton: function setButton(button, value) {\n\t        switch (button) {\n\t            case this.config.player_one.mapping.A:\n\t                this.state1[this.buttons.A] = value;break; // X\n\t            case this.config.player_one.mapping.B:\n\t                this.state1[this.buttons.B] = value;break; // Z\n\t            case this.config.player_one.mapping.SELECT:\n\t                this.state1[this.buttons.SELECT] = value;break; // Right Ctrl\n\t            case this.config.player_one.mapping.START:\n\t                this.state1[this.buttons.START] = value;break; // Enter\n\t            case this.config.player_one.mapping.UP:\n\t                this.state1[this.buttons.UP] = value;break; // Up\n\t            case this.config.player_one.mapping.DOWN:\n\t                this.state1[this.buttons.DOWN] = value;break; // Down\n\t            case this.config.player_one.mapping.LEFT:\n\t                this.state1[this.buttons.LEFT] = value;break; // Left\n\t            case this.config.player_one.mapping.RIGHT:\n\t                this.state1[this.buttons.RIGHT] = value;break; // Right\n\t\n\t            case this.config.player_two.mapping.A:\n\t                this.state2[this.buttons.A] = value;break; // Num-7\n\t            case this.config.player_two.mapping.B:\n\t                this.state2[this.buttons.B] = value;break; // Num-9\n\t            case this.config.player_two.mapping.SELECT:\n\t                this.state2[this.buttons.SELECT] = value;break; // Num-3\n\t            case this.config.player_two.mapping.START:\n\t                this.state2[this.buttons.START] = value;break; // Num-1\n\t            case this.config.player_two.mapping.UP:\n\t                this.state2[this.buttons.UP] = value;break; // Num-8\n\t            case this.config.player_two.mapping.DOWN:\n\t                this.state2[this.buttons.DOWN] = value;break; // Num-2\n\t            case this.config.player_two.mapping.LEFT:\n\t                this.state2[this.buttons.LEFT] = value;break; // Num-4\n\t            case this.config.player_two.mapping.RIGHT:\n\t                this.state2[this.buttons.RIGHT] = value;break; // Num-6\n\t            default:\n\t                return true;\n\t        }\n\t        return false; // preventDefault\n\t    },\n\t\n\t    buttonDown: function buttonDown(evt, type) {\n\t        var buttonPressed = type === 'keyboard' ? evt.keyCode : evt.detail.value;\n\t        //evt.keyCode\n\t        if (!this.setButton(buttonPressed, 0x41) && evt.preventDefault) {\n\t            evt.preventDefault();\n\t        }\n\t    },\n\t\n\t    buttonUp: function buttonUp(evt, type) {\n\t        var buttonPressed = type === 'keyboard' ? evt.keyCode : false;\n\t        if (!this.setButton(buttonPressed, 0x40) && evt.preventDefault) {\n\t            evt.preventDefault();\n\t        }\n\t    },\n\t\n\t    buttonPress: function buttonPress(evt, type) {\n\t        evt.preventDefault();\n\t    }\n\t};\n\t\n\tControllers.prototype.configureButton = function () {\n\t    var player = arguments.length <= 0 || arguments[0] === undefined ? 'player_one' : arguments[0];\n\t    var type = arguments.length <= 1 || arguments[1] === undefined ? 'keyboard' : arguments[1];\n\t    var button = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\t    var setButton = arguments.length <= 3 || arguments[3] === undefined ? 'A' : arguments[3];\n\t\n\t    this.config[player].mapping[setButton] = button;\n\t    console.log('mapping button');\n\t    this.config([player].mapping);\n\t    return this;\n\t};\n\t\n\tControllers.prototype.configureAllButtons = function () {\n\t    var player = arguments.length <= 0 || arguments[0] === undefined ? 'player_one' : arguments[0];\n\t    var type = arguments.length <= 1 || arguments[1] === undefined ? 'keyboard' : arguments[1];\n\t    var mapping = arguments[2];\n\t};\n\t\n\texports.default = Controllers;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\t* Gamepad Axis\n\t* Axis 1\n\t*  -1 UP\n\t*  1 DOWN\n\t* Axis 2\n\t*  -1 LEFT\n\t*  1 RIGHT\n\t*/\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar Gamepad = function Gamepad() {\n\t  return this;\n\t};\n\t\n\tGamepad.prototype.gamepads = [];\n\tGamepad.prototype.gamepadPoll = false;\n\tGamepad.prototype.buttonPressedEvent = new CustomEvent('buttonpressed', { detail: null });\n\t\n\tGamepad.prototype.checkPads = function () {\n\t  console.log(Gamepad.prototype.gamepads);\n\t};\n\t\n\tGamepad.prototype.gamepadHandler = function (event, connecting) {\n\t  var gamepad = event.gamepad;\n\t\n\t  if (gamepad) {\n\t    if (connecting) {\n\t      console.log(this);\n\t      Gamepad.prototype.gamepads[gamepad.index] = gamepad;\n\t    } else {\n\t      delete Gamepad.prototype.gamepads[gamepad.index];\n\t    }\n\t  }\n\t};\n\t\n\tGamepad.prototype.isButtonPressed = function (btn) {\n\t  if ((typeof btn === 'undefined' ? 'undefined' : _typeof(btn)) == 'object') {\n\t    return btn.pressed;\n\t  }\n\t\n\t  return btn == 1.0;\n\t};\n\t\n\tGamepad.prototype.gamepadListener = function () {\n\t  var gamepads = navigator.getGamepadss ? navigator.getGamepadss() : navigator.webkitGetGamepadss ? navigator.webkitGetGamepadss : [];\n\t  var gp = gamepads[0];\n\t  if (!gamepads) {\n\t    return;\n\t  }\n\t\n\t  Gamepad.prototype.gamepads.forEach(function (pad) {\n\t    var gamepad = navigator.getGamepads()[pad.index];\n\t\n\t    for (var i = 0, len = gamepad.buttons.length; i < len; i++) {\n\t      if (Gamepad.prototype.isButtonPressed(gamepad.buttons[i])) {\n\t        //trigger press event\n\t        var buttonPressed = new CustomEvent('buttonpressed', { detail: { id: i, value: gamepad.buttons[i], type: 'button', message: 'button pressed' } });\n\t        window.dispatchEvent(buttonPressed);\n\t      }\n\t    }\n\t\n\t    for (var j = 0, l = gamepad.axes.length; j < l; j++) {\n\t      if (gamepad.axes[j] !== 0) {\n\t        var buttonPressed = new CustomEvent('buttonpressed', { detail: { id: j, value: gamepad.axes[j], type: 'axis', message: 'direction pressed' } });\n\t        window.dispatchEvent(buttonPressed);\n\t      }\n\t    }\n\t  });\n\t\n\t  Gamepad.prototype.gamepadPoll = requestAnimationFrame(Gamepad.prototype.gamepadListener);\n\t};\n\t\n\tGamepad.prototype.addButtonPressListener = function () {\n\t  window.addEventListener('buttonpressed', function (e) {\n\t    console.log('triggered button press ', e);\n\t    if (e.detail) {\n\t      console.log('details: ', e.detail);\n\t    }\n\t  }, false);\n\t};\n\t\n\tGamepad.prototype.listenForGamepadConnected = function (context) {\n\t  window.addEventListener('gamepadconnected', function (e) {\n\t    console.log('initializing gamepad');\n\t    Gamepad.prototype.gamepadHandler(e, true);\n\t    console.log('Gamepads connected: ', e);\n\t    console.log('Gamepads configured: ', context.gamepads);\n\t    Gamepad.prototype.gamepadListener();\n\t  }, false);\n\t};\n\t\n\tGamepad.prototype.listenForGamepadDisconnected = function (context) {\n\t  window.addEventListener('gamepaddisconnected', function (e) {\n\t    console.log('removing gamepad');\n\t    Gamepad.prototype.gamepadHandler(e, false);\n\t    console.log('Gamepads disconnected: ', e);\n\t    console.log('Gamepads configured: ', context.gamepads);\n\t    cancelAnimationFrame(Gamepad.prototype.gamepadPoll);\n\t  }, false);\n\t};\n\t\n\tGamepad.prototype.init = function () {\n\t  this.listenForGamepadConnected(this);\n\t  this.listenForGamepadDisconnected(this);\n\t};\n\t\n\texports.default = Gamepad;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** jsnes.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 941b370b35370e42cf53\n **/","'use strict';\n\nimport JSNES from './source/nes';\n\nexport default JSNES;\n\nexport const create = function(opts) {\n  return new JSNES(opts);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","'use strict';\n\n/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport CPU from './cpu';\nimport PPU from './ppu';\nimport PAPU from './papu';\nimport ROM from './rom';\nimport Controllers from './controllers';\nimport Gamepad from './gamepads';\n\nconst DummyUI = function(nes) {\n    this.nes = nes;\n    this.enable = function() {};\n    this.updateStatus = function() {};\n    this.writeAudio = function() {};\n    this.writeFrame = function() {};\n};\n\nconst JSNES = function(opts) {\n    this.opts = {\n        ui: DummyUI,\n        swfPath: 'lib/',\n\n        preferredFrameRate: 60,\n        fpsInterval: 500, // Time between updating FPS in ms\n        showDisplay: true,\n\n        emulateSound: false,\n        sampleRate: 44100, // Sound sample rate in hz\n\n        CPU_FREQ_NTSC: 1789772.5, //1789772.72727272d;\n        CPU_FREQ_PAL: 1773447.4\n    };\n    if (typeof opts != 'undefined') {\n        var key;\n        for (key in this.opts) {\n            if (typeof opts[key] != 'undefined') {\n                this.opts[key] = opts[key];\n            }\n        }\n    }\n\n    this.frameTime = 1000 / this.opts.preferredFrameRate;\n\n    this.ui = new this.opts.ui(this);\n    this.cpu = new CPU(this);\n    this.ppu = new PPU(this);\n    this.papu = new PAPU(this);\n    this.mmap = null; // set in loadRom()\n    this.controllers = new Controllers();\n    this.gamepad = new Gamepad(this);\n\n    this.ui.updateStatus(\"Ready to load a ROM.\");\n\n    return this;\n};\n\nJSNES.VERSION = \"<%= version %>\";\n\nJSNES.prototype = {\n    isRunning: false,\n    fpsFrameCount: 0,\n    romData: null,\n\n    // Resets the system\n    reset: function() {\n        if (this.mmap !== null) {\n            this.mmap.reset();\n        }\n\n        this.cpu.reset();\n        this.ppu.reset();\n        this.papu.reset();\n    },\n\n    start: function() {\n        var self = this;\n\n        if (this.rom !== null && this.rom.valid) {\n            if (!this.isRunning) {\n                this.isRunning = true;\n\n                this.frameInterval = setInterval(function() {\n                    self.frame();\n                }, this.frameTime);\n                this.resetFps();\n                this.printFps();\n                this.fpsInterval = setInterval(function() {\n                    self.printFps();\n                }, this.opts.fpsInterval);\n            }\n        }\n        else {\n            this.ui.updateStatus(\"There is no ROM loaded, or it is invalid.\");\n        }\n    },\n\n    frame: function() {\n        this.ppu.startFrame();\n        var cycles = 0;\n        var emulateSound = this.opts.emulateSound;\n        var cpu = this.cpu;\n        var ppu = this.ppu;\n        var papu = this.papu;\n        FRAMELOOP: for (;;) {\n            if (cpu.cyclesToHalt === 0) {\n                // Execute a CPU instruction\n                cycles = cpu.emulate();\n                if (emulateSound) {\n                    papu.clockFrameCounter(cycles);\n                }\n                cycles *= 3;\n            }\n            else {\n                if (cpu.cyclesToHalt > 8) {\n                    cycles = 24;\n                    if (emulateSound) {\n                        papu.clockFrameCounter(8);\n                    }\n                    cpu.cyclesToHalt -= 8;\n                }\n                else {\n                    cycles = cpu.cyclesToHalt * 3;\n                    if (emulateSound) {\n                        papu.clockFrameCounter(cpu.cyclesToHalt);\n                    }\n                    cpu.cyclesToHalt = 0;\n                }\n            }\n\n            for (; cycles > 0; cycles--) {\n                if(ppu.curX === ppu.spr0HitX &&\n                        ppu.f_spVisibility === 1 &&\n                        ppu.scanline - 21 === ppu.spr0HitY) {\n                    // Set sprite 0 hit flag:\n                    ppu.setStatusFlag(ppu.STATUS_SPRITE0HIT, true);\n                }\n\n                if (ppu.requestEndFrame) {\n                    ppu.nmiCounter--;\n                    if (ppu.nmiCounter === 0) {\n                        ppu.requestEndFrame = false;\n                        ppu.startVBlank();\n                        break FRAMELOOP;\n                    }\n                }\n\n                ppu.curX++;\n                if (ppu.curX === 341) {\n                    ppu.curX = 0;\n                    ppu.endScanline();\n                }\n            }\n        }\n        this.fpsFrameCount++;\n    },\n\n    printFps: function() {\n        var now = +new Date();\n        var s = 'Running';\n        if (this.lastFpsTime) {\n            s += ': '+(\n                this.fpsFrameCount / ((now - this.lastFpsTime) / 1000)\n            ).toFixed(2)+' FPS';\n        }\n        this.ui.updateStatus(s);\n        this.fpsFrameCount = 0;\n        this.lastFpsTime = now;\n    },\n\n    stop: function() {\n        clearInterval(this.frameInterval);\n        clearInterval(this.fpsInterval);\n        this.isRunning = false;\n    },\n\n    reloadRom: function() {\n        if (this.romData !== null) {\n            this.loadRom(this.romData);\n        }\n    },\n\n    // Loads a ROM file into the CPU and PPU.\n    // The ROM file is validated first.\n    loadRom: function(data) {\n        if (this.isRunning) {\n            this.stop();\n        }\n\n        this.ui.updateStatus(\"Loading ROM...\");\n\n        // Load ROM file:\n        this.rom = new ROM(this);\n        this.rom.load(data);\n\n        if (this.rom.valid) {\n            this.reset();\n            this.mmap = this.rom.createMapper();\n            if (!this.mmap) {\n                return;\n            }\n            this.mmap.loadROM();\n            this.ppu.setMirroring(this.rom.getMirroringType());\n            this.romData = data;\n\n            this.ui.updateStatus(\"Successfully loaded. Ready to be started.\");\n        }\n        else {\n            this.ui.updateStatus(\"Invalid ROM!\");\n        }\n        return this.rom.valid;\n    },\n\n    resetFps: function() {\n        this.lastFpsTime = null;\n        this.fpsFrameCount = 0;\n    },\n\n    setFramerate: function(rate){\n        this.opts.preferredFrameRate = rate;\n        this.frameTime = 1000 / rate;\n        this.papu.setSampleRate(this.opts.sampleRate, false);\n    },\n\n    toJSON: function() {\n        return {\n            'romData': this.romData,\n            'cpu': this.cpu.toJSON(),\n            'mmap': this.mmap.toJSON(),\n            'ppu': this.ppu.toJSON()\n        };\n    },\n\n    fromJSON: function(s) {\n        this.loadRom(s.romData);\n        this.cpu.fromJSON(s.cpu);\n        this.mmap.fromJSON(s.mmap);\n        this.ppu.fromJSON(s.ppu);\n    }\n};\n\nexport default JSNES;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/nes.js\n **/","'use strict';\n\n/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport utils from './utils';\n\nconst CPU = function(nes) {\n    this.nes = nes;\n\n    // Keep Chrome happy\n    this.mem = null;\n    this.REG_ACC = null;\n    this.REG_X = null;\n    this.REG_Y = null;\n    this.REG_SP = null;\n    this.REG_PC = null;\n    this.REG_PC_NEW = null;\n    this.REG_STATUS = null;\n    this.F_CARRY = null;\n    this.F_DECIMAL = null;\n    this.F_INTERRUPT = null;\n    this.F_INTERRUPT_NEW = null;\n    this.F_OVERFLOW = null;\n    this.F_SIGN = null;\n    this.F_ZERO = null;\n    this.F_NOTUSED = null;\n    this.F_NOTUSED_NEW = null;\n    this.F_BRK = null;\n    this.F_BRK_NEW = null;\n    this.opdata = null;\n    this.cyclesToHalt = null;\n    this.crash = null;\n    this.irqRequested = null;\n    this.irqType = null;\n\n    this.reset();\n};\n\nCPU.prototype = {\n    // IRQ Types\n    IRQ_NORMAL: 0,\n    IRQ_NMI: 1,\n    IRQ_RESET: 2,\n\n    reset: function() {\n        // Main memory\n        this.mem = new Array(0x10000);\n\n        for (var i=0; i < 0x2000; i++) {\n            this.mem[i] = 0xFF;\n        }\n        for (var p=0; p < 4; p++) {\n            var i = p*0x800;\n            this.mem[i+0x008] = 0xF7;\n            this.mem[i+0x009] = 0xEF;\n            this.mem[i+0x00A] = 0xDF;\n            this.mem[i+0x00F] = 0xBF;\n        }\n        for (var i=0x2001; i < this.mem.length; i++) {\n            this.mem[i] = 0;\n        }\n\n        // CPU Registers:\n        this.REG_ACC = 0;\n        this.REG_X = 0;\n        this.REG_Y = 0;\n        // Reset Stack pointer:\n        this.REG_SP = 0x01FF;\n        // Reset Program counter:\n        this.REG_PC = 0x8000-1;\n        this.REG_PC_NEW = 0x8000-1;\n        // Reset Status register:\n        this.REG_STATUS = 0x28;\n\n        this.setStatus(0x28);\n\n        // Set flags:\n        this.F_CARRY = 0;\n        this.F_DECIMAL = 0;\n        this.F_INTERRUPT = 1;\n        this.F_INTERRUPT_NEW = 1;\n        this.F_OVERFLOW = 0;\n        this.F_SIGN = 0;\n        this.F_ZERO = 1;\n\n        this.F_NOTUSED = 1;\n        this.F_NOTUSED_NEW = 1;\n        this.F_BRK = 1;\n        this.F_BRK_NEW = 1;\n\n        this.opdata = new CPU.OpData().opdata;\n        this.cyclesToHalt = 0;\n\n        // Reset crash flag:\n        this.crash = false;\n\n        // Interrupt notification:\n        this.irqRequested = false;\n        this.irqType = null;\n\n    },\n\n    // Emulates a single CPU instruction, returns the number of cycles\n    emulate: function() {\n        var temp;\n        var add;\n\n        // Check interrupts:\n        if(this.irqRequested){\n            temp =\n                (this.F_CARRY)|\n                ((this.F_ZERO===0?1:0)<<1)|\n                (this.F_INTERRUPT<<2)|\n                (this.F_DECIMAL<<3)|\n                (this.F_BRK<<4)|\n                (this.F_NOTUSED<<5)|\n                (this.F_OVERFLOW<<6)|\n                (this.F_SIGN<<7);\n\n            this.REG_PC_NEW = this.REG_PC;\n            this.F_INTERRUPT_NEW = this.F_INTERRUPT;\n            switch(this.irqType){\n                case 0: {\n                    // Normal IRQ:\n                    if(this.F_INTERRUPT!=0){\n                        ////System.out.println(\"Interrupt was masked.\");\n                        break;\n                    }\n                    this.doIrq(temp);\n                    ////System.out.println(\"Did normal IRQ. I=\"+this.F_INTERRUPT);\n                    break;\n                }case 1:{\n                    // NMI:\n                    this.doNonMaskableInterrupt(temp);\n                    break;\n\n                }case 2:{\n                    // Reset:\n                    this.doResetInterrupt();\n                    break;\n                }\n            }\n\n            this.REG_PC = this.REG_PC_NEW;\n            this.F_INTERRUPT = this.F_INTERRUPT_NEW;\n            this.F_BRK = this.F_BRK_NEW;\n            this.irqRequested = false;\n        }\n\n        var opinf = this.opdata[this.nes.mmap.load(this.REG_PC+1)];\n        var cycleCount = (opinf>>24);\n        var cycleAdd = 0;\n\n        // Find address mode:\n        var addrMode = (opinf >> 8) & 0xFF;\n\n        // Increment PC by number of op bytes:\n        var opaddr = this.REG_PC;\n        this.REG_PC += ((opinf >> 16) & 0xFF);\n\n        var addr = 0;\n        switch(addrMode){\n            case 0:{\n                // Zero Page mode. Use the address given after the opcode,\n                // but without high byte.\n                addr = this.load(opaddr+2);\n                break;\n\n            }case 1:{\n                // Relative mode.\n                addr = this.load(opaddr+2);\n                if(addr<0x80){\n                    addr += this.REG_PC;\n                }else{\n                    addr += this.REG_PC-256;\n                }\n                break;\n            }case 2:{\n                // Ignore. Address is implied in instruction.\n                break;\n            }case 3:{\n                // Absolute mode. Use the two bytes following the opcode as\n                // an address.\n                addr = this.load16bit(opaddr+2);\n                break;\n            }case 4:{\n                // Accumulator mode. The address is in the accumulator\n                // register.\n                addr = this.REG_ACC;\n                break;\n            }case 5:{\n                // Immediate mode. The value is given after the opcode.\n                addr = this.REG_PC;\n                break;\n            }case 6:{\n                // Zero Page Indexed mode, X as index. Use the address given\n                // after the opcode, then add the\n                // X register to it to get the final address.\n                addr = (this.load(opaddr+2)+this.REG_X)&0xFF;\n                break;\n            }case 7:{\n                // Zero Page Indexed mode, Y as index. Use the address given\n                // after the opcode, then add the\n                // Y register to it to get the final address.\n                addr = (this.load(opaddr+2)+this.REG_Y)&0xFF;\n                break;\n            }case 8:{\n                // Absolute Indexed Mode, X as index. Same as zero page\n                // indexed, but with the high byte.\n                addr = this.load16bit(opaddr+2);\n                if((addr&0xFF00)!=((addr+this.REG_X)&0xFF00)){\n                    cycleAdd = 1;\n                }\n                addr+=this.REG_X;\n                break;\n            }case 9:{\n                // Absolute Indexed Mode, Y as index. Same as zero page\n                // indexed, but with the high byte.\n                addr = this.load16bit(opaddr+2);\n                if((addr&0xFF00)!=((addr+this.REG_Y)&0xFF00)){\n                    cycleAdd = 1;\n                }\n                addr+=this.REG_Y;\n                break;\n            }case 10:{\n                // Pre-indexed Indirect mode. Find the 16-bit address\n                // starting at the given location plus\n                // the current X register. The value is the contents of that\n                // address.\n                addr = this.load(opaddr+2);\n                if((addr&0xFF00)!=((addr+this.REG_X)&0xFF00)){\n                    cycleAdd = 1;\n                }\n                addr+=this.REG_X;\n                addr&=0xFF;\n                addr = this.load16bit(addr);\n                break;\n            }case 11:{\n                // Post-indexed Indirect mode. Find the 16-bit address\n                // contained in the given location\n                // (and the one following). Add to that address the contents\n                // of the Y register. Fetch the value\n                // stored at that adress.\n                addr = this.load16bit(this.load(opaddr+2));\n                if((addr&0xFF00)!=((addr+this.REG_Y)&0xFF00)){\n                    cycleAdd = 1;\n                }\n                addr+=this.REG_Y;\n                break;\n            }case 12:{\n                // Indirect Absolute mode. Find the 16-bit address contained\n                // at the given location.\n                addr = this.load16bit(opaddr+2);// Find op\n                if(addr < 0x1FFF) {\n                    addr = this.mem[addr] + (this.mem[(addr & 0xFF00) | (((addr & 0xFF) + 1) & 0xFF)] << 8);// Read from address given in op\n                }\n                else{\n                    addr = this.nes.mmap.load(addr) + (this.nes.mmap.load((addr & 0xFF00) | (((addr & 0xFF) + 1) & 0xFF)) << 8);\n                }\n                break;\n\n            }\n\n        }\n        // Wrap around for addresses above 0xFFFF:\n        addr&=0xFFFF;\n\n        // ----------------------------------------------------------------------------------------------------\n        // Decode & execute instruction:\n        // ----------------------------------------------------------------------------------------------------\n\n        // This should be compiled to a jump table.\n        switch(opinf&0xFF){\n            case 0:{\n                // *******\n                // * ADC *\n                // *******\n\n                // Add with carry.\n                temp = this.REG_ACC + this.load(addr) + this.F_CARRY;\n                this.F_OVERFLOW = ((!(((this.REG_ACC ^ this.load(addr)) & 0x80)!=0) && (((this.REG_ACC ^ temp) & 0x80))!=0)?1:0);\n                this.F_CARRY = (temp>255?1:0);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                this.REG_ACC = (temp&255);\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 1:{\n                // *******\n                // * AND *\n                // *******\n\n                // AND memory with accumulator.\n                this.REG_ACC = this.REG_ACC & this.load(addr);\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                //this.REG_ACC = temp;\n                if(addrMode!=11)cycleCount+=cycleAdd; // PostIdxInd = 11\n                break;\n            }case 2:{\n                // *******\n                // * ASL *\n                // *******\n\n                // Shift left one bit\n                if(addrMode == 4){ // ADDR_ACC = 4\n\n                    this.F_CARRY = (this.REG_ACC>>7)&1;\n                    this.REG_ACC = (this.REG_ACC<<1)&255;\n                    this.F_SIGN = (this.REG_ACC>>7)&1;\n                    this.F_ZERO = this.REG_ACC;\n\n                }else{\n\n                    temp = this.load(addr);\n                    this.F_CARRY = (temp>>7)&1;\n                    temp = (temp<<1)&255;\n                    this.F_SIGN = (temp>>7)&1;\n                    this.F_ZERO = temp;\n                    this.write(addr, temp);\n\n                }\n                break;\n\n            }case 3:{\n\n                // *******\n                // * BCC *\n                // *******\n\n                // Branch on carry clear\n                if(this.F_CARRY == 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 4:{\n\n                // *******\n                // * BCS *\n                // *******\n\n                // Branch on carry set\n                if(this.F_CARRY == 1){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 5:{\n\n                // *******\n                // * BEQ *\n                // *******\n\n                // Branch on zero\n                if(this.F_ZERO == 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 6:{\n\n                // *******\n                // * BIT *\n                // *******\n\n                temp = this.load(addr);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_OVERFLOW = (temp>>6)&1;\n                temp &= this.REG_ACC;\n                this.F_ZERO = temp;\n                break;\n\n            }case 7:{\n\n                // *******\n                // * BMI *\n                // *******\n\n                // Branch on negative result\n                if(this.F_SIGN == 1){\n                    cycleCount++;\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 8:{\n\n                // *******\n                // * BNE *\n                // *******\n\n                // Branch on not zero\n                if(this.F_ZERO != 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 9:{\n\n                // *******\n                // * BPL *\n                // *******\n\n                // Branch on positive result\n                if(this.F_SIGN == 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 10:{\n\n                // *******\n                // * BRK *\n                // *******\n\n                this.REG_PC+=2;\n                this.push((this.REG_PC>>8)&255);\n                this.push(this.REG_PC&255);\n                this.F_BRK = 1;\n\n                this.push(\n                    (this.F_CARRY)|\n                    ((this.F_ZERO==0?1:0)<<1)|\n                    (this.F_INTERRUPT<<2)|\n                    (this.F_DECIMAL<<3)|\n                    (this.F_BRK<<4)|\n                    (this.F_NOTUSED<<5)|\n                    (this.F_OVERFLOW<<6)|\n                    (this.F_SIGN<<7)\n                );\n\n                this.F_INTERRUPT = 1;\n                //this.REG_PC = load(0xFFFE) | (load(0xFFFF) << 8);\n                this.REG_PC = this.load16bit(0xFFFE);\n                this.REG_PC--;\n                break;\n\n            }case 11:{\n\n                // *******\n                // * BVC *\n                // *******\n\n                // Branch on overflow clear\n                if(this.F_OVERFLOW == 0){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 12:{\n\n                // *******\n                // * BVS *\n                // *******\n\n                // Branch on overflow set\n                if(this.F_OVERFLOW == 1){\n                    cycleCount += ((opaddr&0xFF00)!=(addr&0xFF00)?2:1);\n                    this.REG_PC = addr;\n                }\n                break;\n\n            }case 13:{\n\n                // *******\n                // * CLC *\n                // *******\n\n                // Clear carry flag\n                this.F_CARRY = 0;\n                break;\n\n            }case 14:{\n\n                // *******\n                // * CLD *\n                // *******\n\n                // Clear decimal flag\n                this.F_DECIMAL = 0;\n                break;\n\n            }case 15:{\n\n                // *******\n                // * CLI *\n                // *******\n\n                // Clear interrupt flag\n                this.F_INTERRUPT = 0;\n                break;\n\n            }case 16:{\n\n                // *******\n                // * CLV *\n                // *******\n\n                // Clear overflow flag\n                this.F_OVERFLOW = 0;\n                break;\n\n            }case 17:{\n\n                // *******\n                // * CMP *\n                // *******\n\n                // Compare memory and accumulator:\n                temp = this.REG_ACC - this.load(addr);\n                this.F_CARRY = (temp>=0?1:0);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 18:{\n\n                // *******\n                // * CPX *\n                // *******\n\n                // Compare memory and index X:\n                temp = this.REG_X - this.load(addr);\n                this.F_CARRY = (temp>=0?1:0);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                break;\n\n            }case 19:{\n\n                // *******\n                // * CPY *\n                // *******\n\n                // Compare memory and index Y:\n                temp = this.REG_Y - this.load(addr);\n                this.F_CARRY = (temp>=0?1:0);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                break;\n\n            }case 20:{\n\n                // *******\n                // * DEC *\n                // *******\n\n                // Decrement memory by one:\n                temp = (this.load(addr)-1)&0xFF;\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                this.write(addr, temp);\n                break;\n\n            }case 21:{\n\n                // *******\n                // * DEX *\n                // *******\n\n                // Decrement index X by one:\n                this.REG_X = (this.REG_X-1)&0xFF;\n                this.F_SIGN = (this.REG_X>>7)&1;\n                this.F_ZERO = this.REG_X;\n                break;\n\n            }case 22:{\n\n                // *******\n                // * DEY *\n                // *******\n\n                // Decrement index Y by one:\n                this.REG_Y = (this.REG_Y-1)&0xFF;\n                this.F_SIGN = (this.REG_Y>>7)&1;\n                this.F_ZERO = this.REG_Y;\n                break;\n\n            }case 23:{\n\n                // *******\n                // * EOR *\n                // *******\n\n                // XOR Memory with accumulator, store in accumulator:\n                this.REG_ACC = (this.load(addr)^this.REG_ACC)&0xFF;\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 24:{\n\n                // *******\n                // * INC *\n                // *******\n\n                // Increment memory by one:\n                temp = (this.load(addr)+1)&0xFF;\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                this.write(addr, temp&0xFF);\n                break;\n\n            }case 25:{\n\n                // *******\n                // * INX *\n                // *******\n\n                // Increment index X by one:\n                this.REG_X = (this.REG_X+1)&0xFF;\n                this.F_SIGN = (this.REG_X>>7)&1;\n                this.F_ZERO = this.REG_X;\n                break;\n\n            }case 26:{\n\n                // *******\n                // * INY *\n                // *******\n\n                // Increment index Y by one:\n                this.REG_Y++;\n                this.REG_Y &= 0xFF;\n                this.F_SIGN = (this.REG_Y>>7)&1;\n                this.F_ZERO = this.REG_Y;\n                break;\n\n            }case 27:{\n\n                // *******\n                // * JMP *\n                // *******\n\n                // Jump to new location:\n                this.REG_PC = addr-1;\n                break;\n\n            }case 28:{\n\n                // *******\n                // * JSR *\n                // *******\n\n                // Jump to new location, saving return address.\n                // Push return address on stack:\n                this.push((this.REG_PC>>8)&255);\n                this.push(this.REG_PC&255);\n                this.REG_PC = addr-1;\n                break;\n\n            }case 29:{\n\n                // *******\n                // * LDA *\n                // *******\n\n                // Load accumulator with memory:\n                this.REG_ACC = this.load(addr);\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 30:{\n\n                // *******\n                // * LDX *\n                // *******\n\n                // Load index X with memory:\n                this.REG_X = this.load(addr);\n                this.F_SIGN = (this.REG_X>>7)&1;\n                this.F_ZERO = this.REG_X;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 31:{\n\n                // *******\n                // * LDY *\n                // *******\n\n                // Load index Y with memory:\n                this.REG_Y = this.load(addr);\n                this.F_SIGN = (this.REG_Y>>7)&1;\n                this.F_ZERO = this.REG_Y;\n                cycleCount+=cycleAdd;\n                break;\n\n            }case 32:{\n\n                // *******\n                // * LSR *\n                // *******\n\n                // Shift right one bit:\n                if(addrMode == 4){ // ADDR_ACC\n\n                    temp = (this.REG_ACC & 0xFF);\n                    this.F_CARRY = temp&1;\n                    temp >>= 1;\n                    this.REG_ACC = temp;\n\n                }else{\n\n                    temp = this.load(addr) & 0xFF;\n                    this.F_CARRY = temp&1;\n                    temp >>= 1;\n                    this.write(addr, temp);\n\n                }\n                this.F_SIGN = 0;\n                this.F_ZERO = temp;\n                break;\n\n            }case 33:{\n\n                // *******\n                // * NOP *\n                // *******\n\n                // No OPeration.\n                // Ignore.\n                break;\n\n            }case 34:{\n\n                // *******\n                // * ORA *\n                // *******\n\n                // OR memory with accumulator, store in accumulator.\n                temp = (this.load(addr)|this.REG_ACC)&255;\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                this.REG_ACC = temp;\n                if(addrMode!=11)cycleCount+=cycleAdd; // PostIdxInd = 11\n                break;\n\n            }case 35:{\n\n                // *******\n                // * PHA *\n                // *******\n\n                // Push accumulator on stack\n                this.push(this.REG_ACC);\n                break;\n\n            }case 36:{\n\n                // *******\n                // * PHP *\n                // *******\n\n                // Push processor status on stack\n                this.F_BRK = 1;\n                this.push(\n                    (this.F_CARRY)|\n                    ((this.F_ZERO==0?1:0)<<1)|\n                    (this.F_INTERRUPT<<2)|\n                    (this.F_DECIMAL<<3)|\n                    (this.F_BRK<<4)|\n                    (this.F_NOTUSED<<5)|\n                    (this.F_OVERFLOW<<6)|\n                    (this.F_SIGN<<7)\n                );\n                break;\n\n            }case 37:{\n\n                // *******\n                // * PLA *\n                // *******\n\n                // Pull accumulator from stack\n                this.REG_ACC = this.pull();\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                break;\n\n            }case 38:{\n\n                // *******\n                // * PLP *\n                // *******\n\n                // Pull processor status from stack\n                temp = this.pull();\n                this.F_CARRY     = (temp   )&1;\n                this.F_ZERO      = (((temp>>1)&1)==1)?0:1;\n                this.F_INTERRUPT = (temp>>2)&1;\n                this.F_DECIMAL   = (temp>>3)&1;\n                this.F_BRK       = (temp>>4)&1;\n                this.F_NOTUSED   = (temp>>5)&1;\n                this.F_OVERFLOW  = (temp>>6)&1;\n                this.F_SIGN      = (temp>>7)&1;\n\n                this.F_NOTUSED = 1;\n                break;\n\n            }case 39:{\n\n                // *******\n                // * ROL *\n                // *******\n\n                // Rotate one bit left\n                if(addrMode == 4){ // ADDR_ACC = 4\n\n                    temp = this.REG_ACC;\n                    add = this.F_CARRY;\n                    this.F_CARRY = (temp>>7)&1;\n                    temp = ((temp<<1)&0xFF)+add;\n                    this.REG_ACC = temp;\n\n                }else{\n\n                    temp = this.load(addr);\n                    add = this.F_CARRY;\n                    this.F_CARRY = (temp>>7)&1;\n                    temp = ((temp<<1)&0xFF)+add;\n                    this.write(addr, temp);\n\n                }\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                break;\n\n            }case 40:{\n\n                // *******\n                // * ROR *\n                // *******\n\n                // Rotate one bit right\n                if(addrMode == 4){ // ADDR_ACC = 4\n\n                    add = this.F_CARRY<<7;\n                    this.F_CARRY = this.REG_ACC&1;\n                    temp = (this.REG_ACC>>1)+add;\n                    this.REG_ACC = temp;\n\n                }else{\n\n                    temp = this.load(addr);\n                    add = this.F_CARRY<<7;\n                    this.F_CARRY = temp&1;\n                    temp = (temp>>1)+add;\n                    this.write(addr, temp);\n\n                }\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp;\n                break;\n\n            }case 41:{\n\n                // *******\n                // * RTI *\n                // *******\n\n                // Return from interrupt. Pull status and PC from stack.\n\n                temp = this.pull();\n                this.F_CARRY     = (temp   )&1;\n                this.F_ZERO      = ((temp>>1)&1)==0?1:0;\n                this.F_INTERRUPT = (temp>>2)&1;\n                this.F_DECIMAL   = (temp>>3)&1;\n                this.F_BRK       = (temp>>4)&1;\n                this.F_NOTUSED   = (temp>>5)&1;\n                this.F_OVERFLOW  = (temp>>6)&1;\n                this.F_SIGN      = (temp>>7)&1;\n\n                this.REG_PC = this.pull();\n                this.REG_PC += (this.pull()<<8);\n                if(this.REG_PC==0xFFFF){\n                    return;\n                }\n                this.REG_PC--;\n                this.F_NOTUSED = 1;\n                break;\n\n            }case 42:{\n\n                // *******\n                // * RTS *\n                // *******\n\n                // Return from subroutine. Pull PC from stack.\n\n                this.REG_PC = this.pull();\n                this.REG_PC += (this.pull()<<8);\n\n                if(this.REG_PC==0xFFFF){\n                    return; // return from NSF play routine:\n                }\n                break;\n\n            }case 43:{\n\n                // *******\n                // * SBC *\n                // *******\n\n                temp = this.REG_ACC-this.load(addr)-(1-this.F_CARRY);\n                this.F_SIGN = (temp>>7)&1;\n                this.F_ZERO = temp&0xFF;\n                this.F_OVERFLOW = ((((this.REG_ACC^temp)&0x80)!=0 && ((this.REG_ACC^this.load(addr))&0x80)!=0)?1:0);\n                this.F_CARRY = (temp<0?0:1);\n                this.REG_ACC = (temp&0xFF);\n                if(addrMode!=11)cycleCount+=cycleAdd; // PostIdxInd = 11\n                break;\n\n            }case 44:{\n\n                // *******\n                // * SEC *\n                // *******\n\n                // Set carry flag\n                this.F_CARRY = 1;\n                break;\n\n            }case 45:{\n\n                // *******\n                // * SED *\n                // *******\n\n                // Set decimal mode\n                this.F_DECIMAL = 1;\n                break;\n\n            }case 46:{\n\n                // *******\n                // * SEI *\n                // *******\n\n                // Set interrupt disable status\n                this.F_INTERRUPT = 1;\n                break;\n\n            }case 47:{\n\n                // *******\n                // * STA *\n                // *******\n\n                // Store accumulator in memory\n                this.write(addr, this.REG_ACC);\n                break;\n\n            }case 48:{\n\n                // *******\n                // * STX *\n                // *******\n\n                // Store index X in memory\n                this.write(addr, this.REG_X);\n                break;\n\n            }case 49:{\n\n                // *******\n                // * STY *\n                // *******\n\n                // Store index Y in memory:\n                this.write(addr, this.REG_Y);\n                break;\n\n            }case 50:{\n\n                // *******\n                // * TAX *\n                // *******\n\n                // Transfer accumulator to index X:\n                this.REG_X = this.REG_ACC;\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                break;\n\n            }case 51:{\n\n                // *******\n                // * TAY *\n                // *******\n\n                // Transfer accumulator to index Y:\n                this.REG_Y = this.REG_ACC;\n                this.F_SIGN = (this.REG_ACC>>7)&1;\n                this.F_ZERO = this.REG_ACC;\n                break;\n\n            }case 52:{\n\n                // *******\n                // * TSX *\n                // *******\n\n                // Transfer stack pointer to index X:\n                this.REG_X = (this.REG_SP-0x0100);\n                this.F_SIGN = (this.REG_SP>>7)&1;\n                this.F_ZERO = this.REG_X;\n                break;\n\n            }case 53:{\n\n                // *******\n                // * TXA *\n                // *******\n\n                // Transfer index X to accumulator:\n                this.REG_ACC = this.REG_X;\n                this.F_SIGN = (this.REG_X>>7)&1;\n                this.F_ZERO = this.REG_X;\n                break;\n\n            }case 54:{\n\n                // *******\n                // * TXS *\n                // *******\n\n                // Transfer index X to stack pointer:\n                this.REG_SP = (this.REG_X+0x0100);\n                this.stackWrap();\n                break;\n\n            }case 55:{\n\n                // *******\n                // * TYA *\n                // *******\n\n                // Transfer index Y to accumulator:\n                this.REG_ACC = this.REG_Y;\n                this.F_SIGN = (this.REG_Y>>7)&1;\n                this.F_ZERO = this.REG_Y;\n                break;\n\n            }default:{\n\n                // *******\n                // * ??? *\n                // *******\n\n                this.nes.stop();\n                this.nes.crashMessage = \"Game crashed, invalid opcode at address $\"+opaddr.toString(16);\n                break;\n\n            }\n\n        }// end of switch\n\n        return cycleCount;\n\n    },\n\n    load: function(addr){\n        if (addr < 0x2000) {\n            return this.mem[addr & 0x7FF];\n        }\n        else {\n            return this.nes.mmap.load(addr);\n        }\n    },\n\n    load16bit: function(addr){\n        if (addr < 0x1FFF) {\n            return this.mem[addr&0x7FF]\n                | (this.mem[(addr+1)&0x7FF]<<8);\n        }\n        else {\n            return this.nes.mmap.load(addr) | (this.nes.mmap.load(addr+1) << 8);\n        }\n    },\n\n    write: function(addr, val){\n        if(addr < 0x2000) {\n            this.mem[addr&0x7FF] = val;\n        }\n        else {\n            this.nes.mmap.write(addr,val);\n        }\n    },\n\n    requestIrq: function(type){\n        if(this.irqRequested){\n            if(type == this.IRQ_NORMAL){\n                return;\n            }\n            ////System.out.println(\"too fast irqs. type=\"+type);\n        }\n        this.irqRequested = true;\n        this.irqType = type;\n    },\n\n    push: function(value){\n        this.nes.mmap.write(this.REG_SP, value);\n        this.REG_SP--;\n        this.REG_SP = 0x0100 | (this.REG_SP&0xFF);\n    },\n\n    stackWrap: function(){\n        this.REG_SP = 0x0100 | (this.REG_SP&0xFF);\n    },\n\n    pull: function(){\n        this.REG_SP++;\n        this.REG_SP = 0x0100 | (this.REG_SP&0xFF);\n        return this.nes.mmap.load(this.REG_SP);\n    },\n\n    pageCrossed: function(addr1, addr2){\n        return ((addr1&0xFF00) != (addr2&0xFF00));\n    },\n\n    haltCycles: function(cycles){\n        this.cyclesToHalt += cycles;\n    },\n\n    doNonMaskableInterrupt: function(status){\n        if((this.nes.mmap.load(0x2000) & 128) != 0) { // Check whether VBlank Interrupts are enabled\n\n            this.REG_PC_NEW++;\n            this.push((this.REG_PC_NEW>>8)&0xFF);\n            this.push(this.REG_PC_NEW&0xFF);\n            //this.F_INTERRUPT_NEW = 1;\n            this.push(status);\n\n            this.REG_PC_NEW = this.nes.mmap.load(0xFFFA) | (this.nes.mmap.load(0xFFFB) << 8);\n            this.REG_PC_NEW--;\n        }\n    },\n\n    doResetInterrupt: function(){\n        this.REG_PC_NEW = this.nes.mmap.load(0xFFFC) | (this.nes.mmap.load(0xFFFD) << 8);\n        this.REG_PC_NEW--;\n    },\n\n    doIrq: function(status){\n        this.REG_PC_NEW++;\n        this.push((this.REG_PC_NEW>>8)&0xFF);\n        this.push(this.REG_PC_NEW&0xFF);\n        this.push(status);\n        this.F_INTERRUPT_NEW = 1;\n        this.F_BRK_NEW = 0;\n\n        this.REG_PC_NEW = this.nes.mmap.load(0xFFFE) | (this.nes.mmap.load(0xFFFF) << 8);\n        this.REG_PC_NEW--;\n    },\n\n    getStatus: function(){\n        return (this.F_CARRY)\n                |(this.F_ZERO<<1)\n                |(this.F_INTERRUPT<<2)\n                |(this.F_DECIMAL<<3)\n                |(this.F_BRK<<4)\n                |(this.F_NOTUSED<<5)\n                |(this.F_OVERFLOW<<6)\n                |(this.F_SIGN<<7);\n    },\n\n    setStatus: function(st){\n        this.F_CARRY     = (st   )&1;\n        this.F_ZERO      = (st>>1)&1;\n        this.F_INTERRUPT = (st>>2)&1;\n        this.F_DECIMAL   = (st>>3)&1;\n        this.F_BRK       = (st>>4)&1;\n        this.F_NOTUSED   = (st>>5)&1;\n        this.F_OVERFLOW  = (st>>6)&1;\n        this.F_SIGN      = (st>>7)&1;\n    },\n\n    JSON_PROPERTIES: [\n        'mem', 'cyclesToHalt', 'irqRequested', 'irqType',\n        // Registers\n        'REG_ACC', 'REG_X', 'REG_Y', 'REG_SP', 'REG_PC', 'REG_PC_NEW',\n        'REG_STATUS',\n        // Status\n        'F_CARRY', 'F_DECIMAL', 'F_INTERRUPT', 'F_INTERRUPT_NEW', 'F_OVERFLOW',\n        'F_SIGN', 'F_ZERO', 'F_NOTUSED', 'F_NOTUSED_NEW', 'F_BRK', 'F_BRK_NEW'\n    ],\n\n    toJSON: function() {\n        return utils.toJSON(this);\n    },\n\n    fromJSON: function(s) {\n        utils.fromJSON(this, s);\n    }\n}\n\n    // Generates and provides an array of details about instructions\n    CPU.OpData = function() {\n    this.opdata = new Array(256);\n\n    // Set all to invalid instruction (to detect crashes):\n    for(var i=0;i<256;i++) this.opdata[i]=0xFF;\n\n    // Now fill in all valid opcodes:\n\n    // ADC:\n    this.setOp(this.INS_ADC,0x69,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_ADC,0x65,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_ADC,0x75,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_ADC,0x6D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_ADC,0x7D,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_ADC,0x79,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_ADC,0x61,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_ADC,0x71,this.ADDR_POSTIDXIND,2,5);\n\n    // AND:\n    this.setOp(this.INS_AND,0x29,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_AND,0x25,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_AND,0x35,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_AND,0x2D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_AND,0x3D,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_AND,0x39,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_AND,0x21,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_AND,0x31,this.ADDR_POSTIDXIND,2,5);\n\n    // ASL:\n    this.setOp(this.INS_ASL,0x0A,this.ADDR_ACC,1,2);\n    this.setOp(this.INS_ASL,0x06,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_ASL,0x16,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_ASL,0x0E,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_ASL,0x1E,this.ADDR_ABSX,3,7);\n\n    // BCC:\n    this.setOp(this.INS_BCC,0x90,this.ADDR_REL,2,2);\n\n    // BCS:\n    this.setOp(this.INS_BCS,0xB0,this.ADDR_REL,2,2);\n\n    // BEQ:\n    this.setOp(this.INS_BEQ,0xF0,this.ADDR_REL,2,2);\n\n    // BIT:\n    this.setOp(this.INS_BIT,0x24,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_BIT,0x2C,this.ADDR_ABS,3,4);\n\n    // BMI:\n    this.setOp(this.INS_BMI,0x30,this.ADDR_REL,2,2);\n\n    // BNE:\n    this.setOp(this.INS_BNE,0xD0,this.ADDR_REL,2,2);\n\n    // BPL:\n    this.setOp(this.INS_BPL,0x10,this.ADDR_REL,2,2);\n\n    // BRK:\n    this.setOp(this.INS_BRK,0x00,this.ADDR_IMP,1,7);\n\n    // BVC:\n    this.setOp(this.INS_BVC,0x50,this.ADDR_REL,2,2);\n\n    // BVS:\n    this.setOp(this.INS_BVS,0x70,this.ADDR_REL,2,2);\n\n    // CLC:\n    this.setOp(this.INS_CLC,0x18,this.ADDR_IMP,1,2);\n\n    // CLD:\n    this.setOp(this.INS_CLD,0xD8,this.ADDR_IMP,1,2);\n\n    // CLI:\n    this.setOp(this.INS_CLI,0x58,this.ADDR_IMP,1,2);\n\n    // CLV:\n    this.setOp(this.INS_CLV,0xB8,this.ADDR_IMP,1,2);\n\n    // CMP:\n    this.setOp(this.INS_CMP,0xC9,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_CMP,0xC5,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_CMP,0xD5,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_CMP,0xCD,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_CMP,0xDD,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_CMP,0xD9,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_CMP,0xC1,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_CMP,0xD1,this.ADDR_POSTIDXIND,2,5);\n\n    // CPX:\n    this.setOp(this.INS_CPX,0xE0,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_CPX,0xE4,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_CPX,0xEC,this.ADDR_ABS,3,4);\n\n    // CPY:\n    this.setOp(this.INS_CPY,0xC0,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_CPY,0xC4,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_CPY,0xCC,this.ADDR_ABS,3,4);\n\n    // DEC:\n    this.setOp(this.INS_DEC,0xC6,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_DEC,0xD6,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_DEC,0xCE,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_DEC,0xDE,this.ADDR_ABSX,3,7);\n\n    // DEX:\n    this.setOp(this.INS_DEX,0xCA,this.ADDR_IMP,1,2);\n\n    // DEY:\n    this.setOp(this.INS_DEY,0x88,this.ADDR_IMP,1,2);\n\n    // EOR:\n    this.setOp(this.INS_EOR,0x49,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_EOR,0x45,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_EOR,0x55,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_EOR,0x4D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_EOR,0x5D,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_EOR,0x59,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_EOR,0x41,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_EOR,0x51,this.ADDR_POSTIDXIND,2,5);\n\n    // INC:\n    this.setOp(this.INS_INC,0xE6,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_INC,0xF6,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_INC,0xEE,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_INC,0xFE,this.ADDR_ABSX,3,7);\n\n    // INX:\n    this.setOp(this.INS_INX,0xE8,this.ADDR_IMP,1,2);\n\n    // INY:\n    this.setOp(this.INS_INY,0xC8,this.ADDR_IMP,1,2);\n\n    // JMP:\n    this.setOp(this.INS_JMP,0x4C,this.ADDR_ABS,3,3);\n    this.setOp(this.INS_JMP,0x6C,this.ADDR_INDABS,3,5);\n\n    // JSR:\n    this.setOp(this.INS_JSR,0x20,this.ADDR_ABS,3,6);\n\n    // LDA:\n    this.setOp(this.INS_LDA,0xA9,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_LDA,0xA5,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_LDA,0xB5,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_LDA,0xAD,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_LDA,0xBD,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_LDA,0xB9,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_LDA,0xA1,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_LDA,0xB1,this.ADDR_POSTIDXIND,2,5);\n\n\n    // LDX:\n    this.setOp(this.INS_LDX,0xA2,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_LDX,0xA6,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_LDX,0xB6,this.ADDR_ZPY,2,4);\n    this.setOp(this.INS_LDX,0xAE,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_LDX,0xBE,this.ADDR_ABSY,3,4);\n\n    // LDY:\n    this.setOp(this.INS_LDY,0xA0,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_LDY,0xA4,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_LDY,0xB4,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_LDY,0xAC,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_LDY,0xBC,this.ADDR_ABSX,3,4);\n\n    // LSR:\n    this.setOp(this.INS_LSR,0x4A,this.ADDR_ACC,1,2);\n    this.setOp(this.INS_LSR,0x46,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_LSR,0x56,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_LSR,0x4E,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_LSR,0x5E,this.ADDR_ABSX,3,7);\n\n    // NOP:\n    this.setOp(this.INS_NOP,0xEA,this.ADDR_IMP,1,2);\n\n    // ORA:\n    this.setOp(this.INS_ORA,0x09,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_ORA,0x05,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_ORA,0x15,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_ORA,0x0D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_ORA,0x1D,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_ORA,0x19,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_ORA,0x01,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_ORA,0x11,this.ADDR_POSTIDXIND,2,5);\n\n    // PHA:\n    this.setOp(this.INS_PHA,0x48,this.ADDR_IMP,1,3);\n\n    // PHP:\n    this.setOp(this.INS_PHP,0x08,this.ADDR_IMP,1,3);\n\n    // PLA:\n    this.setOp(this.INS_PLA,0x68,this.ADDR_IMP,1,4);\n\n    // PLP:\n    this.setOp(this.INS_PLP,0x28,this.ADDR_IMP,1,4);\n\n    // ROL:\n    this.setOp(this.INS_ROL,0x2A,this.ADDR_ACC,1,2);\n    this.setOp(this.INS_ROL,0x26,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_ROL,0x36,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_ROL,0x2E,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_ROL,0x3E,this.ADDR_ABSX,3,7);\n\n    // ROR:\n    this.setOp(this.INS_ROR,0x6A,this.ADDR_ACC,1,2);\n    this.setOp(this.INS_ROR,0x66,this.ADDR_ZP,2,5);\n    this.setOp(this.INS_ROR,0x76,this.ADDR_ZPX,2,6);\n    this.setOp(this.INS_ROR,0x6E,this.ADDR_ABS,3,6);\n    this.setOp(this.INS_ROR,0x7E,this.ADDR_ABSX,3,7);\n\n    // RTI:\n    this.setOp(this.INS_RTI,0x40,this.ADDR_IMP,1,6);\n\n    // RTS:\n    this.setOp(this.INS_RTS,0x60,this.ADDR_IMP,1,6);\n\n    // SBC:\n    this.setOp(this.INS_SBC,0xE9,this.ADDR_IMM,2,2);\n    this.setOp(this.INS_SBC,0xE5,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_SBC,0xF5,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_SBC,0xED,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_SBC,0xFD,this.ADDR_ABSX,3,4);\n    this.setOp(this.INS_SBC,0xF9,this.ADDR_ABSY,3,4);\n    this.setOp(this.INS_SBC,0xE1,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_SBC,0xF1,this.ADDR_POSTIDXIND,2,5);\n\n    // SEC:\n    this.setOp(this.INS_SEC,0x38,this.ADDR_IMP,1,2);\n\n    // SED:\n    this.setOp(this.INS_SED,0xF8,this.ADDR_IMP,1,2);\n\n    // SEI:\n    this.setOp(this.INS_SEI,0x78,this.ADDR_IMP,1,2);\n\n    // STA:\n    this.setOp(this.INS_STA,0x85,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_STA,0x95,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_STA,0x8D,this.ADDR_ABS,3,4);\n    this.setOp(this.INS_STA,0x9D,this.ADDR_ABSX,3,5);\n    this.setOp(this.INS_STA,0x99,this.ADDR_ABSY,3,5);\n    this.setOp(this.INS_STA,0x81,this.ADDR_PREIDXIND,2,6);\n    this.setOp(this.INS_STA,0x91,this.ADDR_POSTIDXIND,2,6);\n\n    // STX:\n    this.setOp(this.INS_STX,0x86,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_STX,0x96,this.ADDR_ZPY,2,4);\n    this.setOp(this.INS_STX,0x8E,this.ADDR_ABS,3,4);\n\n    // STY:\n    this.setOp(this.INS_STY,0x84,this.ADDR_ZP,2,3);\n    this.setOp(this.INS_STY,0x94,this.ADDR_ZPX,2,4);\n    this.setOp(this.INS_STY,0x8C,this.ADDR_ABS,3,4);\n\n    // TAX:\n    this.setOp(this.INS_TAX,0xAA,this.ADDR_IMP,1,2);\n\n    // TAY:\n    this.setOp(this.INS_TAY,0xA8,this.ADDR_IMP,1,2);\n\n    // TSX:\n    this.setOp(this.INS_TSX,0xBA,this.ADDR_IMP,1,2);\n\n    // TXA:\n    this.setOp(this.INS_TXA,0x8A,this.ADDR_IMP,1,2);\n\n    // TXS:\n    this.setOp(this.INS_TXS,0x9A,this.ADDR_IMP,1,2);\n\n    // TYA:\n    this.setOp(this.INS_TYA,0x98,this.ADDR_IMP,1,2);\n\n    this.cycTable = new Array(\n    /*0x00*/ 7,6,2,8,3,3,5,5,3,2,2,2,4,4,6,6,\n    /*0x10*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x20*/ 6,6,2,8,3,3,5,5,4,2,2,2,4,4,6,6,\n    /*0x30*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x40*/ 6,6,2,8,3,3,5,5,3,2,2,2,3,4,6,6,\n    /*0x50*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x60*/ 6,6,2,8,3,3,5,5,4,2,2,2,5,4,6,6,\n    /*0x70*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x80*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,\n    /*0x90*/ 2,6,2,6,4,4,4,4,2,5,2,5,5,5,5,5,\n    /*0xA0*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,\n    /*0xB0*/ 2,5,2,5,4,4,4,4,2,4,2,4,4,4,4,4,\n    /*0xC0*/ 2,6,2,8,3,3,5,5,2,2,2,2,4,4,6,6,\n    /*0xD0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0xE0*/ 2,6,3,8,3,3,5,5,2,2,2,2,4,4,6,6,\n    /*0xF0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7\n    );\n\n\n    this.instname = new Array(56);\n\n    // Instruction Names:\n    this.instname[ 0] = \"ADC\";\n    this.instname[ 1] = \"AND\";\n    this.instname[ 2] = \"ASL\";\n    this.instname[ 3] = \"BCC\";\n    this.instname[ 4] = \"BCS\";\n    this.instname[ 5] = \"BEQ\";\n    this.instname[ 6] = \"BIT\";\n    this.instname[ 7] = \"BMI\";\n    this.instname[ 8] = \"BNE\";\n    this.instname[ 9] = \"BPL\";\n    this.instname[10] = \"BRK\";\n    this.instname[11] = \"BVC\";\n    this.instname[12] = \"BVS\";\n    this.instname[13] = \"CLC\";\n    this.instname[14] = \"CLD\";\n    this.instname[15] = \"CLI\";\n    this.instname[16] = \"CLV\";\n    this.instname[17] = \"CMP\";\n    this.instname[18] = \"CPX\";\n    this.instname[19] = \"CPY\";\n    this.instname[20] = \"DEC\";\n    this.instname[21] = \"DEX\";\n    this.instname[22] = \"DEY\";\n    this.instname[23] = \"EOR\";\n    this.instname[24] = \"INC\";\n    this.instname[25] = \"INX\";\n    this.instname[26] = \"INY\";\n    this.instname[27] = \"JMP\";\n    this.instname[28] = \"JSR\";\n    this.instname[29] = \"LDA\";\n    this.instname[30] = \"LDX\";\n    this.instname[31] = \"LDY\";\n    this.instname[32] = \"LSR\";\n    this.instname[33] = \"NOP\";\n    this.instname[34] = \"ORA\";\n    this.instname[35] = \"PHA\";\n    this.instname[36] = \"PHP\";\n    this.instname[37] = \"PLA\";\n    this.instname[38] = \"PLP\";\n    this.instname[39] = \"ROL\";\n    this.instname[40] = \"ROR\";\n    this.instname[41] = \"RTI\";\n    this.instname[42] = \"RTS\";\n    this.instname[43] = \"SBC\";\n    this.instname[44] = \"SEC\";\n    this.instname[45] = \"SED\";\n    this.instname[46] = \"SEI\";\n    this.instname[47] = \"STA\";\n    this.instname[48] = \"STX\";\n    this.instname[49] = \"STY\";\n    this.instname[50] = \"TAX\";\n    this.instname[51] = \"TAY\";\n    this.instname[52] = \"TSX\";\n    this.instname[53] = \"TXA\";\n    this.instname[54] = \"TXS\";\n    this.instname[55] = \"TYA\";\n\n    this.addrDesc = new Array(\n        \"Zero Page           \",\n        \"Relative            \",\n        \"Implied             \",\n        \"Absolute            \",\n        \"Accumulator         \",\n        \"Immediate           \",\n        \"Zero Page,X         \",\n        \"Zero Page,Y         \",\n        \"Absolute,X          \",\n        \"Absolute,Y          \",\n        \"Preindexed Indirect \",\n        \"Postindexed Indirect\",\n        \"Indirect Absolute   \"\n    );\n}\n\nCPU.OpData.prototype = {\n    INS_ADC: 0,\n    INS_AND: 1,\n    INS_ASL: 2,\n\n    INS_BCC: 3,\n    INS_BCS: 4,\n    INS_BEQ: 5,\n    INS_BIT: 6,\n    INS_BMI: 7,\n    INS_BNE: 8,\n    INS_BPL: 9,\n    INS_BRK: 10,\n    INS_BVC: 11,\n    INS_BVS: 12,\n\n    INS_CLC: 13,\n    INS_CLD: 14,\n    INS_CLI: 15,\n    INS_CLV: 16,\n    INS_CMP: 17,\n    INS_CPX: 18,\n    INS_CPY: 19,\n\n    INS_DEC: 20,\n    INS_DEX: 21,\n    INS_DEY: 22,\n\n    INS_EOR: 23,\n\n    INS_INC: 24,\n    INS_INX: 25,\n    INS_INY: 26,\n\n    INS_JMP: 27,\n    INS_JSR: 28,\n\n    INS_LDA: 29,\n    INS_LDX: 30,\n    INS_LDY: 31,\n    INS_LSR: 32,\n\n    INS_NOP: 33,\n\n    INS_ORA: 34,\n\n    INS_PHA: 35,\n    INS_PHP: 36,\n    INS_PLA: 37,\n    INS_PLP: 38,\n\n    INS_ROL: 39,\n    INS_ROR: 40,\n    INS_RTI: 41,\n    INS_RTS: 42,\n\n    INS_SBC: 43,\n    INS_SEC: 44,\n    INS_SED: 45,\n    INS_SEI: 46,\n    INS_STA: 47,\n    INS_STX: 48,\n    INS_STY: 49,\n\n    INS_TAX: 50,\n    INS_TAY: 51,\n    INS_TSX: 52,\n    INS_TXA: 53,\n    INS_TXS: 54,\n    INS_TYA: 55,\n\n    INS_DUMMY: 56, // dummy instruction used for 'halting' the processor some cycles\n\n    // -------------------------------- //\n\n    // Addressing modes:\n    ADDR_ZP        : 0,\n    ADDR_REL       : 1,\n    ADDR_IMP       : 2,\n    ADDR_ABS       : 3,\n    ADDR_ACC       : 4,\n    ADDR_IMM       : 5,\n    ADDR_ZPX       : 6,\n    ADDR_ZPY       : 7,\n    ADDR_ABSX      : 8,\n    ADDR_ABSY      : 9,\n    ADDR_PREIDXIND : 10,\n    ADDR_POSTIDXIND: 11,\n    ADDR_INDABS    : 12,\n\n    setOp: function(inst, op, addr, size, cycles){\n        this.opdata[op] =\n            ((inst  &0xFF)    )|\n            ((addr  &0xFF)<< 8)|\n            ((size  &0xFF)<<16)|\n            ((cycles&0xFF)<<24);\n    }\n};\n\nexport default CPU;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/cpu.js\n **/","'use strict';\n\n/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst utils = {\n    copyArrayElements: function(src, srcPos, dest, destPos, length) {\n        for (var i = 0; i < length; ++i) {\n            dest[destPos + i] = src[srcPos + i];\n        }\n    },\n\n    copyArray: function(src) {\n        var dest = new Array(src.length);\n        for (var i = 0; i < src.length; i++) {\n            dest[i] = src[i];\n        }\n        return dest;\n    },\n\n    fromJSON: function(obj, state) {\n        for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n            obj[obj.JSON_PROPERTIES[i]] = state[obj.JSON_PROPERTIES[i]];\n        }\n    },\n\n    toJSON: function(obj) {\n        var state = {};\n        for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n            state[obj.JSON_PROPERTIES[i]] = obj[obj.JSON_PROPERTIES[i]];\n        }\n        return state;\n    },\n\n    isIE: function() {\n        return (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent));\n    }\n};\n\nexport default utils;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/utils.js\n **/","/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport utils from './utils';\n\nconst PPU = function(nes) {\n    this.nes = nes;\n\n    // Keep Chrome happy\n    this.vramMem = null;\n    this.spriteMem = null;\n    this.vramAddress = null;\n    this.vramTmpAddress = null;\n    this.vramBufferedReadValue = null;\n    this.firstWrite = null;\n    this.sramAddress = null;\n    this.currentMirroring = null;\n    this.requestEndFrame = null;\n    this.nmiOk = null;\n    this.dummyCycleToggle = null;\n    this.validTileData = null;\n    this.nmiCounter = null;\n    this.scanlineAlreadyRendered = null;\n    this.f_nmiOnVblank = null;\n    this.f_spriteSize = null;\n    this.f_bgPatternTable = null;\n    this.f_spPatternTable = null;\n    this.f_addrInc = null;\n    this.f_nTblAddress = null;\n    this.f_color = null;\n    this.f_spVisibility = null;\n    this.f_bgVisibility = null;\n    this.f_spClipping = null;\n    this.f_bgClipping = null;\n    this.f_dispType = null;\n    this.cntFV = null;\n    this.cntV = null;\n    this.cntH = null;\n    this.cntVT = null;\n    this.cntHT = null;\n    this.regFV = null;\n    this.regV = null;\n    this.regH = null;\n    this.regVT = null;\n    this.regHT = null;\n    this.regFH = null;\n    this.regS = null;\n    this.curNt = null;\n    this.attrib = null;\n    this.buffer = null;\n    this.prevBuffer = null;\n    this.bgbuffer = null;\n    this.pixrendered = null;\n\n    this.validTileData = null;\n    this.scantile = null;\n    this.scanline = null;\n    this.lastRenderedScanline = null;\n    this.curX = null;\n    this.sprX = null;\n    this.sprY = null;\n    this.sprTile = null;\n    this.sprCol = null;\n    this.vertFlip = null;\n    this.horiFlip = null;\n    this.bgPriority = null;\n    this.spr0HitX = null;\n    this.spr0HitY = null;\n    this.hitSpr0 = null;\n    this.sprPalette = null;\n    this.imgPalette = null;\n    this.ptTile = null;\n    this.ntable1 = null;\n    this.currentMirroring = null;\n    this.nameTable = null;\n    this.vramMirrorTable = null;\n    this.palTable = null;\n\n\n    // Rendering Options:\n    this.showSpr0Hit = false;\n    this.clipToTvSize = true;\n\n    this.reset();\n};\n\nPPU.prototype = {\n    // Status flags:\n    STATUS_VRAMWRITE: 4,\n    STATUS_SLSPRITECOUNT: 5,\n    STATUS_SPRITE0HIT: 6,\n    STATUS_VBLANK: 7,\n\n    reset: function() {\n        var i;\n\n        // Memory\n        this.vramMem = new Array(0x8000);\n        this.spriteMem = new Array(0x100);\n        for (i=0; i<this.vramMem.length; i++) {\n            this.vramMem[i] = 0;\n        }\n        for (i=0; i<this.spriteMem.length; i++) {\n            this.spriteMem[i] = 0;\n        }\n\n        // VRAM I/O:\n        this.vramAddress = null;\n        this.vramTmpAddress = null;\n        this.vramBufferedReadValue = 0;\n        this.firstWrite = true;       // VRAM/Scroll Hi/Lo latch\n\n        // SPR-RAM I/O:\n        this.sramAddress = 0; // 8-bit only.\n\n        this.currentMirroring = -1;\n        this.requestEndFrame = false;\n        this.nmiOk = false;\n        this.dummyCycleToggle = false;\n        this.validTileData = false;\n        this.nmiCounter = 0;\n        this.scanlineAlreadyRendered = null;\n\n        // Control Flags Register 1:\n        this.f_nmiOnVblank = 0;    // NMI on VBlank. 0=disable, 1=enable\n        this.f_spriteSize = 0;     // Sprite size. 0=8x8, 1=8x16\n        this.f_bgPatternTable = 0; // Background Pattern Table address. 0=0x0000,1=0x1000\n        this.f_spPatternTable = 0; // Sprite Pattern Table address. 0=0x0000,1=0x1000\n        this.f_addrInc = 0;        // PPU Address Increment. 0=1,1=32\n        this.f_nTblAddress = 0;    // Name Table Address. 0=0x2000,1=0x2400,2=0x2800,3=0x2C00\n\n        // Control Flags Register 2:\n        this.f_color = 0;         // Background color. 0=black, 1=blue, 2=green, 4=red\n        this.f_spVisibility = 0;   // Sprite visibility. 0=not displayed,1=displayed\n        this.f_bgVisibility = 0;   // Background visibility. 0=Not Displayed,1=displayed\n        this.f_spClipping = 0;     // Sprite clipping. 0=Sprites invisible in left 8-pixel column,1=No clipping\n        this.f_bgClipping = 0;     // Background clipping. 0=BG invisible in left 8-pixel column, 1=No clipping\n        this.f_dispType = 0;       // Display type. 0=color, 1=monochrome\n\n        // Counters:\n        this.cntFV = 0;\n        this.cntV = 0;\n        this.cntH = 0;\n        this.cntVT = 0;\n        this.cntHT = 0;\n\n        // Registers:\n        this.regFV = 0;\n        this.regV = 0;\n        this.regH = 0;\n        this.regVT = 0;\n        this.regHT = 0;\n        this.regFH = 0;\n        this.regS = 0;\n\n        // These are temporary variables used in rendering and sound procedures.\n        // Their states outside of those procedures can be ignored.\n        // TODO: the use of this is a bit weird, investigate\n        this.curNt = null;\n\n        // Variables used when rendering:\n        this.attrib = new Array(32);\n        this.buffer = new Array(256*240);\n        this.prevBuffer = new Array(256*240);\n        this.bgbuffer = new Array(256*240);\n        this.pixrendered = new Array(256*240);\n\n        this.validTileData = null;\n\n        this.scantile = new Array(32);\n\n        // Initialize misc vars:\n        this.scanline = 0;\n        this.lastRenderedScanline = -1;\n        this.curX = 0;\n\n        // Sprite data:\n        this.sprX = new Array(64); // X coordinate\n        this.sprY = new Array(64); // Y coordinate\n        this.sprTile = new Array(64); // Tile Index (into pattern table)\n        this.sprCol = new Array(64); // Upper two bits of color\n        this.vertFlip = new Array(64); // Vertical Flip\n        this.horiFlip = new Array(64); // Horizontal Flip\n        this.bgPriority = new Array(64); // Background priority\n        this.spr0HitX = 0; // Sprite #0 hit X coordinate\n        this.spr0HitY = 0; // Sprite #0 hit Y coordinate\n        this.hitSpr0 = false;\n\n        // Palette data:\n        this.sprPalette = new Array(16);\n        this.imgPalette = new Array(16);\n\n        // Create pattern table tile buffers:\n        this.ptTile = new Array(512);\n        for (i=0; i<512; i++) {\n            this.ptTile[i] = new PPU.Tile();\n        }\n\n        // Create nametable buffers:\n        // Name table data:\n        this.ntable1 = new Array(4);\n        this.currentMirroring = -1;\n        this.nameTable = new Array(4);\n        for (i=0; i<4; i++) {\n            this.nameTable[i] = new PPU.NameTable(32, 32, \"Nt\"+i);\n        }\n\n        // Initialize mirroring lookup table:\n        this.vramMirrorTable = new Array(0x8000);\n        for (i=0; i<0x8000; i++) {\n            this.vramMirrorTable[i] = i;\n        }\n\n        this.palTable = new PPU.PaletteTable();\n        this.palTable.loadNTSCPalette();\n        //this.palTable.loadDefaultPalette();\n\n        this.updateControlReg1(0);\n        this.updateControlReg2(0);\n    },\n\n    // Sets Nametable mirroring.\n    setMirroring: function(mirroring){\n\n        if (mirroring == this.currentMirroring) {\n            return;\n        }\n\n        this.currentMirroring = mirroring;\n        this.triggerRendering();\n\n        // Remove mirroring:\n        if (this.vramMirrorTable === null) {\n            this.vramMirrorTable = new Array(0x8000);\n        }\n        for (var i=0; i<0x8000; i++) {\n            this.vramMirrorTable[i] = i;\n        }\n\n        // Palette mirroring:\n        this.defineMirrorRegion(0x3f20,0x3f00,0x20);\n        this.defineMirrorRegion(0x3f40,0x3f00,0x20);\n        this.defineMirrorRegion(0x3f80,0x3f00,0x20);\n        this.defineMirrorRegion(0x3fc0,0x3f00,0x20);\n\n        // Additional mirroring:\n        this.defineMirrorRegion(0x3000,0x2000,0xf00);\n        this.defineMirrorRegion(0x4000,0x0000,0x4000);\n\n        if (mirroring == this.nes.rom.HORIZONTAL_MIRRORING) {\n            // Horizontal mirroring.\n\n            this.ntable1[0] = 0;\n            this.ntable1[1] = 0;\n            this.ntable1[2] = 1;\n            this.ntable1[3] = 1;\n\n            this.defineMirrorRegion(0x2400,0x2000,0x400);\n            this.defineMirrorRegion(0x2c00,0x2800,0x400);\n\n        }else if (mirroring == this.nes.rom.VERTICAL_MIRRORING) {\n            // Vertical mirroring.\n\n            this.ntable1[0] = 0;\n            this.ntable1[1] = 1;\n            this.ntable1[2] = 0;\n            this.ntable1[3] = 1;\n\n            this.defineMirrorRegion(0x2800,0x2000,0x400);\n            this.defineMirrorRegion(0x2c00,0x2400,0x400);\n\n        }else if (mirroring == this.nes.rom.SINGLESCREEN_MIRRORING) {\n\n            // Single Screen mirroring\n\n            this.ntable1[0] = 0;\n            this.ntable1[1] = 0;\n            this.ntable1[2] = 0;\n            this.ntable1[3] = 0;\n\n            this.defineMirrorRegion(0x2400,0x2000,0x400);\n            this.defineMirrorRegion(0x2800,0x2000,0x400);\n            this.defineMirrorRegion(0x2c00,0x2000,0x400);\n\n        }else if (mirroring == this.nes.rom.SINGLESCREEN_MIRRORING2) {\n\n\n            this.ntable1[0] = 1;\n            this.ntable1[1] = 1;\n            this.ntable1[2] = 1;\n            this.ntable1[3] = 1;\n\n            this.defineMirrorRegion(0x2400,0x2400,0x400);\n            this.defineMirrorRegion(0x2800,0x2400,0x400);\n            this.defineMirrorRegion(0x2c00,0x2400,0x400);\n\n        }else {\n\n            // Assume Four-screen mirroring.\n\n            this.ntable1[0] = 0;\n            this.ntable1[1] = 1;\n            this.ntable1[2] = 2;\n            this.ntable1[3] = 3;\n\n        }\n\n    },\n\n\n    // Define a mirrored area in the address lookup table.\n    // Assumes the regions don't overlap.\n    // The 'to' region is the region that is physically in memory.\n    defineMirrorRegion: function(fromStart, toStart, size){\n        for (var i=0;i<size;i++) {\n            this.vramMirrorTable[fromStart+i] = toStart+i;\n        }\n    },\n\n    startVBlank: function(){\n\n        // Do NMI:\n        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n\n        // Make sure everything is rendered:\n        if (this.lastRenderedScanline < 239) {\n            this.renderFramePartially(\n                this.lastRenderedScanline+1,240-this.lastRenderedScanline\n            );\n        }\n\n        // End frame:\n        this.endFrame();\n\n        // Reset scanline counter:\n        this.lastRenderedScanline = -1;\n    },\n\n    endScanline: function(){\n        switch (this.scanline) {\n            case 19:\n                // Dummy scanline.\n                // May be variable length:\n                if (this.dummyCycleToggle) {\n\n                    // Remove dead cycle at end of scanline,\n                    // for next scanline:\n                    this.curX = 1;\n                    this.dummyCycleToggle = !this.dummyCycleToggle;\n\n                }\n                break;\n\n            case 20:\n                // Clear VBlank flag:\n                this.setStatusFlag(this.STATUS_VBLANK,false);\n\n                // Clear Sprite #0 hit flag:\n                this.setStatusFlag(this.STATUS_SPRITE0HIT,false);\n                this.hitSpr0 = false;\n                this.spr0HitX = -1;\n                this.spr0HitY = -1;\n\n                if (this.f_bgVisibility == 1 || this.f_spVisibility==1) {\n\n                    // Update counters:\n                    this.cntFV = this.regFV;\n                    this.cntV = this.regV;\n                    this.cntH = this.regH;\n                    this.cntVT = this.regVT;\n                    this.cntHT = this.regHT;\n\n                    if (this.f_bgVisibility==1) {\n                        // Render dummy scanline:\n                        this.renderBgScanline(false,0);\n                    }\n\n                }\n\n                if (this.f_bgVisibility==1 && this.f_spVisibility==1) {\n\n                    // Check sprite 0 hit for first scanline:\n                    this.checkSprite0(0);\n\n                }\n\n                if (this.f_bgVisibility==1 || this.f_spVisibility==1) {\n                    // Clock mapper IRQ Counter:\n                    this.nes.mmap.clockIrqCounter();\n                }\n                break;\n\n            case 261:\n                // Dead scanline, no rendering.\n                // Set VINT:\n                this.setStatusFlag(this.STATUS_VBLANK,true);\n                this.requestEndFrame = true;\n                this.nmiCounter = 9;\n\n                // Wrap around:\n                this.scanline = -1; // will be incremented to 0\n\n                break;\n\n            default:\n                if (this.scanline >= 21 && this.scanline <= 260) {\n\n                    // Render normally:\n                    if (this.f_bgVisibility == 1) {\n\n                        if (!this.scanlineAlreadyRendered) {\n                            // update scroll:\n                            this.cntHT = this.regHT;\n                            this.cntH = this.regH;\n                            this.renderBgScanline(true,this.scanline+1-21);\n                        }\n                        this.scanlineAlreadyRendered=false;\n\n                        // Check for sprite 0 (next scanline):\n                        if (!this.hitSpr0 && this.f_spVisibility == 1) {\n                            if (this.sprX[0] >= -7 &&\n                                    this.sprX[0] < 256 &&\n                                    this.sprY[0] + 1 <= (this.scanline - 20) &&\n                                    (this.sprY[0] + 1 + (\n                                        this.f_spriteSize === 0 ? 8 : 16\n                                    )) >= (this.scanline - 20)) {\n                                if (this.checkSprite0(this.scanline - 20)) {\n                                    this.hitSpr0 = true;\n                                }\n                            }\n                        }\n\n                    }\n\n                    if (this.f_bgVisibility==1 || this.f_spVisibility==1) {\n                        // Clock mapper IRQ Counter:\n                        this.nes.mmap.clockIrqCounter();\n                    }\n                }\n        }\n\n        this.scanline++;\n        this.regsToAddress();\n        this.cntsToAddress();\n\n    },\n\n    startFrame: function(){\n        // Set background color:\n        var bgColor=0;\n\n        if (this.f_dispType === 0) {\n            // Color display.\n            // f_color determines color emphasis.\n            // Use first entry of image palette as BG color.\n            bgColor = this.imgPalette[0];\n        }\n        else {\n            // Monochrome display.\n            // f_color determines the bg color.\n            switch (this.f_color) {\n                case 0:\n                    // Black\n                    bgColor = 0x00000;\n                    break;\n                case 1:\n                    // Green\n                    bgColor = 0x00FF00;\n                    break;\n                case 2:\n                    // Blue\n                    bgColor = 0xFF0000;\n                    break;\n                case 3:\n                    // Invalid. Use black.\n                    bgColor = 0x000000;\n                    break;\n                case 4:\n                    // Red\n                    bgColor = 0x0000FF;\n                    break;\n                default:\n                    // Invalid. Use black.\n                    bgColor = 0x0;\n            }\n        }\n\n        var buffer = this.buffer;\n        var i;\n        for (i=0; i<256*240; i++) {\n            buffer[i] = bgColor;\n        }\n        var pixrendered = this.pixrendered;\n        for (i=0; i<pixrendered.length; i++) {\n            pixrendered[i]=65;\n        }\n    },\n\n    endFrame: function(){\n        var i, x, y;\n        var buffer = this.buffer;\n\n        // Draw spr#0 hit coordinates:\n        if (this.showSpr0Hit) {\n            // Spr 0 position:\n            if (this.sprX[0] >= 0 && this.sprX[0] < 256 &&\n                    this.sprY[0] >= 0 && this.sprY[0] < 240) {\n                for (i=0; i<256; i++) {\n                    buffer[(this.sprY[0]<<8)+i] = 0xFF5555;\n                }\n                for (i=0; i<240; i++) {\n                    buffer[(i<<8)+this.sprX[0]] = 0xFF5555;\n                }\n            }\n            // Hit position:\n            if (this.spr0HitX >= 0 && this.spr0HitX < 256 &&\n                    this.spr0HitY >= 0 && this.spr0HitY < 240) {\n                for (i=0; i<256; i++) {\n                    buffer[(this.spr0HitY<<8)+i] = 0x55FF55;\n                }\n                for (i=0; i<240; i++) {\n                    buffer[(i<<8)+this.spr0HitX] = 0x55FF55;\n                }\n            }\n        }\n\n        // This is a bit lazy..\n        // if either the sprites or the background should be clipped,\n        // both are clipped after rendering is finished.\n        if (this.clipToTvSize || this.f_bgClipping === 0 || this.f_spClipping === 0) {\n            // Clip left 8-pixels column:\n            for (y=0;y<240;y++) {\n                for (x=0;x<8;x++) {\n                    buffer[(y<<8)+x] = 0;\n                }\n            }\n        }\n\n        if (this.clipToTvSize) {\n            // Clip right 8-pixels column too:\n            for (y=0; y<240; y++) {\n                for (x=0; x<8; x++) {\n                    buffer[(y<<8)+255-x] = 0;\n                }\n            }\n        }\n\n        // Clip top and bottom 8 pixels:\n        if (this.clipToTvSize) {\n            for (y=0; y<8; y++) {\n                for (x=0; x<256; x++) {\n                    buffer[(y<<8)+x] = 0;\n                    buffer[((239-y)<<8)+x] = 0;\n                }\n            }\n        }\n\n        if (this.nes.opts.showDisplay) {\n            this.nes.ui.writeFrame(buffer, this.prevBuffer);\n        }\n    },\n\n    updateControlReg1: function(value){\n\n        this.triggerRendering();\n\n        this.f_nmiOnVblank =    (value>>7)&1;\n        this.f_spriteSize =     (value>>5)&1;\n        this.f_bgPatternTable = (value>>4)&1;\n        this.f_spPatternTable = (value>>3)&1;\n        this.f_addrInc =        (value>>2)&1;\n        this.f_nTblAddress =     value&3;\n\n        this.regV = (value>>1)&1;\n        this.regH = value&1;\n        this.regS = (value>>4)&1;\n\n    },\n\n    updateControlReg2: function(value){\n\n        this.triggerRendering();\n\n        this.f_color =       (value>>5)&7;\n        this.f_spVisibility = (value>>4)&1;\n        this.f_bgVisibility = (value>>3)&1;\n        this.f_spClipping =   (value>>2)&1;\n        this.f_bgClipping =   (value>>1)&1;\n        this.f_dispType =      value&1;\n\n        if (this.f_dispType === 0) {\n            this.palTable.setEmphasis(this.f_color);\n        }\n        this.updatePalettes();\n    },\n\n    setStatusFlag: function(flag, value){\n        var n = 1<<flag;\n        this.nes.cpu.mem[0x2002] =\n            ((this.nes.cpu.mem[0x2002] & (255-n)) | (value?n:0));\n    },\n\n    // CPU Register $2002:\n    // Read the Status Register.\n    readStatusRegister: function(){\n\n        var tmp = this.nes.cpu.mem[0x2002];\n\n        // Reset scroll & VRAM Address toggle:\n        this.firstWrite = true;\n\n        // Clear VBlank flag:\n        this.setStatusFlag(this.STATUS_VBLANK,false);\n\n        // Fetch status data:\n        return tmp;\n\n    },\n\n    // CPU Register $2003:\n    // Write the SPR-RAM address that is used for sramWrite (Register 0x2004 in CPU memory map)\n    writeSRAMAddress: function(address) {\n        this.sramAddress = address;\n    },\n\n    // CPU Register $2004 (R):\n    // Read from SPR-RAM (Sprite RAM).\n    // The address should be set first.\n    sramLoad: function() {\n        /*short tmp = sprMem.load(sramAddress);\n        sramAddress++; // Increment address\n        sramAddress%=0x100;\n        return tmp;*/\n        return this.spriteMem[this.sramAddress];\n    },\n\n    // CPU Register $2004 (W):\n    // Write to SPR-RAM (Sprite RAM).\n    // The address should be set first.\n    sramWrite: function(value){\n        this.spriteMem[this.sramAddress] = value;\n        this.spriteRamWriteUpdate(this.sramAddress,value);\n        this.sramAddress++; // Increment address\n        this.sramAddress %= 0x100;\n    },\n\n    // CPU Register $2005:\n    // Write to scroll registers.\n    // The first write is the vertical offset, the second is the\n    // horizontal offset:\n    scrollWrite: function(value){\n        this.triggerRendering();\n\n        if (this.firstWrite) {\n            // First write, horizontal scroll:\n            this.regHT = (value>>3)&31;\n            this.regFH = value&7;\n\n        }else {\n\n            // Second write, vertical scroll:\n            this.regFV = value&7;\n            this.regVT = (value>>3)&31;\n\n        }\n        this.firstWrite = !this.firstWrite;\n\n    },\n\n    // CPU Register $2006:\n    // Sets the adress used when reading/writing from/to VRAM.\n    // The first write sets the high byte, the second the low byte.\n    writeVRAMAddress: function(address){\n\n        if (this.firstWrite) {\n\n            this.regFV = (address>>4)&3;\n            this.regV = (address>>3)&1;\n            this.regH = (address>>2)&1;\n            this.regVT = (this.regVT&7) | ((address&3)<<3);\n\n        }else {\n            this.triggerRendering();\n\n            this.regVT = (this.regVT&24) | ((address>>5)&7);\n            this.regHT = address&31;\n\n            this.cntFV = this.regFV;\n            this.cntV = this.regV;\n            this.cntH = this.regH;\n            this.cntVT = this.regVT;\n            this.cntHT = this.regHT;\n\n            this.checkSprite0(this.scanline-20);\n\n        }\n\n        this.firstWrite = !this.firstWrite;\n\n        // Invoke mapper latch:\n        this.cntsToAddress();\n        if (this.vramAddress < 0x2000) {\n            this.nes.mmap.latchAccess(this.vramAddress);\n        }\n    },\n\n    // CPU Register $2007(R):\n    // Read from PPU memory. The address should be set first.\n    vramLoad: function(){\n        var tmp;\n\n        this.cntsToAddress();\n        this.regsToAddress();\n\n        // If address is in range 0x0000-0x3EFF, return buffered values:\n        if (this.vramAddress <= 0x3EFF) {\n            tmp = this.vramBufferedReadValue;\n\n            // Update buffered value:\n            if (this.vramAddress < 0x2000) {\n                this.vramBufferedReadValue = this.vramMem[this.vramAddress];\n            }\n            else {\n                this.vramBufferedReadValue = this.mirroredLoad(\n                    this.vramAddress\n                );\n            }\n\n            // Mapper latch access:\n            if (this.vramAddress < 0x2000) {\n                this.nes.mmap.latchAccess(this.vramAddress);\n            }\n\n            // Increment by either 1 or 32, depending on d2 of Control Register 1:\n            this.vramAddress += (this.f_addrInc == 1 ? 32 : 1);\n\n            this.cntsFromAddress();\n            this.regsFromAddress();\n\n            return tmp; // Return the previous buffered value.\n        }\n\n        // No buffering in this mem range. Read normally.\n        tmp = this.mirroredLoad(this.vramAddress);\n\n        // Increment by either 1 or 32, depending on d2 of Control Register 1:\n        this.vramAddress += (this.f_addrInc == 1 ? 32 : 1);\n\n        this.cntsFromAddress();\n        this.regsFromAddress();\n\n        return tmp;\n    },\n\n    // CPU Register $2007(W):\n    // Write to PPU memory. The address should be set first.\n    vramWrite: function(value){\n\n        this.triggerRendering();\n        this.cntsToAddress();\n        this.regsToAddress();\n\n        if (this.vramAddress >= 0x2000) {\n            // Mirroring is used.\n            this.mirroredWrite(this.vramAddress,value);\n        }else {\n\n            // Write normally.\n            this.writeMem(this.vramAddress,value);\n\n            // Invoke mapper latch:\n            this.nes.mmap.latchAccess(this.vramAddress);\n\n        }\n\n        // Increment by either 1 or 32, depending on d2 of Control Register 1:\n        this.vramAddress += (this.f_addrInc==1?32:1);\n        this.regsFromAddress();\n        this.cntsFromAddress();\n\n    },\n\n    // CPU Register $4014:\n    // Write 256 bytes of main memory\n    // into Sprite RAM.\n    sramDMA: function(value){\n        var baseAddress = value * 0x100;\n        var data;\n        for (var i=this.sramAddress; i < 256; i++) {\n            data = this.nes.cpu.mem[baseAddress+i];\n            this.spriteMem[i] = data;\n            this.spriteRamWriteUpdate(i, data);\n        }\n\n        this.nes.cpu.haltCycles(513);\n\n    },\n\n    // Updates the scroll registers from a new VRAM address.\n    regsFromAddress: function(){\n\n        var address = (this.vramTmpAddress>>8)&0xFF;\n        this.regFV = (address>>4)&7;\n        this.regV = (address>>3)&1;\n        this.regH = (address>>2)&1;\n        this.regVT = (this.regVT&7) | ((address&3)<<3);\n\n        address = this.vramTmpAddress&0xFF;\n        this.regVT = (this.regVT&24) | ((address>>5)&7);\n        this.regHT = address&31;\n    },\n\n    // Updates the scroll registers from a new VRAM address.\n    cntsFromAddress: function(){\n\n        var address = (this.vramAddress>>8)&0xFF;\n        this.cntFV = (address>>4)&3;\n        this.cntV = (address>>3)&1;\n        this.cntH = (address>>2)&1;\n        this.cntVT = (this.cntVT&7) | ((address&3)<<3);\n\n        address = this.vramAddress&0xFF;\n        this.cntVT = (this.cntVT&24) | ((address>>5)&7);\n        this.cntHT = address&31;\n\n    },\n\n    regsToAddress: function(){\n        var b1  = (this.regFV&7)<<4;\n        b1 |= (this.regV&1)<<3;\n        b1 |= (this.regH&1)<<2;\n        b1 |= (this.regVT>>3)&3;\n\n        var b2  = (this.regVT&7)<<5;\n        b2 |= this.regHT&31;\n\n        this.vramTmpAddress = ((b1<<8) | b2)&0x7FFF;\n    },\n\n    cntsToAddress: function(){\n        var b1  = (this.cntFV&7)<<4;\n        b1 |= (this.cntV&1)<<3;\n        b1 |= (this.cntH&1)<<2;\n        b1 |= (this.cntVT>>3)&3;\n\n        var b2  = (this.cntVT&7)<<5;\n        b2 |= this.cntHT&31;\n\n        this.vramAddress = ((b1<<8) | b2)&0x7FFF;\n    },\n\n    incTileCounter: function(count) {\n        for (var i=count; i!==0; i--) {\n            this.cntHT++;\n            if (this.cntHT == 32) {\n                this.cntHT = 0;\n                this.cntVT++;\n                if (this.cntVT >= 30) {\n                    this.cntH++;\n                    if(this.cntH == 2) {\n                        this.cntH = 0;\n                        this.cntV++;\n                        if (this.cntV == 2) {\n                            this.cntV = 0;\n                            this.cntFV++;\n                            this.cntFV &= 0x7;\n                        }\n                    }\n                }\n            }\n        }\n    },\n\n    // Reads from memory, taking into account\n    // mirroring/mapping of address ranges.\n    mirroredLoad: function(address) {\n        return this.vramMem[this.vramMirrorTable[address]];\n    },\n\n    // Writes to memory, taking into account\n    // mirroring/mapping of address ranges.\n    mirroredWrite: function(address, value){\n        if (address>=0x3f00 && address<0x3f20) {\n            // Palette write mirroring.\n            if (address==0x3F00 || address==0x3F10) {\n                this.writeMem(0x3F00,value);\n                this.writeMem(0x3F10,value);\n\n            }else if (address==0x3F04 || address==0x3F14) {\n\n                this.writeMem(0x3F04,value);\n                this.writeMem(0x3F14,value);\n\n            }else if (address==0x3F08 || address==0x3F18) {\n\n                this.writeMem(0x3F08,value);\n                this.writeMem(0x3F18,value);\n\n            }else if (address==0x3F0C || address==0x3F1C) {\n\n                this.writeMem(0x3F0C,value);\n                this.writeMem(0x3F1C,value);\n\n            }else {\n                this.writeMem(address,value);\n            }\n\n        }else {\n\n            // Use lookup table for mirrored address:\n            if (address<this.vramMirrorTable.length) {\n                this.writeMem(this.vramMirrorTable[address],value);\n            }else {\n                // FIXME\n                alert(\"Invalid VRAM address: \"+address.toString(16));\n            }\n\n        }\n    },\n\n    triggerRendering: function(){\n        if (this.scanline >= 21 && this.scanline <= 260) {\n            // Render sprites, and combine:\n            this.renderFramePartially(\n                this.lastRenderedScanline+1,\n                this.scanline-21-this.lastRenderedScanline\n            );\n\n            // Set last rendered scanline:\n            this.lastRenderedScanline = this.scanline-21;\n        }\n    },\n\n    renderFramePartially: function(startScan, scanCount){\n        if (this.f_spVisibility == 1) {\n            this.renderSpritesPartially(startScan,scanCount,true);\n        }\n\n        if(this.f_bgVisibility == 1) {\n            var si = startScan<<8;\n            var ei = (startScan+scanCount)<<8;\n            if (ei > 0xF000) {\n                ei = 0xF000;\n            }\n            var buffer = this.buffer;\n            var bgbuffer = this.bgbuffer;\n            var pixrendered = this.pixrendered;\n            for (var destIndex=si; destIndex<ei; destIndex++) {\n                if (pixrendered[destIndex] > 0xFF) {\n                    buffer[destIndex] = bgbuffer[destIndex];\n                }\n            }\n        }\n\n        if (this.f_spVisibility == 1) {\n            this.renderSpritesPartially(startScan, scanCount, false);\n        }\n\n        this.validTileData = false;\n    },\n\n    renderBgScanline: function(bgbuffer, scan) {\n        var baseTile = (this.regS === 0 ? 0 : 256);\n        var destIndex = (scan<<8)-this.regFH;\n\n        this.curNt = this.ntable1[this.cntV+this.cntV+this.cntH];\n\n        this.cntHT = this.regHT;\n        this.cntH = this.regH;\n        this.curNt = this.ntable1[this.cntV+this.cntV+this.cntH];\n\n        if (scan<240 && (scan-this.cntFV)>=0){\n\n            var tscanoffset = this.cntFV<<3;\n            var scantile = this.scantile;\n            var attrib = this.attrib;\n            var ptTile = this.ptTile;\n            var nameTable = this.nameTable;\n            var imgPalette = this.imgPalette;\n            var pixrendered = this.pixrendered;\n            var targetBuffer = bgbuffer ? this.bgbuffer : this.buffer;\n\n            var t, tpix, att, col;\n\n            for (var tile=0;tile<32;tile++) {\n\n                if (scan>=0) {\n\n                    // Fetch tile & attrib data:\n                    if (this.validTileData) {\n                        // Get data from array:\n                        t = scantile[tile];\n                        tpix = t.pix;\n                        att = attrib[tile];\n                    }else {\n                        // Fetch data:\n                        t = ptTile[baseTile+nameTable[this.curNt].getTileIndex(this.cntHT,this.cntVT)];\n                        tpix = t.pix;\n                        att = nameTable[this.curNt].getAttrib(this.cntHT,this.cntVT);\n                        scantile[tile] = t;\n                        attrib[tile] = att;\n                    }\n\n                    // Render tile scanline:\n                    var sx = 0;\n                    var x = (tile<<3)-this.regFH;\n\n                    if (x>-8) {\n                        if (x<0) {\n                            destIndex-=x;\n                            sx = -x;\n                        }\n                        if (t.opaque[this.cntFV]) {\n                            for (;sx<8;sx++) {\n                                targetBuffer[destIndex] = imgPalette[\n                                    tpix[tscanoffset+sx]+att\n                                ];\n                                pixrendered[destIndex] |= 256;\n                                destIndex++;\n                            }\n                        }else {\n                            for (;sx<8;sx++) {\n                                col = tpix[tscanoffset+sx];\n                                if(col !== 0) {\n                                    targetBuffer[destIndex] = imgPalette[\n                                        col+att\n                                    ];\n                                    pixrendered[destIndex] |= 256;\n                                }\n                                destIndex++;\n                            }\n                        }\n                    }\n\n                }\n\n                // Increase Horizontal Tile Counter:\n                if (++this.cntHT==32) {\n                    this.cntHT=0;\n                    this.cntH++;\n                    this.cntH%=2;\n                    this.curNt = this.ntable1[(this.cntV<<1)+this.cntH];\n                }\n\n\n            }\n\n            // Tile data for one row should now have been fetched,\n            // so the data in the array is valid.\n            this.validTileData = true;\n\n        }\n\n        // update vertical scroll:\n        this.cntFV++;\n        if (this.cntFV==8) {\n            this.cntFV = 0;\n            this.cntVT++;\n            if (this.cntVT==30) {\n                this.cntVT = 0;\n                this.cntV++;\n                this.cntV%=2;\n                this.curNt = this.ntable1[(this.cntV<<1)+this.cntH];\n            }else if (this.cntVT==32) {\n                this.cntVT = 0;\n            }\n\n            // Invalidate fetched data:\n            this.validTileData = false;\n\n        }\n    },\n\n    renderSpritesPartially: function(startscan, scancount, bgPri){\n        if (this.f_spVisibility === 1) {\n\n            for (var i=0;i<64;i++) {\n                if (this.bgPriority[i]==bgPri && this.sprX[i]>=0 &&\n                        this.sprX[i]<256 && this.sprY[i]+8>=startscan &&\n                        this.sprY[i]<startscan+scancount) {\n                    // Show sprite.\n                    if (this.f_spriteSize === 0) {\n                        // 8x8 sprites\n\n                        this.srcy1 = 0;\n                        this.srcy2 = 8;\n\n                        if (this.sprY[i]<startscan) {\n                            this.srcy1 = startscan - this.sprY[i]-1;\n                        }\n\n                        if (this.sprY[i]+8 > startscan+scancount) {\n                            this.srcy2 = startscan+scancount-this.sprY[i]+1;\n                        }\n\n                        if (this.f_spPatternTable===0) {\n                            this.ptTile[this.sprTile[i]].render(this.buffer,\n                                0, this.srcy1, 8, this.srcy2, this.sprX[i],\n                                this.sprY[i]+1, this.sprCol[i], this.sprPalette,\n                                this.horiFlip[i], this.vertFlip[i], i,\n                                this.pixrendered\n                            );\n                        }else {\n                            this.ptTile[this.sprTile[i]+256].render(this.buffer, 0, this.srcy1, 8, this.srcy2, this.sprX[i], this.sprY[i]+1, this.sprCol[i], this.sprPalette, this.horiFlip[i], this.vertFlip[i], i, this.pixrendered);\n                        }\n                    }else {\n                        // 8x16 sprites\n                        var top = this.sprTile[i];\n                        if ((top&1)!==0) {\n                            top = this.sprTile[i]-1+256;\n                        }\n\n                        var srcy1 = 0;\n                        var srcy2 = 8;\n\n                        if (this.sprY[i]<startscan) {\n                            srcy1 = startscan - this.sprY[i]-1;\n                        }\n\n                        if (this.sprY[i]+8 > startscan+scancount) {\n                            srcy2 = startscan+scancount-this.sprY[i];\n                        }\n\n                        this.ptTile[top+(this.vertFlip[i]?1:0)].render(\n                            this.buffer,\n                            0,\n                            srcy1,\n                            8,\n                            srcy2,\n                            this.sprX[i],\n                            this.sprY[i]+1,\n                            this.sprCol[i],\n                            this.sprPalette,\n                            this.horiFlip[i],\n                            this.vertFlip[i],\n                            i,\n                            this.pixrendered\n                        );\n\n                        srcy1 = 0;\n                        srcy2 = 8;\n\n                        if (this.sprY[i]+8<startscan) {\n                            srcy1 = startscan - (this.sprY[i]+8+1);\n                        }\n\n                        if (this.sprY[i]+16 > startscan+scancount) {\n                            srcy2 = startscan+scancount-(this.sprY[i]+8);\n                        }\n\n                        this.ptTile[top+(this.vertFlip[i]?0:1)].render(\n                            this.buffer,\n                            0,\n                            srcy1,\n                            8,\n                            srcy2,\n                            this.sprX[i],\n                            this.sprY[i]+1+8,\n                            this.sprCol[i],\n                            this.sprPalette,\n                            this.horiFlip[i],\n                            this.vertFlip[i],\n                            i,\n                            this.pixrendered\n                        );\n\n                    }\n                }\n            }\n        }\n    },\n\n    checkSprite0: function(scan){\n\n        this.spr0HitX = -1;\n        this.spr0HitY = -1;\n\n        var toffset;\n        var tIndexAdd = (this.f_spPatternTable === 0?0:256);\n        var x, y, t, i;\n        var bufferIndex;\n        var col;\n        var bgPri;\n\n        x = this.sprX[0];\n        y = this.sprY[0]+1;\n\n        if (this.f_spriteSize === 0) {\n            // 8x8 sprites.\n\n            // Check range:\n            if (y <= scan && y + 8 > scan && x >= -7 && x < 256) {\n\n                // Sprite is in range.\n                // Draw scanline:\n                t = this.ptTile[this.sprTile[0] + tIndexAdd];\n                col = this.sprCol[0];\n                bgPri = this.bgPriority[0];\n\n                if (this.vertFlip[0]) {\n                    toffset = 7 - (scan -y);\n                }\n                else {\n                    toffset = scan - y;\n                }\n                toffset *= 8;\n\n                bufferIndex = scan * 256 + x;\n                if (this.horiFlip[0]) {\n                    for (i = 7; i >= 0; i--) {\n                        if (x >= 0 && x < 256) {\n                            if (bufferIndex>=0 && bufferIndex<61440 &&\n                                    this.pixrendered[bufferIndex] !==0 ) {\n                                if (t.pix[toffset+i] !== 0) {\n                                    this.spr0HitX = bufferIndex % 256;\n                                    this.spr0HitY = scan;\n                                    return true;\n                                }\n                            }\n                        }\n                        x++;\n                        bufferIndex++;\n                    }\n                }\n                else {\n                    for (i = 0; i < 8; i++) {\n                        if (x >= 0 && x < 256) {\n                            if (bufferIndex >= 0 && bufferIndex < 61440 &&\n                                    this.pixrendered[bufferIndex] !==0 ) {\n                                if (t.pix[toffset+i] !== 0) {\n                                    this.spr0HitX = bufferIndex % 256;\n                                    this.spr0HitY = scan;\n                                    return true;\n                                }\n                            }\n                        }\n                        x++;\n                        bufferIndex++;\n                    }\n                }\n            }\n        }\n        else {\n            // 8x16 sprites:\n\n            // Check range:\n            if (y <= scan && y + 16 > scan && x >= -7 && x < 256) {\n                // Sprite is in range.\n                // Draw scanline:\n\n                if (this.vertFlip[0]) {\n                    toffset = 15-(scan-y);\n                }else {\n                    toffset = scan-y;\n                }\n\n                if (toffset<8) {\n                    // first half of sprite.\n                    t = this.ptTile[this.sprTile[0]+(this.vertFlip[0]?1:0)+((this.sprTile[0]&1)!==0?255:0)];\n                }else {\n                    // second half of sprite.\n                    t = this.ptTile[this.sprTile[0]+(this.vertFlip[0]?0:1)+((this.sprTile[0]&1)!==0?255:0)];\n                    if (this.vertFlip[0]) {\n                        toffset = 15-toffset;\n                    }\n                    else {\n                        toffset -= 8;\n                    }\n                }\n                toffset*=8;\n                col = this.sprCol[0];\n                bgPri = this.bgPriority[0];\n\n                bufferIndex = scan*256+x;\n                if (this.horiFlip[0]) {\n                    for (i=7;i>=0;i--) {\n                        if (x>=0 && x<256) {\n                            if (bufferIndex>=0 && bufferIndex<61440 && this.pixrendered[bufferIndex]!==0) {\n                                if (t.pix[toffset+i] !== 0) {\n                                    this.spr0HitX = bufferIndex%256;\n                                    this.spr0HitY = scan;\n                                    return true;\n                                }\n                            }\n                        }\n                        x++;\n                        bufferIndex++;\n                    }\n\n                }\n                else {\n\n                    for (i=0;i<8;i++) {\n                        if (x>=0 && x<256) {\n                            if (bufferIndex>=0 && bufferIndex<61440 && this.pixrendered[bufferIndex]!==0) {\n                                if (t.pix[toffset+i] !== 0) {\n                                    this.spr0HitX = bufferIndex%256;\n                                    this.spr0HitY = scan;\n                                    return true;\n                                }\n                            }\n                        }\n                        x++;\n                        bufferIndex++;\n                    }\n\n                }\n\n            }\n\n        }\n\n        return false;\n    },\n\n    // This will write to PPU memory, and\n    // update internally buffered data\n    // appropriately.\n    writeMem: function(address, value){\n        this.vramMem[address] = value;\n\n        // Update internally buffered data:\n        if (address < 0x2000) {\n            this.vramMem[address] = value;\n            this.patternWrite(address,value);\n        }\n        else if (address >=0x2000 && address <0x23c0) {\n            this.nameTableWrite(this.ntable1[0], address - 0x2000, value);\n        }\n        else if (address >=0x23c0 && address <0x2400) {\n            this.attribTableWrite(this.ntable1[0],address-0x23c0,value);\n        }\n        else if (address >=0x2400 && address <0x27c0) {\n            this.nameTableWrite(this.ntable1[1],address-0x2400,value);\n        }\n        else if (address >=0x27c0 && address <0x2800) {\n            this.attribTableWrite(this.ntable1[1],address-0x27c0,value);\n        }\n        else if (address >=0x2800 && address <0x2bc0) {\n            this.nameTableWrite(this.ntable1[2],address-0x2800,value);\n        }\n        else if (address >=0x2bc0 && address <0x2c00) {\n            this.attribTableWrite(this.ntable1[2],address-0x2bc0,value);\n        }\n        else if (address >=0x2c00 && address <0x2fc0) {\n            this.nameTableWrite(this.ntable1[3],address-0x2c00,value);\n        }\n        else if (address >=0x2fc0 && address <0x3000) {\n            this.attribTableWrite(this.ntable1[3],address-0x2fc0,value);\n        }\n        else if (address >=0x3f00 && address <0x3f20) {\n            this.updatePalettes();\n        }\n    },\n\n    // Reads data from $3f00 to $f20\n    // into the two buffered palettes.\n    updatePalettes: function(){\n        var i;\n\n        for (i = 0; i < 16; i++) {\n            if (this.f_dispType === 0) {\n                this.imgPalette[i] = this.palTable.getEntry(\n                    this.vramMem[0x3f00 + i] & 63\n                );\n            }\n            else {\n                this.imgPalette[i] = this.palTable.getEntry(\n                    this.vramMem[0x3f00 + i] & 32\n                );\n            }\n        }\n        for (i = 0; i < 16; i++) {\n            if (this.f_dispType === 0) {\n                this.sprPalette[i] = this.palTable.getEntry(\n                    this.vramMem[0x3f10 + i] & 63\n                );\n            }\n            else {\n                this.sprPalette[i] = this.palTable.getEntry(\n                    this.vramMem[0x3f10 + i] & 32\n                );\n            }\n        }\n    },\n\n    // Updates the internal pattern\n    // table buffers with this new byte.\n    // In vNES, there is a version of this with 4 arguments which isn't used.\n    patternWrite: function(address, value){\n        var tileIndex = Math.floor(address / 16);\n        var leftOver = address%16;\n        if (leftOver<8) {\n            this.ptTile[tileIndex].setScanline(\n                leftOver,\n                value,\n                this.vramMem[address+8]\n            );\n        }\n        else {\n            this.ptTile[tileIndex].setScanline(\n                leftOver-8,\n                this.vramMem[address-8],\n                value\n            );\n        }\n    },\n\n    // Updates the internal name table buffers\n    // with this new byte.\n    nameTableWrite: function(index, address, value){\n        this.nameTable[index].tile[address] = value;\n\n        // Update Sprite #0 hit:\n        //updateSpr0Hit();\n        this.checkSprite0(this.scanline-20);\n    },\n\n    // Updates the internal pattern\n    // table buffers with this new attribute\n    // table byte.\n    attribTableWrite: function(index, address, value){\n        this.nameTable[index].writeAttrib(address,value);\n    },\n\n    // Updates the internally buffered sprite\n    // data with this new byte of info.\n    spriteRamWriteUpdate: function(address, value) {\n        var tIndex = Math.floor(address / 4);\n\n        if (tIndex === 0) {\n            //updateSpr0Hit();\n            this.checkSprite0(this.scanline - 20);\n        }\n\n        if (address % 4 === 0) {\n            // Y coordinate\n            this.sprY[tIndex] = value;\n        }\n        else if (address % 4 == 1) {\n            // Tile index\n            this.sprTile[tIndex] = value;\n        }\n        else if (address % 4 == 2) {\n            // Attributes\n            this.vertFlip[tIndex] = ((value & 0x80) !== 0);\n            this.horiFlip[tIndex] = ((value & 0x40) !==0 );\n            this.bgPriority[tIndex] = ((value & 0x20) !== 0);\n            this.sprCol[tIndex] = (value & 3) << 2;\n\n        }\n        else if (address % 4 == 3) {\n            // X coordinate\n            this.sprX[tIndex] = value;\n        }\n    },\n\n    doNMI: function() {\n        // Set VBlank flag:\n        this.setStatusFlag(this.STATUS_VBLANK,true);\n        //nes.getCpu().doNonMaskableInterrupt();\n        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n    },\n\n    JSON_PROPERTIES: [\n        // Memory\n        'vramMem', 'spriteMem',\n        // Counters\n        'cntFV', 'cntV', 'cntH', 'cntVT', 'cntHT',\n        // Registers\n        'regFV', 'regV', 'regH', 'regVT', 'regHT', 'regFH', 'regS',\n        // VRAM addr\n        'vramAddress', 'vramTmpAddress',\n        // Control/Status registers\n        'f_nmiOnVblank', 'f_spriteSize', 'f_bgPatternTable', 'f_spPatternTable',\n        'f_addrInc', 'f_nTblAddress', 'f_color', 'f_spVisibility',\n        'f_bgVisibility', 'f_spClipping', 'f_bgClipping', 'f_dispType',\n        // VRAM I/O\n        'vramBufferedReadValue', 'firstWrite',\n        // Mirroring\n        'currentMirroring', 'vramMirrorTable', 'ntable1',\n        // SPR-RAM I/O\n        'sramAddress',\n        // Sprites. Most sprite data is rebuilt from spriteMem\n        'hitSpr0',\n        // Palettes\n        'sprPalette', 'imgPalette',\n        // Rendering progression\n        'curX', 'scanline', 'lastRenderedScanline', 'curNt', 'scantile',\n        // Used during rendering\n        'attrib', 'buffer', 'bgbuffer', 'pixrendered',\n        // Misc\n        'requestEndFrame', 'nmiOk', 'dummyCycleToggle', 'nmiCounter',\n        'validTileData', 'scanlineAlreadyRendered'\n    ],\n\n    toJSON: function() {\n        var i;\n        var state = utils.toJSON(this);\n\n        state.nameTable = [];\n        for (i = 0; i < this.nameTable.length; i++) {\n            state.nameTable[i] = this.nameTable[i].toJSON();\n        }\n\n        state.ptTile = [];\n        for (i = 0; i < this.ptTile.length; i++) {\n            state.ptTile[i] = this.ptTile[i].toJSON();\n        }\n\n        return state;\n    },\n\n    fromJSON: function(state) {\n        var i;\n\n        utils.fromJSON(this, state);\n\n        for (i = 0; i < this.nameTable.length; i++) {\n            this.nameTable[i].fromJSON(state.nameTable[i]);\n        }\n\n        for (i = 0; i < this.ptTile.length; i++) {\n            this.ptTile[i].fromJSON(state.ptTile[i]);\n        }\n\n        // Sprite data:\n        for (i = 0; i < this.spriteMem.length; i++) {\n            this.spriteRamWriteUpdate(i, this.spriteMem[i]);\n        }\n    }\n};\n\nPPU.NameTable = function(width, height, name) {\n    this.width = width;\n    this.height = height;\n    this.name = name;\n\n    this.tile = new Array(width*height);\n    this.attrib = new Array(width*height);\n};\n\nPPU.NameTable.prototype = {\n    getTileIndex: function(x, y){\n        return this.tile[y*this.width+x];\n    },\n\n    getAttrib: function(x, y){\n        return this.attrib[y*this.width+x];\n    },\n\n    writeAttrib: function(index, value){\n        var basex = (index % 8) * 4;\n        var basey = Math.floor(index / 8) * 4;\n        var add;\n        var tx, ty;\n        var attindex;\n\n        for (var sqy=0;sqy<2;sqy++) {\n            for (var sqx=0;sqx<2;sqx++) {\n                add = (value>>(2*(sqy*2+sqx)))&3;\n                for (var y=0;y<2;y++) {\n                    for (var x=0;x<2;x++) {\n                        tx = basex+sqx*2+x;\n                        ty = basey+sqy*2+y;\n                        attindex = ty*this.width+tx;\n                        this.attrib[ty*this.width+tx] = (add<<2)&12;\n                    }\n                }\n            }\n        }\n    },\n\n    toJSON: function() {\n        return {\n            'tile': this.tile,\n            'attrib': this.attrib\n        };\n    },\n\n    fromJSON: function(s) {\n        this.tile = s.tile;\n        this.attrib = s.attrib;\n    }\n};\n\n\nPPU.PaletteTable = function() {\n    this.curTable = new Array(64);\n    this.emphTable = new Array(8);\n    this.currentEmph = -1;\n};\n\nPPU.PaletteTable.prototype = {\n    reset: function() {\n        this.setEmphasis(0);\n    },\n\n    loadNTSCPalette: function() {\n        this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n        this.makeTables();\n        this.setEmphasis(0);\n    },\n\n    loadPALPalette: function() {\n        this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n        this.makeTables();\n        this.setEmphasis(0);\n    },\n\n    makeTables: function(){\n        var r, g, b, col, i, rFactor, gFactor, bFactor;\n\n        // Calculate a table for each possible emphasis setting:\n        for (var emph = 0; emph < 8; emph++) {\n\n            // Determine color component factors:\n            rFactor = 1.0;\n            gFactor = 1.0;\n            bFactor = 1.0;\n\n            if ((emph & 1) !== 0) {\n                rFactor = 0.75;\n                bFactor = 0.75;\n            }\n            if ((emph & 2) !== 0) {\n                rFactor = 0.75;\n                gFactor = 0.75;\n            }\n            if ((emph & 4) !== 0) {\n                gFactor = 0.75;\n                bFactor = 0.75;\n            }\n\n            this.emphTable[emph] = new Array(64);\n\n            // Calculate table:\n            for (i = 0; i < 64; i++) {\n                col = this.curTable[i];\n                r = Math.floor(this.getRed(col) * rFactor);\n                g = Math.floor(this.getGreen(col) * gFactor);\n                b = Math.floor(this.getBlue(col) * bFactor);\n                this.emphTable[emph][i] = this.getRgb(r, g, b);\n            }\n        }\n    },\n\n    setEmphasis: function(emph){\n        if (emph != this.currentEmph) {\n            this.currentEmph = emph;\n            for (var i = 0; i < 64; i++) {\n                this.curTable[i] = this.emphTable[emph][i];\n            }\n        }\n    },\n\n    getEntry: function(yiq){\n        return this.curTable[yiq];\n    },\n\n    getRed: function(rgb){\n        return (rgb>>16)&0xFF;\n    },\n\n    getGreen: function(rgb){\n        return (rgb>>8)&0xFF;\n    },\n\n    getBlue: function(rgb){\n        return rgb&0xFF;\n    },\n\n    getRgb: function(r, g, b){\n        return ((r<<16)|(g<<8)|(b));\n    },\n\n    loadDefaultPalette: function(){\n        this.curTable[ 0] = this.getRgb(117,117,117);\n        this.curTable[ 1] = this.getRgb( 39, 27,143);\n        this.curTable[ 2] = this.getRgb(  0,  0,171);\n        this.curTable[ 3] = this.getRgb( 71,  0,159);\n        this.curTable[ 4] = this.getRgb(143,  0,119);\n        this.curTable[ 5] = this.getRgb(171,  0, 19);\n        this.curTable[ 6] = this.getRgb(167,  0,  0);\n        this.curTable[ 7] = this.getRgb(127, 11,  0);\n        this.curTable[ 8] = this.getRgb( 67, 47,  0);\n        this.curTable[ 9] = this.getRgb(  0, 71,  0);\n        this.curTable[10] = this.getRgb(  0, 81,  0);\n        this.curTable[11] = this.getRgb(  0, 63, 23);\n        this.curTable[12] = this.getRgb( 27, 63, 95);\n        this.curTable[13] = this.getRgb(  0,  0,  0);\n        this.curTable[14] = this.getRgb(  0,  0,  0);\n        this.curTable[15] = this.getRgb(  0,  0,  0);\n        this.curTable[16] = this.getRgb(188,188,188);\n        this.curTable[17] = this.getRgb(  0,115,239);\n        this.curTable[18] = this.getRgb( 35, 59,239);\n        this.curTable[19] = this.getRgb(131,  0,243);\n        this.curTable[20] = this.getRgb(191,  0,191);\n        this.curTable[21] = this.getRgb(231,  0, 91);\n        this.curTable[22] = this.getRgb(219, 43,  0);\n        this.curTable[23] = this.getRgb(203, 79, 15);\n        this.curTable[24] = this.getRgb(139,115,  0);\n        this.curTable[25] = this.getRgb(  0,151,  0);\n        this.curTable[26] = this.getRgb(  0,171,  0);\n        this.curTable[27] = this.getRgb(  0,147, 59);\n        this.curTable[28] = this.getRgb(  0,131,139);\n        this.curTable[29] = this.getRgb(  0,  0,  0);\n        this.curTable[30] = this.getRgb(  0,  0,  0);\n        this.curTable[31] = this.getRgb(  0,  0,  0);\n        this.curTable[32] = this.getRgb(255,255,255);\n        this.curTable[33] = this.getRgb( 63,191,255);\n        this.curTable[34] = this.getRgb( 95,151,255);\n        this.curTable[35] = this.getRgb(167,139,253);\n        this.curTable[36] = this.getRgb(247,123,255);\n        this.curTable[37] = this.getRgb(255,119,183);\n        this.curTable[38] = this.getRgb(255,119, 99);\n        this.curTable[39] = this.getRgb(255,155, 59);\n        this.curTable[40] = this.getRgb(243,191, 63);\n        this.curTable[41] = this.getRgb(131,211, 19);\n        this.curTable[42] = this.getRgb( 79,223, 75);\n        this.curTable[43] = this.getRgb( 88,248,152);\n        this.curTable[44] = this.getRgb(  0,235,219);\n        this.curTable[45] = this.getRgb(  0,  0,  0);\n        this.curTable[46] = this.getRgb(  0,  0,  0);\n        this.curTable[47] = this.getRgb(  0,  0,  0);\n        this.curTable[48] = this.getRgb(255,255,255);\n        this.curTable[49] = this.getRgb(171,231,255);\n        this.curTable[50] = this.getRgb(199,215,255);\n        this.curTable[51] = this.getRgb(215,203,255);\n        this.curTable[52] = this.getRgb(255,199,255);\n        this.curTable[53] = this.getRgb(255,199,219);\n        this.curTable[54] = this.getRgb(255,191,179);\n        this.curTable[55] = this.getRgb(255,219,171);\n        this.curTable[56] = this.getRgb(255,231,163);\n        this.curTable[57] = this.getRgb(227,255,163);\n        this.curTable[58] = this.getRgb(171,243,191);\n        this.curTable[59] = this.getRgb(179,255,207);\n        this.curTable[60] = this.getRgb(159,255,243);\n        this.curTable[61] = this.getRgb(  0,  0,  0);\n        this.curTable[62] = this.getRgb(  0,  0,  0);\n        this.curTable[63] = this.getRgb(  0,  0,  0);\n\n        this.makeTables();\n        this.setEmphasis(0);\n    }\n};\n\nPPU.Tile = function() {\n    // Tile data:\n    this.pix = new Array(64);\n\n    this.fbIndex = null;\n    this.tIndex = null;\n    this.x = null;\n    this.y = null;\n    this.w = null;\n    this.h = null;\n    this.incX = null;\n    this.incY = null;\n    this.palIndex = null;\n    this.tpri = null;\n    this.c = null;\n    this.initialized = false;\n    this.opaque = new Array(8);\n};\n\nPPU.Tile.prototype = {\n    setBuffer: function(scanline){\n        for (this.y=0;this.y<8;this.y++) {\n            this.setScanline(this.y,scanline[this.y],scanline[this.y+8]);\n        }\n    },\n\n    setScanline: function(sline, b1, b2){\n        this.initialized = true;\n        this.tIndex = sline<<3;\n        for (this.x = 0; this.x < 8; this.x++) {\n            this.pix[this.tIndex + this.x] = ((b1 >> (7 - this.x)) & 1) +\n                    (((b2 >> (7 - this.x)) & 1) << 1);\n            if(this.pix[this.tIndex+this.x] === 0) {\n                this.opaque[sline] = false;\n            }\n        }\n    },\n\n    render: function(buffer, srcx1, srcy1, srcx2, srcy2, dx, dy, palAdd, palette, flipHorizontal, flipVertical, pri, priTable) {\n\n        if (dx<-7 || dx>=256 || dy<-7 || dy>=240) {\n            return;\n        }\n\n        this.w=srcx2-srcx1;\n        this.h=srcy2-srcy1;\n\n        if (dx<0) {\n            srcx1-=dx;\n        }\n        if (dx+srcx2>=256) {\n            srcx2=256-dx;\n        }\n\n        if (dy<0) {\n            srcy1-=dy;\n        }\n        if (dy+srcy2>=240) {\n            srcy2=240-dy;\n        }\n\n        if (!flipHorizontal && !flipVertical) {\n\n            this.fbIndex = (dy<<8)+dx;\n            this.tIndex = 0;\n            for (this.y=0;this.y<8;this.y++) {\n                for (this.x=0;this.x<8;this.x++) {\n                    if (this.x>=srcx1 && this.x<srcx2 && this.y>=srcy1 && this.y<srcy2) {\n                        this.palIndex = this.pix[this.tIndex];\n                        this.tpri = priTable[this.fbIndex];\n                        if (this.palIndex!==0 && pri<=(this.tpri&0xFF)) {\n                            //console.log(\"Rendering upright tile to buffer\");\n                            buffer[this.fbIndex] = palette[this.palIndex+palAdd];\n                            this.tpri = (this.tpri&0xF00)|pri;\n                            priTable[this.fbIndex] =this.tpri;\n                        }\n                    }\n                    this.fbIndex++;\n                    this.tIndex++;\n                }\n                this.fbIndex-=8;\n                this.fbIndex+=256;\n            }\n\n        }else if (flipHorizontal && !flipVertical) {\n\n            this.fbIndex = (dy<<8)+dx;\n            this.tIndex = 7;\n            for (this.y=0;this.y<8;this.y++) {\n                for (this.x=0;this.x<8;this.x++) {\n                    if (this.x>=srcx1 && this.x<srcx2 && this.y>=srcy1 && this.y<srcy2) {\n                        this.palIndex = this.pix[this.tIndex];\n                        this.tpri = priTable[this.fbIndex];\n                        if (this.palIndex!==0 && pri<=(this.tpri&0xFF)) {\n                            buffer[this.fbIndex] = palette[this.palIndex+palAdd];\n                            this.tpri = (this.tpri&0xF00)|pri;\n                            priTable[this.fbIndex] =this.tpri;\n                        }\n                    }\n                    this.fbIndex++;\n                    this.tIndex--;\n                }\n                this.fbIndex-=8;\n                this.fbIndex+=256;\n                this.tIndex+=16;\n            }\n\n        }\n        else if(flipVertical && !flipHorizontal) {\n\n            this.fbIndex = (dy<<8)+dx;\n            this.tIndex = 56;\n            for (this.y=0;this.y<8;this.y++) {\n                for (this.x=0;this.x<8;this.x++) {\n                    if (this.x>=srcx1 && this.x<srcx2 && this.y>=srcy1 && this.y<srcy2) {\n                        this.palIndex = this.pix[this.tIndex];\n                        this.tpri = priTable[this.fbIndex];\n                        if (this.palIndex!==0 && pri<=(this.tpri&0xFF)) {\n                            buffer[this.fbIndex] = palette[this.palIndex+palAdd];\n                            this.tpri = (this.tpri&0xF00)|pri;\n                            priTable[this.fbIndex] =this.tpri;\n                        }\n                    }\n                    this.fbIndex++;\n                    this.tIndex++;\n                }\n                this.fbIndex-=8;\n                this.fbIndex+=256;\n                this.tIndex-=16;\n            }\n\n        }\n        else {\n            this.fbIndex = (dy<<8)+dx;\n            this.tIndex = 63;\n            for (this.y=0;this.y<8;this.y++) {\n                for (this.x=0;this.x<8;this.x++) {\n                    if (this.x>=srcx1 && this.x<srcx2 && this.y>=srcy1 && this.y<srcy2) {\n                        this.palIndex = this.pix[this.tIndex];\n                        this.tpri = priTable[this.fbIndex];\n                        if (this.palIndex!==0 && pri<=(this.tpri&0xFF)) {\n                            buffer[this.fbIndex] = palette[this.palIndex+palAdd];\n                            this.tpri = (this.tpri&0xF00)|pri;\n                            priTable[this.fbIndex] =this.tpri;\n                        }\n                    }\n                    this.fbIndex++;\n                    this.tIndex--;\n                }\n                this.fbIndex-=8;\n                this.fbIndex+=256;\n            }\n\n        }\n\n    },\n\n    isTransparent: function(x, y){\n        return (this.pix[(y << 3) + x] === 0);\n    },\n\n    toJSON: function() {\n        return {\n            'opaque': this.opaque,\n            'pix': this.pix\n        };\n    },\n\n    fromJSON: function(s) {\n        this.opaque = s.opaque;\n        this.pix = s.pix;\n    }\n};\n\nexport default PPU;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/ppu.js\n **/","/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst PAPU = function(nes) {\n    this.nes = nes;\n\n    this.square1 = new PAPU.ChannelSquare(this, true);\n    this.square2 = new PAPU.ChannelSquare(this, false);\n    this.triangle = new PAPU.ChannelTriangle(this);\n    this.noise = new PAPU.ChannelNoise(this);\n    this.dmc = new PAPU.ChannelDM(this);\n\n    this.frameIrqCounter = null;\n    this.frameIrqCounterMax = 4;\n    this.initCounter = 2048;\n    this.channelEnableValue = null;\n\n    this.bufferSize = 8192;\n    this.bufferIndex = 0;\n    this.sampleRate = 44100;\n\n    this.lengthLookup = null;\n    this.dmcFreqLookup = null;\n    this.noiseWavelengthLookup = null;\n    this.square_table = null;\n    this.tnd_table = null;\n    this.sampleBuffer = new Array(this.bufferSize*2);\n\n    this.frameIrqEnabled = false;\n    this.frameIrqActive = null;\n    this.frameClockNow = null;\n    this.startedPlaying=false;\n    this.recordOutput = false;\n    this.initingHardware = false;\n\n    this.masterFrameCounter = null;\n    this.derivedFrameCounter = null;\n    this.countSequence = null;\n    this.sampleTimer = null;\n    this.frameTime = null;\n    this.sampleTimerMax = null;\n    this.sampleCount = null;\n    this.triValue = 0;\n\n    this.smpSquare1 = null;\n    this.smpSquare2 = null;\n    this.smpTriangle = null;\n    this.smpDmc = null;\n    this.accCount = null;\n\n    // DC removal vars:\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n    this.smpAccumL = 0;\n    this.smpAccumR = 0;\n\n    // DAC range:\n    this.dacRange = 0;\n    this.dcValue = 0;\n\n    // Master volume:\n    this.masterVolume = 256;\n\n    // Stereo positioning:\n    this.stereoPosLSquare1 = null;\n    this.stereoPosLSquare2 = null;\n    this.stereoPosLTriangle = null;\n    this.stereoPosLNoise = null;\n    this.stereoPosLDMC = null;\n    this.stereoPosRSquare1 = null;\n    this.stereoPosRSquare2 = null;\n    this.stereoPosRTriangle = null;\n    this.stereoPosRNoise = null;\n    this.stereoPosRDMC = null;\n\n    this.extraCycles = null;\n\n    this.maxSample = null;\n    this.minSample = null;\n\n    // Panning:\n    this.panning = [80, 170, 100, 150, 128];\n    this.setPanning(this.panning);\n\n    // Initialize lookup tables:\n    this.initLengthLookup();\n    this.initDmcFrequencyLookup();\n    this.initNoiseWavelengthLookup();\n    this.initDACtables();\n\n    // Init sound registers:\n    for (var i = 0; i < 0x14; i++) {\n        if (i === 0x10){\n            this.writeReg(0x4010, 0x10);\n        }\n        else {\n            this.writeReg(0x4000 + i, 0);\n        }\n    }\n\n    this.reset();\n};\n\nPAPU.prototype = {\n    reset: function() {\n        this.sampleRate = this.nes.opts.sampleRate;\n        this.sampleTimerMax = Math.floor(\n            (1024.0 * this.nes.opts.CPU_FREQ_NTSC *\n                this.nes.opts.preferredFrameRate) /\n                (this.sampleRate * 60.0)\n        );\n\n        this.frameTime = Math.floor(\n            (14915.0 * this.nes.opts.preferredFrameRate) / 60.0\n        );\n\n        this.sampleTimer = 0;\n        this.bufferIndex = 0;\n\n        this.updateChannelEnable(0);\n        this.masterFrameCounter = 0;\n        this.derivedFrameCounter = 0;\n        this.countSequence = 0;\n        this.sampleCount = 0;\n        this.initCounter = 2048;\n        this.frameIrqEnabled = false;\n        this.initingHardware = false;\n\n        this.resetCounter();\n\n        this.square1.reset();\n        this.square2.reset();\n        this.triangle.reset();\n        this.noise.reset();\n        this.dmc.reset();\n\n        this.bufferIndex = 0;\n        this.accCount = 0;\n        this.smpSquare1 = 0;\n        this.smpSquare2 = 0;\n        this.smpTriangle = 0;\n        this.smpDmc = 0;\n\n        this.frameIrqEnabled = false;\n        this.frameIrqCounterMax = 4;\n\n        this.channelEnableValue = 0xFF;\n        this.startedPlaying = false;\n        this.prevSampleL = 0;\n        this.prevSampleR = 0;\n        this.smpAccumL = 0;\n        this.smpAccumR = 0;\n\n        this.maxSample = -500000;\n        this.minSample = 500000;\n    },\n\n    readReg: function(address){\n        // Read 0x4015:\n        var tmp = 0;\n        tmp |= (this.square1.getLengthStatus()   );\n        tmp |= (this.square2.getLengthStatus() <<1);\n        tmp |= (this.triangle.getLengthStatus()<<2);\n        tmp |= (this.noise.getLengthStatus()   <<3);\n        tmp |= (this.dmc.getLengthStatus()     <<4);\n        tmp |= (((this.frameIrqActive && this.frameIrqEnabled)? 1 : 0) << 6);\n        tmp |= (this.dmc.getIrqStatus()        <<7);\n\n        this.frameIrqActive = false;\n        this.dmc.irqGenerated = false;\n\n        return tmp & 0xFFFF;\n    },\n\n    writeReg: function(address, value){\n        if (address >= 0x4000 && address < 0x4004) {\n            // Square Wave 1 Control\n            this.square1.writeReg(address, value);\n            ////System.out.println(\"Square Write\");\n        }\n        else if (address >= 0x4004 && address < 0x4008) {\n            // Square 2 Control\n            this.square2.writeReg(address, value);\n        }\n        else if (address >= 0x4008 && address < 0x400C) {\n            // Triangle Control\n            this.triangle.writeReg(address, value);\n        }\n        else if (address >= 0x400C && address <= 0x400F) {\n            // Noise Control\n            this.noise.writeReg(address, value);\n        }\n        else if (address === 0x4010){\n            // DMC Play mode & DMA frequency\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4011){\n            // DMC Delta Counter\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4012){\n            // DMC Play code starting address\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4013){\n            // DMC Play code length\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4015){\n            // Channel enable\n            this.updateChannelEnable(value);\n\n            if (value !== 0 && this.initCounter > 0) {\n                // Start hardware initialization\n                this.initingHardware = true;\n            }\n\n            // DMC/IRQ Status\n            this.dmc.writeReg(address, value);\n        }\n        else if (address === 0x4017) {\n            // Frame counter control\n            this.countSequence = (value>>7)&1;\n            this.masterFrameCounter = 0;\n            this.frameIrqActive = false;\n\n            if (((value>>6)&0x1)===0){\n                this.frameIrqEnabled = true;\n            }\n            else {\n                this.frameIrqEnabled = false;\n            }\n\n            if (this.countSequence === 0) {\n                // NTSC:\n                this.frameIrqCounterMax = 4;\n                this.derivedFrameCounter = 4;\n            }\n            else {\n                // PAL:\n                this.frameIrqCounterMax = 5;\n                this.derivedFrameCounter = 0;\n                this.frameCounterTick();\n            }\n        }\n    },\n\n    resetCounter: function(){\n        if (this.countSequence === 0) {\n            this.derivedFrameCounter = 4;\n        }else{\n            this.derivedFrameCounter = 0;\n        }\n    },\n\n    // Updates channel enable status.\n    // This is done on writes to the\n    // channel enable register (0x4015),\n    // and when the user enables/disables channels\n    // in the GUI.\n    updateChannelEnable: function(value){\n        this.channelEnableValue = value&0xFFFF;\n        this.square1.setEnabled((value&1) !== 0);\n        this.square2.setEnabled((value&2) !== 0);\n        this.triangle.setEnabled((value&4) !== 0);\n        this.noise.setEnabled((value&8) !== 0);\n        this.dmc.setEnabled((value&16) !== 0);\n    },\n\n    // Clocks the frame counter. It should be clocked at\n    // twice the cpu speed, so the cycles will be\n    // divided by 2 for those counters that are\n    // clocked at cpu speed.\n    clockFrameCounter: function(nCycles){\n        if (this.initCounter > 0) {\n            if (this.initingHardware) {\n                this.initCounter -= nCycles;\n                if (this.initCounter <= 0) {\n                    this.initingHardware = false;\n                }\n                return;\n            }\n        }\n\n        // Don't process ticks beyond next sampling:\n        nCycles += this.extraCycles;\n        var maxCycles = this.sampleTimerMax-this.sampleTimer;\n        if ((nCycles<<10) > maxCycles) {\n\n            this.extraCycles = ((nCycles<<10) - maxCycles)>>10;\n            nCycles -= this.extraCycles;\n\n        }else{\n\n            this.extraCycles = 0;\n\n        }\n\n        var dmc = this.dmc;\n        var triangle = this.triangle;\n        var square1 = this.square1;\n        var square2 = this.square2;\n        var noise = this.noise;\n\n        // Clock DMC:\n        if (dmc.isEnabled) {\n\n            dmc.shiftCounter-=(nCycles<<3);\n            while(dmc.shiftCounter<=0 && dmc.dmaFrequency>0){\n                dmc.shiftCounter += dmc.dmaFrequency;\n                dmc.clockDmc();\n            }\n\n        }\n\n        // Clock Triangle channel Prog timer:\n        if (triangle.progTimerMax>0) {\n\n            triangle.progTimerCount -= nCycles;\n            while(triangle.progTimerCount <= 0){\n\n                triangle.progTimerCount += triangle.progTimerMax+1;\n                if (triangle.linearCounter>0 && triangle.lengthCounter>0) {\n\n                    triangle.triangleCounter++;\n                    triangle.triangleCounter &= 0x1F;\n\n                    if (triangle.isEnabled) {\n                        if (triangle.triangleCounter>=0x10) {\n                            // Normal value.\n                            triangle.sampleValue = (triangle.triangleCounter&0xF);\n                        }else{\n                            // Inverted value.\n                            triangle.sampleValue = (0xF - (triangle.triangleCounter&0xF));\n                        }\n                        triangle.sampleValue <<= 4;\n                    }\n                }\n            }\n        }\n\n        // Clock Square channel 1 Prog timer:\n        square1.progTimerCount -= nCycles;\n        if (square1.progTimerCount <= 0) {\n\n            square1.progTimerCount += (square1.progTimerMax+1)<<1;\n\n            square1.squareCounter++;\n            square1.squareCounter&=0x7;\n            square1.updateSampleValue();\n\n        }\n\n        // Clock Square channel 2 Prog timer:\n        square2.progTimerCount -= nCycles;\n        if (square2.progTimerCount <= 0) {\n\n            square2.progTimerCount += (square2.progTimerMax+1)<<1;\n\n            square2.squareCounter++;\n            square2.squareCounter&=0x7;\n            square2.updateSampleValue();\n\n        }\n\n        // Clock noise channel Prog timer:\n        var acc_c = nCycles;\n        if (noise.progTimerCount-acc_c > 0) {\n\n            // Do all cycles at once:\n            noise.progTimerCount -= acc_c;\n            noise.accCount       += acc_c;\n            noise.accValue       += acc_c * noise.sampleValue;\n\n        }else{\n\n            // Slow-step:\n            while((acc_c--) > 0){\n\n                if (--noise.progTimerCount <= 0 && noise.progTimerMax>0) {\n\n                    // Update noise shift register:\n                    noise.shiftReg <<= 1;\n                    noise.tmp = (((noise.shiftReg << (noise.randomMode===0?1:6)) ^ noise.shiftReg) & 0x8000 );\n                    if (noise.tmp !== 0) {\n\n                        // Sample value must be 0.\n                        noise.shiftReg |= 0x01;\n                        noise.randomBit = 0;\n                        noise.sampleValue = 0;\n\n                    }else{\n\n                        // Find sample value:\n                        noise.randomBit = 1;\n                        if (noise.isEnabled && noise.lengthCounter>0) {\n                            noise.sampleValue = noise.masterVolume;\n                        }else{\n                            noise.sampleValue = 0;\n                        }\n\n                    }\n\n                    noise.progTimerCount += noise.progTimerMax;\n\n                }\n\n                noise.accValue += noise.sampleValue;\n                noise.accCount++;\n\n            }\n        }\n\n\n        // Frame IRQ handling:\n        if (this.frameIrqEnabled && this.frameIrqActive){\n            this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n        }\n\n        // Clock frame counter at double CPU speed:\n        this.masterFrameCounter += (nCycles<<1);\n        if (this.masterFrameCounter >= this.frameTime) {\n            // 240Hz tick:\n            this.masterFrameCounter -= this.frameTime;\n            this.frameCounterTick();\n        }\n\n        // Accumulate sample value:\n        this.accSample(nCycles);\n\n        // Clock sample timer:\n        this.sampleTimer += nCycles<<10;\n        if (this.sampleTimer>=this.sampleTimerMax) {\n            // Sample channels:\n            this.sample();\n            this.sampleTimer -= this.sampleTimerMax;\n        }\n    },\n\n    accSample: function(cycles) {\n        // Special treatment for triangle channel - need to interpolate.\n        if (this.triangle.sampleCondition) {\n            this.triValue = Math.floor((this.triangle.progTimerCount << 4) /\n                    (this.triangle.progTimerMax + 1));\n            if (this.triValue > 16) {\n                this.triValue = 16;\n            }\n            if (this.triangle.triangleCounter >= 16) {\n                this.triValue = 16 - this.triValue;\n            }\n\n            // Add non-interpolated sample value:\n            this.triValue += this.triangle.sampleValue;\n        }\n\n        // Now sample normally:\n        if (cycles === 2) {\n\n            this.smpTriangle += this.triValue                << 1;\n            this.smpDmc      += this.dmc.sample         << 1;\n            this.smpSquare1  += this.square1.sampleValue    << 1;\n            this.smpSquare2  += this.square2.sampleValue    << 1;\n            this.accCount    += 2;\n\n        }else if (cycles === 4) {\n\n            this.smpTriangle += this.triValue                << 2;\n            this.smpDmc      += this.dmc.sample         << 2;\n            this.smpSquare1  += this.square1.sampleValue    << 2;\n            this.smpSquare2  += this.square2.sampleValue    << 2;\n            this.accCount    += 4;\n\n        }else{\n\n            this.smpTriangle += cycles * this.triValue;\n            this.smpDmc      += cycles * this.dmc.sample;\n            this.smpSquare1  += cycles * this.square1.sampleValue;\n            this.smpSquare2  += cycles * this.square2.sampleValue;\n            this.accCount    += cycles;\n\n        }\n\n    },\n\n    frameCounterTick: function(){\n\n        this.derivedFrameCounter++;\n        if (this.derivedFrameCounter >= this.frameIrqCounterMax) {\n            this.derivedFrameCounter = 0;\n        }\n\n        if (this.derivedFrameCounter===1 || this.derivedFrameCounter===3) {\n\n            // Clock length & sweep:\n            this.triangle.clockLengthCounter();\n            this.square1.clockLengthCounter();\n            this.square2.clockLengthCounter();\n            this.noise.clockLengthCounter();\n            this.square1.clockSweep();\n            this.square2.clockSweep();\n\n        }\n\n        if (this.derivedFrameCounter >= 0 && this.derivedFrameCounter < 4) {\n\n            // Clock linear & decay:\n            this.square1.clockEnvDecay();\n            this.square2.clockEnvDecay();\n            this.noise.clockEnvDecay();\n            this.triangle.clockLinearCounter();\n\n        }\n\n        if (this.derivedFrameCounter === 3 && this.countSequence===0) {\n\n            // Enable IRQ:\n            this.frameIrqActive = true;\n\n        }\n\n\n        // End of 240Hz tick\n\n    },\n\n\n    // Samples the channels, mixes the output together,\n    // writes to buffer and (if enabled) file.\n    sample: function(){\n        var sq_index, tnd_index;\n\n        if (this.accCount > 0) {\n\n            this.smpSquare1 <<= 4;\n            this.smpSquare1 = Math.floor(this.smpSquare1 / this.accCount);\n\n            this.smpSquare2 <<= 4;\n            this.smpSquare2 = Math.floor(this.smpSquare2 / this.accCount);\n\n            this.smpTriangle = Math.floor(this.smpTriangle / this.accCount);\n\n            this.smpDmc <<= 4;\n            this.smpDmc = Math.floor(this.smpDmc / this.accCount);\n\n            this.accCount = 0;\n        }\n        else {\n            this.smpSquare1 = this.square1.sampleValue << 4;\n            this.smpSquare2 = this.square2.sampleValue << 4;\n            this.smpTriangle = this.triangle.sampleValue;\n            this.smpDmc = this.dmc.sample << 4;\n        }\n\n        var smpNoise = Math.floor((this.noise.accValue << 4) /\n                this.noise.accCount);\n        this.noise.accValue = smpNoise >> 4;\n        this.noise.accCount = 1;\n\n        // Stereo sound.\n\n        // Left channel:\n        sq_index  = (\n                this.smpSquare1 * this.stereoPosLSquare1 +\n                this.smpSquare2 * this.stereoPosLSquare2\n            ) >> 8;\n        tnd_index = (\n                3 * this.smpTriangle * this.stereoPosLTriangle +\n                (smpNoise<<1) * this.stereoPosLNoise + this.smpDmc *\n                this.stereoPosLDMC\n            ) >> 8;\n        if (sq_index >= this.square_table.length) {\n            sq_index  = this.square_table.length-1;\n        }\n        if (tnd_index >= this.tnd_table.length) {\n            tnd_index = this.tnd_table.length - 1;\n        }\n        var sampleValueL = this.square_table[sq_index] +\n                this.tnd_table[tnd_index] - this.dcValue;\n\n        // Right channel:\n        sq_index = (this.smpSquare1 * this.stereoPosRSquare1 +\n                this.smpSquare2 * this.stereoPosRSquare2\n            ) >> 8;\n        tnd_index = (3 * this.smpTriangle * this.stereoPosRTriangle +\n                (smpNoise << 1) * this.stereoPosRNoise + this.smpDmc *\n                this.stereoPosRDMC\n            ) >> 8;\n        if (sq_index >= this.square_table.length) {\n            sq_index = this.square_table.length - 1;\n        }\n        if (tnd_index >= this.tnd_table.length) {\n            tnd_index = this.tnd_table.length - 1;\n        }\n        var sampleValueR = this.square_table[sq_index] +\n                this.tnd_table[tnd_index] - this.dcValue;\n\n        // Remove DC from left channel:\n        var smpDiffL = sampleValueL - this.prevSampleL;\n        this.prevSampleL += smpDiffL;\n        this.smpAccumL += smpDiffL - (this.smpAccumL >> 10);\n        sampleValueL = this.smpAccumL;\n\n        // Remove DC from right channel:\n        var smpDiffR     = sampleValueR - this.prevSampleR;\n        this.prevSampleR += smpDiffR;\n        this.smpAccumR  += smpDiffR - (this.smpAccumR >> 10);\n        sampleValueR = this.smpAccumR;\n\n        // Write:\n        if (sampleValueL > this.maxSample) {\n            this.maxSample = sampleValueL;\n        }\n        if (sampleValueL < this.minSample) {\n            this.minSample = sampleValueL;\n        }\n        this.sampleBuffer[this.bufferIndex++] = sampleValueL;\n        this.sampleBuffer[this.bufferIndex++] = sampleValueR;\n\n        // Write full buffer\n        if (this.bufferIndex === this.sampleBuffer.length) {\n            this.nes.ui.writeAudio(this.sampleBuffer);\n            this.sampleBuffer = new Array(this.bufferSize*2);\n            this.bufferIndex = 0;\n        }\n\n        // Reset sampled values:\n        this.smpSquare1 = 0;\n        this.smpSquare2 = 0;\n        this.smpTriangle = 0;\n        this.smpDmc = 0;\n\n    },\n\n    getLengthMax: function(value){\n        return this.lengthLookup[value >> 3];\n    },\n\n    getDmcFrequency: function(value){\n        if (value >= 0 && value < 0x10) {\n            return this.dmcFreqLookup[value];\n        }\n        return 0;\n    },\n\n    getNoiseWaveLength: function(value){\n        if (value >= 0 && value < 0x10) {\n            return this.noiseWavelengthLookup[value];\n        }\n        return 0;\n    },\n\n    setPanning: function(pos){\n        for (var i = 0; i < 5; i++) {\n            this.panning[i] = pos[i];\n        }\n        this.updateStereoPos();\n    },\n\n    setMasterVolume: function(value){\n        if (value < 0) {\n            value = 0;\n        }\n        if (value > 256) {\n            value = 256;\n        }\n        this.masterVolume = value;\n        this.updateStereoPos();\n    },\n\n    updateStereoPos: function(){\n        this.stereoPosLSquare1 = (this.panning[0] * this.masterVolume) >> 8;\n        this.stereoPosLSquare2 = (this.panning[1] * this.masterVolume) >> 8;\n        this.stereoPosLTriangle = (this.panning[2] * this.masterVolume) >> 8;\n        this.stereoPosLNoise = (this.panning[3] * this.masterVolume) >> 8;\n        this.stereoPosLDMC = (this.panning[4] * this.masterVolume) >> 8;\n\n        this.stereoPosRSquare1 = this.masterVolume - this.stereoPosLSquare1;\n        this.stereoPosRSquare2 = this.masterVolume - this.stereoPosLSquare2;\n        this.stereoPosRTriangle = this.masterVolume - this.stereoPosLTriangle;\n        this.stereoPosRNoise = this.masterVolume - this.stereoPosLNoise;\n        this.stereoPosRDMC = this.masterVolume - this.stereoPosLDMC;\n    },\n\n    initLengthLookup: function(){\n\n        this.lengthLookup = [\n            0x0A, 0xFE,\n            0x14, 0x02,\n            0x28, 0x04,\n            0x50, 0x06,\n            0xA0, 0x08,\n            0x3C, 0x0A,\n            0x0E, 0x0C,\n            0x1A, 0x0E,\n            0x0C, 0x10,\n            0x18, 0x12,\n            0x30, 0x14,\n            0x60, 0x16,\n            0xC0, 0x18,\n            0x48, 0x1A,\n            0x10, 0x1C,\n            0x20, 0x1E\n        ];\n    },\n\n    initDmcFrequencyLookup: function(){\n\n        this.dmcFreqLookup = new Array(16);\n\n        this.dmcFreqLookup[0x0] = 0xD60;\n        this.dmcFreqLookup[0x1] = 0xBE0;\n        this.dmcFreqLookup[0x2] = 0xAA0;\n        this.dmcFreqLookup[0x3] = 0xA00;\n        this.dmcFreqLookup[0x4] = 0x8F0;\n        this.dmcFreqLookup[0x5] = 0x7F0;\n        this.dmcFreqLookup[0x6] = 0x710;\n        this.dmcFreqLookup[0x7] = 0x6B0;\n        this.dmcFreqLookup[0x8] = 0x5F0;\n        this.dmcFreqLookup[0x9] = 0x500;\n        this.dmcFreqLookup[0xA] = 0x470;\n        this.dmcFreqLookup[0xB] = 0x400;\n        this.dmcFreqLookup[0xC] = 0x350;\n        this.dmcFreqLookup[0xD] = 0x2A0;\n        this.dmcFreqLookup[0xE] = 0x240;\n        this.dmcFreqLookup[0xF] = 0x1B0;\n        //for(int i=0;i<16;i++)dmcFreqLookup[i]/=8;\n\n    },\n\n    initNoiseWavelengthLookup: function(){\n\n        this.noiseWavelengthLookup = new Array(16);\n\n        this.noiseWavelengthLookup[0x0] = 0x004;\n        this.noiseWavelengthLookup[0x1] = 0x008;\n        this.noiseWavelengthLookup[0x2] = 0x010;\n        this.noiseWavelengthLookup[0x3] = 0x020;\n        this.noiseWavelengthLookup[0x4] = 0x040;\n        this.noiseWavelengthLookup[0x5] = 0x060;\n        this.noiseWavelengthLookup[0x6] = 0x080;\n        this.noiseWavelengthLookup[0x7] = 0x0A0;\n        this.noiseWavelengthLookup[0x8] = 0x0CA;\n        this.noiseWavelengthLookup[0x9] = 0x0FE;\n        this.noiseWavelengthLookup[0xA] = 0x17C;\n        this.noiseWavelengthLookup[0xB] = 0x1FC;\n        this.noiseWavelengthLookup[0xC] = 0x2FA;\n        this.noiseWavelengthLookup[0xD] = 0x3F8;\n        this.noiseWavelengthLookup[0xE] = 0x7F2;\n        this.noiseWavelengthLookup[0xF] = 0xFE4;\n\n    },\n\n    initDACtables: function(){\n        var value, ival, i;\n        var max_sqr = 0;\n        var max_tnd = 0;\n\n        this.square_table = new Array(32*16);\n        this.tnd_table = new Array(204*16);\n\n        for (i = 0; i < 32 * 16; i++) {\n            value = 95.52 / (8128.0 / (i/16.0) + 100.0);\n            value *= 0.98411;\n            value *= 50000.0;\n            ival = Math.floor(value);\n\n            this.square_table[i] = ival;\n            if (ival > max_sqr) {\n                max_sqr = ival;\n            }\n        }\n\n        for (i = 0; i < 204 * 16; i++) {\n            value = 163.67 / (24329.0 / (i/16.0) + 100.0);\n            value *= 0.98411;\n            value *= 50000.0;\n            ival = Math.floor(value);\n\n            this.tnd_table[i] = ival;\n            if (ival > max_tnd) {\n                max_tnd = ival;\n            }\n\n        }\n\n        this.dacRange = max_sqr+max_tnd;\n        this.dcValue = this.dacRange/2;\n\n    }\n};\n\n\nPAPU.ChannelDM = function(papu) {\n    this.papu = papu;\n\n    this.MODE_NORMAL = 0;\n    this.MODE_LOOP = 1;\n    this.MODE_IRQ = 2;\n\n    this.isEnabled = null;\n    this.hasSample = null;\n    this.irqGenerated = false;\n\n    this.playMode = null;\n    this.dmaFrequency = null;\n    this.dmaCounter = null;\n    this.deltaCounter = null;\n    this.playStartAddress = null;\n    this.playAddress = null;\n    this.playLength = null;\n    this.playLengthCounter = null;\n    this.shiftCounter = null;\n    this.reg4012 = null;\n    this.reg4013 = null;\n    this.sample = null;\n    this.dacLsb = null;\n    this.data = null;\n\n    this.reset();\n};\n\nPAPU.ChannelDM.prototype = {\n    clockDmc: function() {\n\n        // Only alter DAC value if the sample buffer has data:\n        if(this.hasSample) {\n\n            if ((this.data & 1) === 0) {\n\n                // Decrement delta:\n                if(this.deltaCounter>0) {\n                    this.deltaCounter--;\n                }\n            }\n            else {\n                // Increment delta:\n                if (this.deltaCounter < 63) {\n                    this.deltaCounter++;\n                }\n            }\n\n            // Update sample value:\n            this.sample = this.isEnabled ? (this.deltaCounter << 1) + this.dacLsb : 0;\n\n            // Update shift register:\n            this.data >>= 1;\n\n        }\n\n        this.dmaCounter--;\n        if (this.dmaCounter <= 0) {\n\n            // No more sample bits.\n            this.hasSample = false;\n            this.endOfSample();\n            this.dmaCounter = 8;\n\n        }\n\n        if (this.irqGenerated) {\n            this.papu.nes.cpu.requestIrq(this.papu.nes.cpu.IRQ_NORMAL);\n        }\n\n    },\n\n    endOfSample: function() {\n        if (this.playLengthCounter === 0 && this.playMode === this.MODE_LOOP) {\n\n            // Start from beginning of sample:\n            this.playAddress = this.playStartAddress;\n            this.playLengthCounter = this.playLength;\n\n        }\n\n        if (this.playLengthCounter > 0) {\n\n            // Fetch next sample:\n            this.nextSample();\n\n            if (this.playLengthCounter === 0) {\n\n                // Last byte of sample fetched, generate IRQ:\n                if (this.playMode === this.MODE_IRQ) {\n\n                    // Generate IRQ:\n                    this.irqGenerated = true;\n\n                }\n\n            }\n\n        }\n\n    },\n\n    nextSample: function() {\n        // Fetch byte:\n        this.data = this.papu.nes.mmap.load(this.playAddress);\n        this.papu.nes.cpu.haltCycles(4);\n\n        this.playLengthCounter--;\n        this.playAddress++;\n        if (this.playAddress > 0xFFFF) {\n            this.playAddress = 0x8000;\n        }\n\n        this.hasSample = true;\n    },\n\n    writeReg: function(address, value) {\n        if (address === 0x4010) {\n\n            // Play mode, DMA Frequency\n            if ((value >> 6) === 0) {\n                this.playMode = this.MODE_NORMAL;\n            }\n            else if (((value >> 6) & 1) === 1) {\n                this.playMode = this.MODE_LOOP;\n            }\n            else if ((value >> 6) === 2) {\n                this.playMode = this.MODE_IRQ;\n            }\n\n            if ((value & 0x80) === 0) {\n                this.irqGenerated = false;\n            }\n\n            this.dmaFrequency = this.papu.getDmcFrequency(value & 0xF);\n\n        }\n        else if (address === 0x4011) {\n\n            // Delta counter load register:\n            this.deltaCounter = (value >> 1) & 63;\n            this.dacLsb = value & 1;\n            this.sample = ((this.deltaCounter << 1) + this.dacLsb); // update sample value\n\n        }\n        else if (address === 0x4012) {\n\n            // DMA address load register\n            this.playStartAddress = (value << 6) | 0x0C000;\n            this.playAddress = this.playStartAddress;\n            this.reg4012 = value;\n\n        }\n        else if (address === 0x4013) {\n\n            // Length of play code\n            this.playLength = (value << 4) + 1;\n            this.playLengthCounter = this.playLength;\n            this.reg4013 = value;\n\n        }\n        else if (address === 0x4015) {\n\n            // DMC/IRQ Status\n            if (((value >> 4) & 1) === 0) {\n                // Disable:\n                this.playLengthCounter = 0;\n            }\n            else {\n                // Restart:\n                this.playAddress = this.playStartAddress;\n                this.playLengthCounter = this.playLength;\n            }\n            this.irqGenerated = false;\n        }\n    },\n\n    setEnabled: function(value) {\n        if ((!this.isEnabled) && value) {\n            this.playLengthCounter = this.playLength;\n        }\n        this.isEnabled = value;\n    },\n\n    getLengthStatus: function(){\n        return ((this.playLengthCounter === 0 || !this.isEnabled) ? 0 : 1);\n    },\n\n    getIrqStatus: function(){\n        return (this.irqGenerated ? 1 : 0);\n    },\n\n    reset: function(){\n        this.isEnabled = false;\n        this.irqGenerated = false;\n        this.playMode = this.MODE_NORMAL;\n        this.dmaFrequency = 0;\n        this.dmaCounter = 0;\n        this.deltaCounter = 0;\n        this.playStartAddress = 0;\n        this.playAddress = 0;\n        this.playLength = 0;\n        this.playLengthCounter = 0;\n        this.sample = 0;\n        this.dacLsb = 0;\n        this.shiftCounter = 0;\n        this.reg4012 = 0;\n        this.reg4013 = 0;\n        this.data = 0;\n    }\n};\n\n\nPAPU.ChannelNoise = function(papu) {\n    this.papu = papu;\n\n    this.isEnabled = null;\n    this.envDecayDisable = null;\n    this.envDecayLoopEnable = null;\n    this.lengthCounterEnable = null;\n    this.envReset = null;\n    this.shiftNow = null;\n\n    this.lengthCounter = null;\n    this.progTimerCount = null;\n    this.progTimerMax = null;\n    this.envDecayRate = null;\n    this.envDecayCounter = null;\n    this.envVolume = null;\n    this.masterVolume = null;\n    this.shiftReg = 1<<14;\n    this.randomBit = null;\n    this.randomMode = null;\n    this.sampleValue = null;\n    this.accValue=0;\n    this.accCount=1;\n    this.tmp = null;\n\n    this.reset();\n};\n\nPAPU.ChannelNoise.prototype = {\n    reset: function() {\n        this.progTimerCount = 0;\n        this.progTimerMax = 0;\n        this.isEnabled = false;\n        this.lengthCounter = 0;\n        this.lengthCounterEnable = false;\n        this.envDecayDisable = false;\n        this.envDecayLoopEnable = false;\n        this.shiftNow = false;\n        this.envDecayRate = 0;\n        this.envDecayCounter = 0;\n        this.envVolume = 0;\n        this.masterVolume = 0;\n        this.shiftReg = 1;\n        this.randomBit = 0;\n        this.randomMode = 0;\n        this.sampleValue = 0;\n        this.tmp = 0;\n    },\n\n    clockLengthCounter: function(){\n        if (this.lengthCounterEnable && this.lengthCounter>0){\n            this.lengthCounter--;\n            if (this.lengthCounter === 0) {\n                this.updateSampleValue();\n            }\n        }\n    },\n\n    clockEnvDecay: function() {\n        if(this.envReset) {\n            // Reset envelope:\n            this.envReset = false;\n            this.envDecayCounter = this.envDecayRate + 1;\n            this.envVolume = 0xF;\n        }\n        else if (--this.envDecayCounter <= 0) {\n            // Normal handling:\n            this.envDecayCounter = this.envDecayRate + 1;\n            if(this.envVolume>0) {\n                this.envVolume--;\n            }\n            else {\n                this.envVolume = this.envDecayLoopEnable ? 0xF : 0;\n            }\n        }\n        this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n        this.updateSampleValue();\n    },\n\n    updateSampleValue: function() {\n        if (this.isEnabled && this.lengthCounter>0) {\n            this.sampleValue = this.randomBit * this.masterVolume;\n        }\n    },\n\n    writeReg: function(address, value){\n        if(address === 0x400C) {\n            // Volume/Envelope decay:\n            this.envDecayDisable = ((value&0x10) !== 0);\n            this.envDecayRate = value&0xF;\n            this.envDecayLoopEnable = ((value&0x20) !== 0);\n            this.lengthCounterEnable = ((value&0x20)===0);\n            this.masterVolume = this.envDecayDisable?this.envDecayRate:this.envVolume;\n\n        }else if(address === 0x400E) {\n            // Programmable timer:\n            this.progTimerMax = this.papu.getNoiseWaveLength(value&0xF);\n            this.randomMode = value>>7;\n\n        }else if(address === 0x400F) {\n            // Length counter\n            this.lengthCounter = this.papu.getLengthMax(value&248);\n            this.envReset = true;\n        }\n        // Update:\n        //updateSampleValue();\n    },\n\n    setEnabled: function(value){\n        this.isEnabled = value;\n        if (!value) {\n            this.lengthCounter = 0;\n        }\n        this.updateSampleValue();\n    },\n\n    getLengthStatus: function() {\n        return ((this.lengthCounter===0 || !this.isEnabled)?0:1);\n    }\n};\n\n\nPAPU.ChannelSquare = function(papu, square1) {\n    this.papu = papu;\n\n    this.dutyLookup = [\n         0, 1, 0, 0, 0, 0, 0, 0,\n         0, 1, 1, 0, 0, 0, 0, 0,\n         0, 1, 1, 1, 1, 0, 0, 0,\n         1, 0, 0, 1, 1, 1, 1, 1\n    ];\n    this.impLookup = [\n         1,-1, 0, 0, 0, 0, 0, 0,\n         1, 0,-1, 0, 0, 0, 0, 0,\n         1, 0, 0, 0,-1, 0, 0, 0,\n        -1, 0, 1, 0, 0, 0, 0, 0\n    ];\n\n    this.sqr1 = square1;\n    this.isEnabled = null;\n    this.lengthCounterEnable = null;\n    this.sweepActive = null;\n    this.envDecayDisable = null;\n    this.envDecayLoopEnable = null;\n    this.envReset = null;\n    this.sweepCarry = null;\n    this.updateSweepPeriod = null;\n\n    this.progTimerCount = null;\n    this.progTimerMax = null;\n    this.lengthCounter = null;\n    this.squareCounter = null;\n    this.sweepCounter = null;\n    this.sweepCounterMax = null;\n    this.sweepMode = null;\n    this.sweepShiftAmount = null;\n    this.envDecayRate = null;\n    this.envDecayCounter = null;\n    this.envVolume = null;\n    this.masterVolume = null;\n    this.dutyMode = null;\n    this.sweepResult = null;\n    this.sampleValue = null;\n    this.vol = null;\n\n    this.reset();\n};\n\nPAPU.ChannelSquare.prototype = {\n    reset: function() {\n        this.progTimerCount = 0;\n        this.progTimerMax = 0;\n        this.lengthCounter = 0;\n        this.squareCounter = 0;\n        this.sweepCounter = 0;\n        this.sweepCounterMax = 0;\n        this.sweepMode = 0;\n        this.sweepShiftAmount = 0;\n        this.envDecayRate = 0;\n        this.envDecayCounter = 0;\n        this.envVolume = 0;\n        this.masterVolume = 0;\n        this.dutyMode = 0;\n        this.vol = 0;\n\n        this.isEnabled = false;\n        this.lengthCounterEnable = false;\n        this.sweepActive = false;\n        this.sweepCarry = false;\n        this.envDecayDisable = false;\n        this.envDecayLoopEnable = false;\n    },\n\n    clockLengthCounter: function() {\n        if (this.lengthCounterEnable && this.lengthCounter > 0){\n            this.lengthCounter--;\n            if (this.lengthCounter === 0) {\n                this.updateSampleValue();\n            }\n        }\n    },\n\n    clockEnvDecay: function() {\n        if (this.envReset) {\n            // Reset envelope:\n            this.envReset = false;\n            this.envDecayCounter = this.envDecayRate + 1;\n            this.envVolume = 0xF;\n        }else if ((--this.envDecayCounter) <= 0) {\n            // Normal handling:\n            this.envDecayCounter = this.envDecayRate + 1;\n            if (this.envVolume>0) {\n                this.envVolume--;\n            }else{\n                this.envVolume = this.envDecayLoopEnable ? 0xF : 0;\n            }\n        }\n\n        this.masterVolume = this.envDecayDisable ? this.envDecayRate : this.envVolume;\n        this.updateSampleValue();\n    },\n\n    clockSweep: function() {\n        if (--this.sweepCounter<=0) {\n\n            this.sweepCounter = this.sweepCounterMax + 1;\n            if (this.sweepActive && this.sweepShiftAmount>0 && this.progTimerMax>7) {\n\n                // Calculate result from shifter:\n                this.sweepCarry = false;\n                if (this.sweepMode===0) {\n                    this.progTimerMax += (this.progTimerMax>>this.sweepShiftAmount);\n                    if (this.progTimerMax > 4095) {\n                        this.progTimerMax = 4095;\n                        this.sweepCarry = true;\n                    }\n                }else{\n                    this.progTimerMax = this.progTimerMax - ((this.progTimerMax>>this.sweepShiftAmount)-(this.sqr1?1:0));\n                }\n            }\n        }\n\n        if (this.updateSweepPeriod) {\n            this.updateSweepPeriod = false;\n            this.sweepCounter = this.sweepCounterMax + 1;\n        }\n    },\n\n    updateSampleValue: function() {\n        if (this.isEnabled && this.lengthCounter>0 && this.progTimerMax>7) {\n\n            if (this.sweepMode===0 && (this.progTimerMax + (this.progTimerMax>>this.sweepShiftAmount)) > 4095) {\n            //if (this.sweepCarry) {\n                this.sampleValue = 0;\n            }else{\n                this.sampleValue = this.masterVolume*this.dutyLookup[(this.dutyMode<<3)+this.squareCounter];\n            }\n        }else{\n            this.sampleValue = 0;\n        }\n    },\n\n    writeReg: function(address, value){\n        var addrAdd = (this.sqr1?0:4);\n        if (address === 0x4000 + addrAdd) {\n            // Volume/Envelope decay:\n            this.envDecayDisable = ((value&0x10) !== 0);\n            this.envDecayRate = value & 0xF;\n            this.envDecayLoopEnable = ((value&0x20) !== 0);\n            this.dutyMode = (value>>6)&0x3;\n            this.lengthCounterEnable = ((value&0x20)===0);\n            this.masterVolume = this.envDecayDisable?this.envDecayRate:this.envVolume;\n            this.updateSampleValue();\n\n        }\n        else if (address === 0x4001+addrAdd) {\n            // Sweep:\n            this.sweepActive = ((value&0x80) !== 0);\n            this.sweepCounterMax = ((value>>4)&7);\n            this.sweepMode = (value>>3)&1;\n            this.sweepShiftAmount = value&7;\n            this.updateSweepPeriod = true;\n        }\n        else if (address === 0x4002+addrAdd){\n            // Programmable timer:\n            this.progTimerMax &= 0x700;\n            this.progTimerMax |= value;\n        }\n        else if (address === 0x4003+addrAdd) {\n            // Programmable timer, length counter\n            this.progTimerMax &= 0xFF;\n            this.progTimerMax |= ((value&0x7)<<8);\n\n            if (this.isEnabled){\n                this.lengthCounter = this.papu.getLengthMax(value&0xF8);\n            }\n\n            this.envReset  = true;\n        }\n    },\n\n    setEnabled: function(value) {\n        this.isEnabled = value;\n        if (!value) {\n            this.lengthCounter = 0;\n        }\n        this.updateSampleValue();\n    },\n\n    getLengthStatus: function() {\n        return ((this.lengthCounter === 0 || !this.isEnabled) ? 0 : 1);\n    }\n};\n\n\nPAPU.ChannelTriangle = function(papu) {\n    this.papu = papu;\n\n    this.isEnabled = null;\n    this.sampleCondition = null;\n    this.lengthCounterEnable = null;\n    this.lcHalt = null;\n    this.lcControl = null;\n\n    this.progTimerCount = null;\n    this.progTimerMax = null;\n    this.triangleCounter = null;\n    this.lengthCounter = null;\n    this.linearCounter = null;\n    this.lcLoadValue = null;\n    this.sampleValue = null;\n    this.tmp = null;\n\n    this.reset();\n};\n\nPAPU.ChannelTriangle.prototype = {\n    reset: function(){\n        this.progTimerCount = 0;\n        this.progTimerMax = 0;\n        this.triangleCounter = 0;\n        this.isEnabled = false;\n        this.sampleCondition = false;\n        this.lengthCounter = 0;\n        this.lengthCounterEnable = false;\n        this.linearCounter = 0;\n        this.lcLoadValue = 0;\n        this.lcHalt = true;\n        this.lcControl = false;\n        this.tmp = 0;\n        this.sampleValue = 0xF;\n    },\n\n    clockLengthCounter: function(){\n        if (this.lengthCounterEnable && this.lengthCounter>0) {\n            this.lengthCounter--;\n            if (this.lengthCounter===0) {\n                this.updateSampleCondition();\n            }\n        }\n    },\n\n    clockLinearCounter: function(){\n        if (this.lcHalt){\n            // Load:\n            this.linearCounter = this.lcLoadValue;\n            this.updateSampleCondition();\n        }\n        else if (this.linearCounter > 0) {\n            // Decrement:\n            this.linearCounter--;\n            this.updateSampleCondition();\n        }\n        if (!this.lcControl) {\n            // Clear halt flag:\n            this.lcHalt = false;\n        }\n    },\n\n    getLengthStatus: function(){\n        return ((this.lengthCounter === 0 || !this.isEnabled)?0:1);\n    },\n\n    readReg: function(address){\n        return 0;\n    },\n\n    writeReg: function(address, value){\n        if (address === 0x4008) {\n            // New values for linear counter:\n            this.lcControl  = (value&0x80)!==0;\n            this.lcLoadValue =  value&0x7F;\n\n            // Length counter enable:\n            this.lengthCounterEnable = !this.lcControl;\n        }\n        else if (address === 0x400A) {\n            // Programmable timer:\n            this.progTimerMax &= 0x700;\n            this.progTimerMax |= value;\n\n        }\n        else if(address === 0x400B) {\n            // Programmable timer, length counter\n            this.progTimerMax &= 0xFF;\n            this.progTimerMax |= ((value&0x07)<<8);\n            this.lengthCounter = this.papu.getLengthMax(value&0xF8);\n            this.lcHalt = true;\n        }\n\n        this.updateSampleCondition();\n    },\n\n    clockProgrammableTimer: function(nCycles){\n        if (this.progTimerMax>0) {\n            this.progTimerCount += nCycles;\n            while (this.progTimerMax > 0 &&\n                    this.progTimerCount >= this.progTimerMax) {\n                this.progTimerCount -= this.progTimerMax;\n                if (this.isEnabled && this.lengthCounter>0 &&\n                        this.linearCounter > 0) {\n                    this.clockTriangleGenerator();\n                }\n            }\n        }\n    },\n\n    clockTriangleGenerator: function() {\n        this.triangleCounter++;\n        this.triangleCounter &= 0x1F;\n    },\n\n    setEnabled: function(value) {\n        this.isEnabled = value;\n        if(!value) {\n            this.lengthCounter = 0;\n        }\n        this.updateSampleCondition();\n    },\n\n    updateSampleCondition: function() {\n        this.sampleCondition = this.isEnabled &&\n                this.progTimerMax > 7 &&\n                this.linearCounter > 0 &&\n                this.lengthCounter > 0;\n    }\n};\n\nexport default PAPU;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/papu.js\n **/","/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport PPU from './ppu';\nimport Mappers from './mappers';\n\nconst ROM = function(nes) {\n    this.nes = nes;\n\n    this.mapperName = new Array(92);\n\n    for (var i=0;i<92;i++) {\n        this.mapperName[i] = \"Unknown Mapper\";\n    }\n    this.mapperName[ 0] = \"Direct Access\";\n    this.mapperName[ 1] = \"Nintendo MMC1\";\n    this.mapperName[ 2] = \"UNROM\";\n    this.mapperName[ 3] = \"CNROM\";\n    this.mapperName[ 4] = \"Nintendo MMC3\";\n    this.mapperName[ 5] = \"Nintendo MMC5\";\n    this.mapperName[ 6] = \"FFE F4xxx\";\n    this.mapperName[ 7] = \"AOROM\";\n    this.mapperName[ 8] = \"FFE F3xxx\";\n    this.mapperName[ 9] = \"Nintendo MMC2\";\n    this.mapperName[10] = \"Nintendo MMC4\";\n    this.mapperName[11] = \"Color Dreams Chip\";\n    this.mapperName[12] = \"FFE F6xxx\";\n    this.mapperName[15] = \"100-in-1 switch\";\n    this.mapperName[16] = \"Bandai chip\";\n    this.mapperName[17] = \"FFE F8xxx\";\n    this.mapperName[18] = \"Jaleco SS8806 chip\";\n    this.mapperName[19] = \"Namcot 106 chip\";\n    this.mapperName[20] = \"Famicom Disk System\";\n    this.mapperName[21] = \"Konami VRC4a\";\n    this.mapperName[22] = \"Konami VRC2a\";\n    this.mapperName[23] = \"Konami VRC2a\";\n    this.mapperName[24] = \"Konami VRC6\";\n    this.mapperName[25] = \"Konami VRC4b\";\n    this.mapperName[32] = \"Irem G-101 chip\";\n    this.mapperName[33] = \"Taito TC0190/TC0350\";\n    this.mapperName[34] = \"32kB ROM switch\";\n\n    this.mapperName[64] = \"Tengen RAMBO-1 chip\";\n    this.mapperName[65] = \"Irem H-3001 chip\";\n    this.mapperName[66] = \"GNROM switch\";\n    this.mapperName[67] = \"SunSoft3 chip\";\n    this.mapperName[68] = \"SunSoft4 chip\";\n    this.mapperName[69] = \"SunSoft5 FME-7 chip\";\n    this.mapperName[71] = \"Camerica chip\";\n    this.mapperName[78] = \"Irem 74HC161/32-based\";\n    this.mapperName[91] = \"Pirate HK-SF3 chip\";\n};\n\nROM.prototype = {\n    // Mirroring types:\n    VERTICAL_MIRRORING: 0,\n    HORIZONTAL_MIRRORING: 1,\n    FOURSCREEN_MIRRORING: 2,\n    SINGLESCREEN_MIRRORING: 3,\n    SINGLESCREEN_MIRRORING2: 4,\n    SINGLESCREEN_MIRRORING3: 5,\n    SINGLESCREEN_MIRRORING4: 6,\n    CHRROM_MIRRORING: 7,\n\n    header: null,\n    rom: null,\n    vrom: null,\n    vromTile: null,\n\n    romCount: null,\n    vromCount: null,\n    mirroring: null,\n    batteryRam: null,\n    trainer: null,\n    fourScreen: null,\n    mapperType: null,\n    valid: false,\n\n    load: function(data) {\n        var i, j, v;\n\n        if (data.indexOf(\"NES\\x1a\") === -1) {\n            this.nes.ui.updateStatus(\"Not a valid NES ROM.\");\n            return;\n        }\n        this.header = new Array(16);\n        for (i = 0; i < 16; i++) {\n            this.header[i] = data.charCodeAt(i) & 0xFF;\n        }\n        this.romCount = this.header[4];\n        this.vromCount = this.header[5]*2; // Get the number of 4kB banks, not 8kB\n        this.mirroring = ((this.header[6] & 1) !== 0 ? 1 : 0);\n        this.batteryRam = (this.header[6] & 2) !== 0;\n        this.trainer = (this.header[6] & 4) !== 0;\n        this.fourScreen = (this.header[6] & 8) !== 0;\n        this.mapperType = (this.header[6] >> 4) | (this.header[7] & 0xF0);\n        /* TODO\n        if (this.batteryRam)\n            this.loadBatteryRam();*/\n        // Check whether byte 8-15 are zero's:\n        var foundError = false;\n        for (i=8; i<16; i++) {\n            if (this.header[i] !== 0) {\n                foundError = true;\n                break;\n            }\n        }\n        if (foundError) {\n            this.mapperType &= 0xF; // Ignore byte 7\n        }\n        // Load PRG-ROM banks:\n        this.rom = new Array(this.romCount);\n        var offset = 16;\n        for (i=0; i < this.romCount; i++) {\n            this.rom[i] = new Array(16384);\n            for (j=0; j < 16384; j++) {\n                if (offset+j >= data.length) {\n                    break;\n                }\n                this.rom[i][j] = data.charCodeAt(offset + j) & 0xFF;\n            }\n            offset += 16384;\n        }\n        // Load CHR-ROM banks:\n        this.vrom = new Array(this.vromCount);\n        for (i=0; i < this.vromCount; i++) {\n            this.vrom[i] = new Array(4096);\n            for (j=0; j < 4096; j++) {\n                if (offset+j >= data.length){\n                    break;\n                }\n                this.vrom[i][j] = data.charCodeAt(offset + j) & 0xFF;\n            }\n            offset += 4096;\n        }\n\n        // Create VROM tiles:\n        this.vromTile = new Array(this.vromCount);\n        for (i=0; i < this.vromCount; i++) {\n            this.vromTile[i] = new Array(256);\n            for (j=0; j < 256; j++) {\n                this.vromTile[i][j] = new PPU.Tile();\n            }\n        }\n\n        // Convert CHR-ROM banks to tiles:\n        var tileIndex;\n        var leftOver;\n        for (v=0; v < this.vromCount; v++) {\n            for (i=0; i < 4096; i++) {\n                tileIndex = i >> 4;\n                leftOver = i % 16;\n                if (leftOver < 8) {\n                    this.vromTile[v][tileIndex].setScanline(\n                        leftOver,\n                        this.vrom[v][i],\n                        this.vrom[v][i+8]\n                    );\n                }\n                else {\n                    this.vromTile[v][tileIndex].setScanline(\n                        leftOver-8,\n                        this.vrom[v][i-8],\n                        this.vrom[v][i]\n                    );\n                }\n            }\n        }\n\n        this.valid = true;\n    },\n\n    getMirroringType: function() {\n        if (this.fourScreen) {\n            return this.FOURSCREEN_MIRRORING;\n        }\n        if (this.mirroring === 0) {\n            return this.HORIZONTAL_MIRRORING;\n        }\n        return this.VERTICAL_MIRRORING;\n    },\n\n    getMapperName: function() {\n        if (this.mapperType >= 0 && this.mapperType < this.mapperName.length) {\n            return this.mapperName[this.mapperType];\n        }\n        return \"Unknown Mapper, \"+this.mapperType;\n    },\n\n    mapperSupported: function() {\n        return typeof Mappers[this.mapperType] !== 'undefined';\n    },\n\n    createMapper: function() {\n        if (this.mapperSupported()) {\n            return new Mappers[this.mapperType](this.nes);\n        }\n        else {\n            this.nes.ui.updateStatus(\"This ROM uses a mapper not supported by JSNES: \"+this.getMapperName()+\"(\"+this.mapperType+\")\");\n            return null;\n        }\n    }\n};\n\nexport default ROM;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/rom.js\n **/","/*\nJSNES, based on Jamie Sanders' vNES\nCopyright (C) 2010 Ben Firshman\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport utils from './utils';\n\nconst Mappers = {};\n\nMappers[0] = function(nes) {\n    this.nes = nes;\n};\n\nMappers[0].prototype = {\n    reset: function() {\n        this.joy1StrobeState = 0;\n        this.joy2StrobeState = 0;\n        this.joypadLastWrite = 0;\n\n        this.mousePressed = false;\n        this.mouseX = null;\n        this.mouseY = null;\n    },\n\n    write: function(address, value) {\n        if (address < 0x2000) {\n            // Mirroring of RAM:\n            this.nes.cpu.mem[address & 0x7FF] = value;\n\n        }\n        else if (address > 0x4017) {\n            this.nes.cpu.mem[address] = value;\n            if (address >= 0x6000 && address < 0x8000) {\n                // Write to SaveRAM. Store in file:\n                // TODO: not yet\n                //if(this.nes.rom!=null)\n                //    this.nes.rom.writeBatteryRam(address,value);\n            }\n        }\n        else if (address > 0x2007 && address < 0x4000) {\n            this.regWrite(0x2000 + (address & 0x7), value);\n        }\n        else {\n            this.regWrite(address, value);\n        }\n    },\n\n    writelow: function(address, value) {\n        if (address < 0x2000) {\n            // Mirroring of RAM:\n            this.nes.cpu.mem[address & 0x7FF] = value;\n        }\n        else if (address > 0x4017) {\n            this.nes.cpu.mem[address] = value;\n        }\n        else if (address > 0x2007 && address < 0x4000) {\n            this.regWrite(0x2000 + (address & 0x7), value);\n        }\n        else {\n            this.regWrite(address, value);\n        }\n    },\n\n    load: function(address) {\n        // Wrap around:\n        address &= 0xFFFF;\n\n        // Check address range:\n        if (address > 0x4017) {\n            // ROM:\n            return this.nes.cpu.mem[address];\n        }\n        else if (address >= 0x2000) {\n            // I/O Ports.\n            return this.regLoad(address);\n        }\n        else {\n            // RAM (mirrored)\n            return this.nes.cpu.mem[address & 0x7FF];\n        }\n    },\n\n    regLoad: function(address) {\n        switch (address >> 12) { // use fourth nibble (0xF000)\n            case 0:\n                break;\n\n            case 1:\n                break;\n\n            case 2:\n                // Fall through to case 3\n            case 3:\n                // PPU Registers\n                switch (address & 0x7) {\n                    case 0x0:\n                        // 0x2000:\n                        // PPU Control Register 1.\n                        // (the value is stored both\n                        // in main memory and in the\n                        // PPU as flags):\n                        // (not in the real NES)\n                        return this.nes.cpu.mem[0x2000];\n\n                    case 0x1:\n                        // 0x2001:\n                        // PPU Control Register 2.\n                        // (the value is stored both\n                        // in main memory and in the\n                        // PPU as flags):\n                        // (not in the real NES)\n                        return this.nes.cpu.mem[0x2001];\n\n                    case 0x2:\n                        // 0x2002:\n                        // PPU Status Register.\n                        // The value is stored in\n                        // main memory in addition\n                        // to as flags in the PPU.\n                        // (not in the real NES)\n                        return this.nes.ppu.readStatusRegister();\n\n                    case 0x3:\n                        return 0;\n\n                    case 0x4:\n                        // 0x2004:\n                        // Sprite Memory read.\n                        return this.nes.ppu.sramLoad();\n                    case 0x5:\n                        return 0;\n\n                    case 0x6:\n                        return 0;\n\n                    case 0x7:\n                        // 0x2007:\n                        // VRAM read:\n                        return this.nes.ppu.vramLoad();\n                }\n                break;\n            case 4:\n                // Sound+Joypad registers\n                switch (address - 0x4015) {\n                    case 0:\n                        // 0x4015:\n                        // Sound channel enable, DMC Status\n                        return this.nes.papu.readReg(address);\n\n                    case 1:\n                        // 0x4016:\n                        // Joystick 1 + Strobe\n                        return this.joy1Read();\n\n                    case 2:\n                        // 0x4017:\n                        // Joystick 2 + Strobe\n                        if (this.mousePressed) {\n\n                            // Check for white pixel nearby:\n                            var sx = Math.max(0, this.mouseX - 4);\n                            var ex = Math.min(256, this.mouseX + 4);\n                            var sy = Math.max(0, this.mouseY - 4);\n                            var ey = Math.min(240, this.mouseY + 4);\n                            var w = 0;\n\n                            for (var y=sy; y<ey; y++) {\n                                for (var x=sx; x<ex; x++) {\n\n                                    if (this.nes.ppu.buffer[(y<<8)+x] == 0xFFFFFF) {\n                                        w |= 0x1<<3;\n                                        console.debug(\"Clicked on white!\");\n                                        break;\n                                    }\n                                }\n                            }\n\n                            w |= (this.mousePressed?(0x1<<4):0);\n                            return (this.joy2Read()|w) & 0xFFFF;\n                        }\n                        else {\n                            return this.joy2Read();\n                        }\n\n                }\n                break;\n        }\n        return 0;\n    },\n\n    regWrite: function(address, value) {\n        switch (address) {\n            case 0x2000:\n                // PPU Control register 1\n                this.nes.cpu.mem[address] = value;\n                this.nes.ppu.updateControlReg1(value);\n                break;\n\n            case 0x2001:\n                // PPU Control register 2\n                this.nes.cpu.mem[address] = value;\n                this.nes.ppu.updateControlReg2(value);\n                break;\n\n            case 0x2003:\n                // Set Sprite RAM address:\n                this.nes.ppu.writeSRAMAddress(value);\n                break;\n\n            case 0x2004:\n                // Write to Sprite RAM:\n                this.nes.ppu.sramWrite(value);\n                break;\n\n            case 0x2005:\n                // Screen Scroll offsets:\n                this.nes.ppu.scrollWrite(value);\n                break;\n\n            case 0x2006:\n                // Set VRAM address:\n                this.nes.ppu.writeVRAMAddress(value);\n                break;\n\n            case 0x2007:\n                // Write to VRAM:\n                this.nes.ppu.vramWrite(value);\n                break;\n\n            case 0x4014:\n                // Sprite Memory DMA Access\n                this.nes.ppu.sramDMA(value);\n                break;\n\n            case 0x4015:\n                // Sound Channel Switch, DMC Status\n                this.nes.papu.writeReg(address, value);\n                break;\n\n            case 0x4016:\n                // Joystick 1 + Strobe\n                if ((value&1) === 0 && (this.joypadLastWrite&1) === 1) {\n                    this.joy1StrobeState = 0;\n                    this.joy2StrobeState = 0;\n                }\n                this.joypadLastWrite = value;\n                break;\n\n            case 0x4017:\n                // Sound channel frame sequencer:\n                this.nes.papu.writeReg(address, value);\n                break;\n\n            default:\n                // Sound registers\n                ////System.out.println(\"write to sound reg\");\n                if (address >= 0x4000 && address <= 0x4017) {\n                    this.nes.papu.writeReg(address,value);\n                }\n\n        }\n    },\n\n    joy1Read: function() {\n        var ret;\n\n        switch (this.joy1StrobeState) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n                ret = this.nes.controllers.state1[this.joy1StrobeState];\n                break;\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n                ret = 0;\n                break;\n            case 19:\n                ret = 1;\n                break;\n            default:\n                ret = 0;\n        }\n\n        this.joy1StrobeState++;\n        if (this.joy1StrobeState == 24) {\n            this.joy1StrobeState = 0;\n        }\n\n        return ret;\n    },\n\n    joy2Read: function() {\n        var ret;\n\n        switch (this.joy2StrobeState) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n                ret = this.nes.controllers.state2[this.joy2StrobeState];\n                break;\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n                ret = 0;\n                break;\n            case 19:\n                ret = 1;\n                break;\n            default:\n                ret = 0;\n        }\n\n        this.joy2StrobeState++;\n        if (this.joy2StrobeState == 24) {\n            this.joy2StrobeState = 0;\n        }\n\n        return ret;\n      },\n\n    loadROM: function() {\n        if (!this.nes.rom.valid || this.nes.rom.romCount < 1) {\n            alert(\"NoMapper: Invalid ROM! Unable to load.\");\n            return;\n        }\n\n        // Load ROM into memory:\n        this.loadPRGROM();\n\n        // Load CHR-ROM:\n        this.loadCHRROM();\n\n        // Load Battery RAM (if present):\n        this.loadBatteryRam();\n\n        // Reset IRQ:\n        //nes.getCpu().doResetInterrupt();\n        this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n    },\n\n    loadPRGROM: function() {\n        if (this.nes.rom.romCount > 1) {\n            // Load the two first banks into memory.\n            this.loadRomBank(0, 0x8000);\n            this.loadRomBank(1, 0xC000);\n        }\n        else {\n            // Load the one bank into both memory locations:\n            this.loadRomBank(0, 0x8000);\n            this.loadRomBank(0, 0xC000);\n        }\n    },\n\n    loadCHRROM: function() {\n        ////System.out.println(\"Loading CHR ROM..\");\n        if (this.nes.rom.vromCount > 0) {\n            if (this.nes.rom.vromCount == 1) {\n                this.loadVromBank(0,0x0000);\n                this.loadVromBank(0,0x1000);\n            }\n            else {\n                this.loadVromBank(0,0x0000);\n                this.loadVromBank(1,0x1000);\n            }\n        }\n        else {\n            //System.out.println(\"There aren't any CHR-ROM banks..\");\n        }\n    },\n\n    loadBatteryRam: function() {\n        if (this.nes.rom.batteryRam) {\n            var ram = this.nes.rom.batteryRam;\n            if (ram !== null && ram.length == 0x2000) {\n                // Load Battery RAM into memory:\n                utils.copyArrayElements(ram, 0, this.nes.cpu.mem, 0x6000, 0x2000);\n            }\n        }\n    },\n\n    loadRomBank: function(bank, address) {\n        // Loads a ROM bank into the specified address.\n        bank %= this.nes.rom.romCount;\n        //var data = this.nes.rom.rom[bank];\n        //cpuMem.write(address,data,data.length);\n        utils.copyArrayElements(this.nes.rom.rom[bank], 0, this.nes.cpu.mem, address, 16384);\n    },\n\n    loadVromBank: function(bank, address) {\n        if (this.nes.rom.vromCount === 0) {\n            return;\n        }\n        this.nes.ppu.triggerRendering();\n\n        utils.copyArrayElements(this.nes.rom.vrom[bank % this.nes.rom.vromCount],\n            0, this.nes.ppu.vramMem, address, 4096);\n\n        var vromTile = this.nes.rom.vromTile[bank % this.nes.rom.vromCount];\n        utils.copyArrayElements(vromTile, 0, this.nes.ppu.ptTile,address >> 4, 256);\n    },\n\n    load32kRomBank: function(bank, address) {\n        this.loadRomBank((bank*2) % this.nes.rom.romCount, address);\n        this.loadRomBank((bank*2+1) % this.nes.rom.romCount, address+16384);\n    },\n\n    load8kVromBank: function(bank4kStart, address) {\n        if (this.nes.rom.vromCount === 0) {\n            return;\n        }\n        this.nes.ppu.triggerRendering();\n\n        this.loadVromBank((bank4kStart) % this.nes.rom.vromCount, address);\n        this.loadVromBank((bank4kStart + 1) % this.nes.rom.vromCount,\n                address + 4096);\n    },\n\n    load1kVromBank: function(bank1k, address) {\n        if (this.nes.rom.vromCount === 0) {\n            return;\n        }\n        this.nes.ppu.triggerRendering();\n\n        var bank4k = Math.floor(bank1k / 4) % this.nes.rom.vromCount;\n        var bankoffset = (bank1k % 4) * 1024;\n        utils.copyArrayElements(this.nes.rom.vrom[bank4k], 0,\n            this.nes.ppu.vramMem, bankoffset, 1024);\n\n        // Update tiles:\n        var vromTile = this.nes.rom.vromTile[bank4k];\n        var baseIndex = address >> 4;\n        for (var i = 0; i < 64; i++) {\n            this.nes.ppu.ptTile[baseIndex+i] = vromTile[((bank1k%4) << 6) + i];\n        }\n    },\n\n    load2kVromBank: function(bank2k, address) {\n        if (this.nes.rom.vromCount === 0) {\n            return;\n        }\n        this.nes.ppu.triggerRendering();\n\n        var bank4k = Math.floor(bank2k / 2) % this.nes.rom.vromCount;\n        var bankoffset = (bank2k % 2) * 2048;\n        utils.copyArrayElements(this.nes.rom.vrom[bank4k], bankoffset,\n            this.nes.ppu.vramMem, address, 2048);\n\n        // Update tiles:\n        var vromTile = this.nes.rom.vromTile[bank4k];\n        var baseIndex = address >> 4;\n        for (var i = 0; i < 128; i++) {\n            this.nes.ppu.ptTile[baseIndex+i] = vromTile[((bank2k%2) << 7) + i];\n        }\n    },\n\n    load8kRomBank: function(bank8k, address) {\n        var bank16k = Math.floor(bank8k / 2) % this.nes.rom.romCount;\n        var offset = (bank8k % 2) * 8192;\n\n        //this.nes.cpu.mem.write(address,this.nes.rom.rom[bank16k],offset,8192);\n        utils.copyArrayElements(this.nes.rom.rom[bank16k], offset,\n                  this.nes.cpu.mem, address, 8192);\n    },\n\n    clockIrqCounter: function() {\n        // Does nothing. This is used by the MMC3 mapper.\n    },\n\n    latchAccess: function(address) {\n        // Does nothing. This is used by MMC2.\n    },\n\n    toJSON: function() {\n        return {\n            'joy1StrobeState': this.joy1StrobeState,\n            'joy2StrobeState': this.joy2StrobeState,\n            'joypadLastWrite': this.joypadLastWrite\n        };\n    },\n\n    fromJSON: function(s) {\n        this.joy1StrobeState = s.joy1StrobeState;\n        this.joy2StrobeState = s.joy2StrobeState;\n        this.joypadLastWrite = s.joypadLastWrite;\n    }\n};\n\n\nMappers[1] = function(nes) {\n    this.nes = nes;\n};\n\nMappers[1].prototype = new Mappers[0]();\n\nMappers[1].prototype.reset = function() {\n    Mappers[0].prototype.reset.apply(this);\n\n    // 5-bit buffer:\n    this.regBuffer = 0;\n    this.regBufferCounter = 0;\n\n    // Register 0:\n    this.mirroring = 0;\n    this.oneScreenMirroring = 0;\n    this.prgSwitchingArea = 1;\n    this.prgSwitchingSize = 1;\n    this.vromSwitchingSize = 0;\n\n    // Register 1:\n    this.romSelectionReg0 = 0;\n\n    // Register 2:\n    this.romSelectionReg1 = 0;\n\n    // Register 3:\n    this.romBankSelect = 0;\n};\n\nMappers[1].prototype.write = function(address, value) {\n    // Writes to addresses other than MMC registers are handled by NoMapper.\n    if (address < 0x8000) {\n        Mappers[0].prototype.write.apply(this, arguments);\n        return;\n    }\n\n    // See what should be done with the written value:\n    if ((value & 128) !== 0) {\n\n        // Reset buffering:\n        this.regBufferCounter = 0;\n        this.regBuffer = 0;\n\n        // Reset register:\n        if (this.getRegNumber(address) === 0) {\n\n            this.prgSwitchingArea = 1;\n            this.prgSwitchingSize = 1;\n\n        }\n    }\n    else {\n\n        // Continue buffering:\n        //regBuffer = (regBuffer & (0xFF-(1<<regBufferCounter))) | ((value & (1<<regBufferCounter))<<regBufferCounter);\n        this.regBuffer = (this.regBuffer & (0xFF - (1 << this.regBufferCounter))) | ((value & 1) << this.regBufferCounter);\n        this.regBufferCounter++;\n\n        if (this.regBufferCounter == 5) {\n            // Use the buffered value:\n            this.setReg(this.getRegNumber(address), this.regBuffer);\n\n            // Reset buffer:\n            this.regBuffer = 0;\n            this.regBufferCounter = 0;\n        }\n    }\n};\n\nMappers[1].prototype.setReg = function(reg, value) {\n    var tmp;\n\n    switch (reg) {\n        case 0:\n            // Mirroring:\n            tmp = value & 3;\n            if (tmp !== this.mirroring) {\n                // Set mirroring:\n                this.mirroring = tmp;\n                if ((this.mirroring & 2) === 0) {\n                    // SingleScreen mirroring overrides the other setting:\n                    this.nes.ppu.setMirroring(\n                        this.nes.rom.SINGLESCREEN_MIRRORING);\n                }\n                // Not overridden by SingleScreen mirroring.\n                else if ((this.mirroring & 1) !== 0) {\n                    this.nes.ppu.setMirroring(\n                        this.nes.rom.HORIZONTAL_MIRRORING\n                    );\n                }\n                else {\n                    this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n                }\n            }\n\n            // PRG Switching Area;\n            this.prgSwitchingArea = (value >> 2) & 1;\n\n            // PRG Switching Size:\n            this.prgSwitchingSize = (value >> 3) & 1;\n\n            // VROM Switching Size:\n            this.vromSwitchingSize = (value >> 4) & 1;\n\n            break;\n\n        case 1:\n            // ROM selection:\n            this.romSelectionReg0 = (value >> 4) & 1;\n\n            // Check whether the cart has VROM:\n            if (this.nes.rom.vromCount > 0) {\n\n                // Select VROM bank at 0x0000:\n                if (this.vromSwitchingSize === 0) {\n\n                    // Swap 8kB VROM:\n                    if (this.romSelectionReg0 === 0) {\n                        this.load8kVromBank((value & 0xF), 0x0000);\n                    }\n                    else {\n                        this.load8kVromBank(\n                            Math.floor(this.nes.rom.vromCount / 2) +\n                                (value & 0xF),\n                            0x0000\n                        );\n                    }\n\n                }\n                else {\n                    // Swap 4kB VROM:\n                    if (this.romSelectionReg0 === 0) {\n                        this.loadVromBank((value & 0xF), 0x0000);\n                    }\n                    else {\n                        this.loadVromBank(\n                            Math.floor(this.nes.rom.vromCount / 2) +\n                                (value & 0xF),\n                            0x0000\n                        );\n                    }\n                }\n            }\n\n            break;\n\n        case 2:\n            // ROM selection:\n            this.romSelectionReg1 = (value >> 4) & 1;\n\n            // Check whether the cart has VROM:\n            if (this.nes.rom.vromCount > 0) {\n\n                // Select VROM bank at 0x1000:\n                if (this.vromSwitchingSize === 1) {\n                    // Swap 4kB of VROM:\n                    if (this.romSelectionReg1 === 0) {\n                        this.loadVromBank((value & 0xF), 0x1000);\n                    }\n                    else {\n                        this.loadVromBank(\n                            Math.floor(this.nes.rom.vromCount / 2) +\n                                (value & 0xF),\n                            0x1000\n                        );\n                    }\n                }\n            }\n            break;\n\n        default:\n            // Select ROM bank:\n            // -------------------------\n            tmp = value & 0xF;\n            var bank;\n            var baseBank = 0;\n\n            if (this.nes.rom.romCount >= 32) {\n                // 1024 kB cart\n                if (this.vromSwitchingSize === 0) {\n                    if (this.romSelectionReg0 === 1) {\n                        baseBank = 16;\n                    }\n                }\n                else {\n                    baseBank = (this.romSelectionReg0\n                                | (this.romSelectionReg1 << 1)) << 3;\n                }\n            }\n            else if (this.nes.rom.romCount >= 16) {\n                // 512 kB cart\n                if (this.romSelectionReg0 === 1) {\n                    baseBank = 8;\n                }\n            }\n\n            if (this.prgSwitchingSize === 0) {\n                // 32kB\n                bank = baseBank + (value & 0xF);\n                this.load32kRomBank(bank, 0x8000);\n            }\n            else {\n                // 16kB\n                bank = baseBank * 2 + (value & 0xF);\n                if (this.prgSwitchingArea === 0) {\n                    this.loadRomBank(bank, 0xC000);\n                }\n                else {\n                    this.loadRomBank(bank, 0x8000);\n                }\n            }\n    }\n};\n\n// Returns the register number from the address written to:\nMappers[1].prototype.getRegNumber = function(address) {\n    if (address >= 0x8000 && address <= 0x9FFF) {\n        return 0;\n    }\n    else if (address >= 0xA000 && address <= 0xBFFF) {\n        return 1;\n    }\n    else if (address >= 0xC000 && address <= 0xDFFF) {\n        return 2;\n    }\n    else {\n        return 3;\n    }\n};\n\nMappers[1].prototype.loadROM = function(rom) {\n    if (!this.nes.rom.valid) {\n        alert(\"MMC1: Invalid ROM! Unable to load.\");\n        return;\n    }\n\n    // Load PRG-ROM:\n    this.loadRomBank(0, 0x8000);                         //   First ROM bank..\n    this.loadRomBank(this.nes.rom.romCount - 1, 0xC000); // ..and last ROM bank.\n\n    // Load CHR-ROM:\n    this.loadCHRROM();\n\n    // Load Battery RAM (if present):\n    this.loadBatteryRam();\n\n    // Do Reset-Interrupt:\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\nMappers[1].prototype.switchLowHighPrgRom = function(oldSetting) {\n    // not yet.\n};\n\nMappers[1].prototype.switch16to32 = function() {\n    // not yet.\n};\n\nMappers[1].prototype.switch32to16 = function() {\n    // not yet.\n};\n\nMappers[1].prototype.toJSON = function() {\n    var s = Mappers[0].prototype.toJSON.apply(this);\n    s.mirroring = this.mirroring;\n    s.oneScreenMirroring = this.oneScreenMirroring;\n    s.prgSwitchingArea = this.prgSwitchingArea;\n    s.prgSwitchingSize = this.prgSwitchingSize;\n    s.vromSwitchingSize = this.vromSwitchingSize;\n    s.romSelectionReg0 = this.romSelectionReg0;\n    s.romSelectionReg1 = this.romSelectionReg1;\n    s.romBankSelect = this.romBankSelect;\n    s.regBuffer = this.regBuffer;\n    s.regBufferCounter = this.regBufferCounter;\n    return s;\n};\n\nMappers[1].prototype.fromJSON = function(s) {\n    Mappers[0].prototype.fromJSON.apply(this, s);\n    this.mirroring = s.mirroring;\n    this.oneScreenMirroring = s.oneScreenMirroring;\n    this.prgSwitchingArea = s.prgSwitchingArea;\n    this.prgSwitchingSize = s.prgSwitchingSize;\n    this.vromSwitchingSize = s.vromSwitchingSize;\n    this.romSelectionReg0 = s.romSelectionReg0;\n    this.romSelectionReg1 = s.romSelectionReg1;\n    this.romBankSelect = s.romBankSelect;\n    this.regBuffer = s.regBuffer;\n    this.regBufferCounter = s.regBufferCounter;\n};\n\nMappers[2] = function(nes) {\n    this.nes = nes;\n};\n\nMappers[2].prototype = new Mappers[0]();\n\nMappers[2].prototype.write = function(address, value) {\n    // Writes to addresses other than MMC registers are handled by NoMapper.\n    if (address < 0x8000) {\n        Mappers[0].prototype.write.apply(this, arguments);\n        return;\n    }\n\n    else {\n        // This is a ROM bank select command.\n        // Swap in the given ROM bank at 0x8000:\n        this.loadRomBank(value, 0x8000);\n    }\n};\n\nMappers[2].prototype.loadROM = function(rom) {\n    if (!this.nes.rom.valid) {\n        alert(\"UNROM: Invalid ROM! Unable to load.\");\n        return;\n    }\n\n    // Load PRG-ROM:\n    this.loadRomBank(0, 0x8000);\n    this.loadRomBank(this.nes.rom.romCount - 1, 0xC000);\n\n    // Load CHR-ROM:\n    this.loadCHRROM();\n\n    // Do Reset-Interrupt:\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\n\nMappers[4] = function(nes) {\n    this.nes = nes;\n\n    this.CMD_SEL_2_1K_VROM_0000 = 0;\n    this.CMD_SEL_2_1K_VROM_0800 = 1;\n    this.CMD_SEL_1K_VROM_1000 = 2;\n    this.CMD_SEL_1K_VROM_1400 = 3;\n    this.CMD_SEL_1K_VROM_1800 = 4;\n    this.CMD_SEL_1K_VROM_1C00 = 5;\n    this.CMD_SEL_ROM_PAGE1 = 6;\n    this.CMD_SEL_ROM_PAGE2 = 7;\n\n    this.command = null;\n    this.prgAddressSelect = null;\n    this.chrAddressSelect = null;\n    this.pageNumber = null;\n    this.irqCounter = null;\n    this.irqLatchValue = null;\n    this.irqEnable = null;\n    this.prgAddressChanged = false;\n};\n\nMappers[4].prototype = new Mappers[0]();\n\nMappers[4].prototype.write = function(address, value) {\n    // Writes to addresses other than MMC registers are handled by NoMapper.\n    if (address < 0x8000) {\n        Mappers[0].prototype.write.apply(this, arguments);\n        return;\n    }\n\n    switch (address) {\n        case 0x8000:\n            // Command/Address Select register\n            this.command = value & 7;\n            var tmp = (value >> 6) & 1;\n            if (tmp != this.prgAddressSelect) {\n                this.prgAddressChanged = true;\n            }\n            this.prgAddressSelect = tmp;\n            this.chrAddressSelect = (value >> 7) & 1;\n            break;\n\n        case 0x8001:\n            // Page number for command\n            this.executeCommand(this.command, value);\n            break;\n\n        case 0xA000:\n            // Mirroring select\n            if ((value & 1) !== 0) {\n                this.nes.ppu.setMirroring(\n                    this.nes.rom.HORIZONTAL_MIRRORING\n                );\n            }\n            else {\n                this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n            }\n            break;\n\n        case 0xA001:\n            // SaveRAM Toggle\n            // TODO\n            //nes.getRom().setSaveState((value&1)!=0);\n            break;\n\n        case 0xC000:\n            // IRQ Counter register\n            this.irqCounter = value;\n            //nes.ppu.mapperIrqCounter = 0;\n            break;\n\n        case 0xC001:\n            // IRQ Latch register\n            this.irqLatchValue = value;\n            break;\n\n        case 0xE000:\n            // IRQ Control Reg 0 (disable)\n            //irqCounter = irqLatchValue;\n            this.irqEnable = 0;\n            break;\n\n        case 0xE001:\n            // IRQ Control Reg 1 (enable)\n            this.irqEnable = 1;\n            break;\n\n        default:\n            // Not a MMC3 register.\n            // The game has probably crashed,\n            // since it tries to write to ROM..\n            // IGNORE.\n    }\n};\n\nMappers[4].prototype.executeCommand = function(cmd, arg) {\n    switch (cmd) {\n        case this.CMD_SEL_2_1K_VROM_0000:\n            // Select 2 1KB VROM pages at 0x0000:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x0000);\n                this.load1kVromBank(arg + 1, 0x0400);\n            }\n            else {\n                this.load1kVromBank(arg, 0x1000);\n                this.load1kVromBank(arg + 1, 0x1400);\n            }\n            break;\n\n        case this.CMD_SEL_2_1K_VROM_0800:\n            // Select 2 1KB VROM pages at 0x0800:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x0800);\n                this.load1kVromBank(arg + 1, 0x0C00);\n            }\n            else {\n                this.load1kVromBank(arg, 0x1800);\n                this.load1kVromBank(arg + 1, 0x1C00);\n            }\n            break;\n\n        case this.CMD_SEL_1K_VROM_1000:\n            // Select 1K VROM Page at 0x1000:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x1000);\n            }\n            else {\n                this.load1kVromBank(arg, 0x0000);\n            }\n            break;\n\n        case this.CMD_SEL_1K_VROM_1400:\n            // Select 1K VROM Page at 0x1400:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x1400);\n            }\n            else {\n                this.load1kVromBank(arg, 0x0400);\n            }\n            break;\n\n        case this.CMD_SEL_1K_VROM_1800:\n            // Select 1K VROM Page at 0x1800:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x1800);\n            }\n            else {\n                this.load1kVromBank(arg, 0x0800);\n            }\n            break;\n\n        case this.CMD_SEL_1K_VROM_1C00:\n            // Select 1K VROM Page at 0x1C00:\n            if (this.chrAddressSelect === 0) {\n                this.load1kVromBank(arg, 0x1C00);\n            }else {\n                this.load1kVromBank(arg, 0x0C00);\n            }\n            break;\n\n        case this.CMD_SEL_ROM_PAGE1:\n            if (this.prgAddressChanged) {\n                // Load the two hardwired banks:\n                if (this.prgAddressSelect === 0) {\n                    this.load8kRomBank(\n                        ((this.nes.rom.romCount - 1) * 2),\n                        0xC000\n                    );\n                }\n                else {\n                    this.load8kRomBank(\n                        ((this.nes.rom.romCount - 1) * 2),\n                        0x8000\n                    );\n                }\n                this.prgAddressChanged = false;\n            }\n\n            // Select first switchable ROM page:\n            if (this.prgAddressSelect === 0) {\n                this.load8kRomBank(arg, 0x8000);\n            }\n            else {\n                this.load8kRomBank(arg, 0xC000);\n            }\n            break;\n\n        case this.CMD_SEL_ROM_PAGE2:\n            // Select second switchable ROM page:\n            this.load8kRomBank(arg, 0xA000);\n\n            // hardwire appropriate bank:\n            if (this.prgAddressChanged) {\n                // Load the two hardwired banks:\n                if (this.prgAddressSelect === 0) {\n                    this.load8kRomBank(\n                        ((this.nes.rom.romCount - 1) * 2),\n                        0xC000\n                    );\n                }\n                else {\n                    this.load8kRomBank(\n                        ((this.nes.rom.romCount - 1) * 2),\n                        0x8000\n                    );\n                }\n                this.prgAddressChanged = false;\n            }\n    }\n};\n\nMappers[4].prototype.loadROM = function(rom) {\n    if (!this.nes.rom.valid) {\n        alert(\"MMC3: Invalid ROM! Unable to load.\");\n        return;\n    }\n\n    // Load hardwired PRG banks (0xC000 and 0xE000):\n    this.load8kRomBank(((this.nes.rom.romCount - 1) * 2), 0xC000);\n    this.load8kRomBank(((this.nes.rom.romCount - 1) * 2) + 1, 0xE000);\n\n    // Load swappable PRG banks (0x8000 and 0xA000):\n    this.load8kRomBank(0, 0x8000);\n    this.load8kRomBank(1, 0xA000);\n\n    // Load CHR-ROM:\n    this.loadCHRROM();\n\n    // Load Battery RAM (if present):\n    this.loadBatteryRam();\n\n    // Do Reset-Interrupt:\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\nMappers[4].prototype.clockIrqCounter = function() {\n    if (this.irqEnable == 1) {\n        this.irqCounter--;\n        if (this.irqCounter < 0) {\n            // Trigger IRQ:\n            //nes.getCpu().doIrq();\n            this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n            this.irqCounter = this.irqLatchValue;\n        }\n    }\n};\n\nMappers[4].prototype.toJSON = function() {\n    var s = Mappers[0].prototype.toJSON.apply(this);\n    s.command = this.command;\n    s.prgAddressSelect = this.prgAddressSelect;\n    s.chrAddressSelect = this.chrAddressSelect;\n    s.pageNumber = this.pageNumber;\n    s.irqCounter = this.irqCounter;\n    s.irqLatchValue = this.irqLatchValue;\n    s.irqEnable = this.irqEnable;\n    s.prgAddressChanged = this.prgAddressChanged;\n    return s;\n};\n\nMappers[4].prototype.fromJSON = function(s) {\n    Mappers[0].prototype.fromJSON.apply(this, s);\n    this.command = s.command;\n    this.prgAddressSelect = s.prgAddressSelect;\n    this.chrAddressSelect = s.chrAddressSelect;\n    this.pageNumber = s.pageNumber;\n    this.irqCounter = s.irqCounter;\n    this.irqLatchValue = s.irqLatchValue;\n    this.irqEnable = s.irqEnable;\n    this.prgAddressChanged = s.prgAddressChanged;\n};\n\nexport default Mappers;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/mappers.js\n **/","'use strict';\n\nlet defaultConfig = {\n  player_one: {\n    type: 'keyboard',\n    mapping: {\n      A: 88,\n      B: 90,\n      SELECT: 17,\n      START: 13,\n      UP: 38,\n      DOWN: 40,\n      LEFT: 37,\n      RIGHT: 39\n    }\n  },\n  player_two: {\n    type: 'keyboard',\n    mapping: {\n      A: 103,\n      B: 105,\n      SELECT: 99,\n      START: 97,\n      UP: 104,\n      DOWN: 98,\n      LEFT: 100,\n      RIGHT: 102\n    }\n  }\n}\n\nconst Controllers = function(config = defaultConfig) {\n\n    this.config = config;\n    this.buttons = {\n        A: 0,\n        B: 1,\n        SELECT: 2,\n        START: 3,\n        UP: 4,\n        DOWN: 5,\n        LEFT: 6,\n        RIGHT: 7\n    };\n\n    this.state1 = new Array(8);\n    for (let i = 0; i < this.state1.length; i++) {\n        this.state1[i] = 0x40;\n    }\n    this.state2 = new Array(8);\n    for (let i = 0; i < this.state2.length; i++) {\n        this.state2[i] = 0x40;\n    }\n};\n\nControllers.prototype = {\n    setButton: function(button, value) {\n        switch (button) {\n            case (this.config.player_one.mapping.A): this.state1[this.buttons.A] = value; break;      // X\n            case (this.config.player_one.mapping.B): this.state1[this.buttons.B] = value; break;      // Z\n            case (this.config.player_one.mapping.SELECT): this.state1[this.buttons.SELECT] = value; break; // Right Ctrl\n            case (this.config.player_one.mapping.START): this.state1[this.buttons.START] = value; break;  // Enter\n            case (this.config.player_one.mapping.UP): this.state1[this.buttons.UP] = value; break;     // Up\n            case (this.config.player_one.mapping.DOWN): this.state1[this.buttons.DOWN] = value; break;   // Down\n            case (this.config.player_one.mapping.LEFT): this.state1[this.buttons.LEFT] = value; break;   // Left\n            case (this.config.player_one.mapping.RIGHT): this.state1[this.buttons.RIGHT] = value; break;  // Right\n\n            case (this.config.player_two.mapping.A): this.state2[this.buttons.A] = value; break;     // Num-7\n            case (this.config.player_two.mapping.B): this.state2[this.buttons.B] = value; break;     // Num-9\n            case (this.config.player_two.mapping.SELECT): this.state2[this.buttons.SELECT] = value; break; // Num-3\n            case (this.config.player_two.mapping.START): this.state2[this.buttons.START] = value; break;  // Num-1\n            case (this.config.player_two.mapping.UP): this.state2[this.buttons.UP] = value; break;    // Num-8\n            case (this.config.player_two.mapping.DOWN): this.state2[this.buttons.DOWN] = value; break;   // Num-2\n            case (this.config.player_two.mapping.LEFT): this.state2[this.buttons.LEFT] = value; break;  // Num-4\n            case (this.config.player_two.mapping.RIGHT): this.state2[this.buttons.RIGHT] = value; break; // Num-6\n            default: return true;\n        }\n        return false; // preventDefault\n    },\n\n    buttonDown: function(evt, type) {\n        let buttonPressed = (type === 'keyboard') ? evt.keyCode : evt.detail.value;\n        //evt.keyCode\n        if (!this.setButton(buttonPressed, 0x41) && evt.preventDefault) {\n            evt.preventDefault();\n        }\n    },\n\n    buttonUp: function(evt, type) {\n        let buttonPressed = (type === 'keyboard') ? evt.keyCode : false;\n        if (!this.setButton(buttonPressed, 0x40) && evt.preventDefault) {\n            evt.preventDefault();\n        }\n    },\n\n    buttonPress: function(evt, type) {\n        evt.preventDefault();\n    }\n};\n\nControllers.prototype.configureButton = function(player = 'player_one', type = 'keyboard', button = null, setButton = 'A') {\n  this.config[player].mapping[setButton] = button;\n  console.log('mapping button');\n  this.config([player].mapping);\n  return this;\n}\n\nControllers.prototype.configureAllButtons = function(player = 'player_one', type = 'keyboard', mapping) {\n\n}\n\nexport default Controllers;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/controllers.js\n **/","'use strict';\n\n/*\n* Gamepad Axis\n* Axis 1\n*  -1 UP\n*  1 DOWN\n* Axis 2\n*  -1 LEFT\n*  1 RIGHT\n*/\n\nconst Gamepad = function() {\n  return this;\n};\n\nGamepad.prototype.gamepads = [];\nGamepad.prototype.gamepadPoll = false;\nGamepad.prototype.buttonPressedEvent = new CustomEvent('buttonpressed', {detail: null});\n\nGamepad.prototype.checkPads = function() {\n  console.log(Gamepad.prototype.gamepads);\n};\n\nGamepad.prototype.gamepadHandler = function(event, connecting) {\n  let gamepad = event.gamepad;\n \n  if(gamepad) {\n    if(connecting) {\n      console.log(this);\n      Gamepad.prototype.gamepads[gamepad.index] = gamepad;\n    } else {\n      delete Gamepad.prototype.gamepads[gamepad.index];\n    }\n  }\n};\n\nGamepad.prototype.isButtonPressed = function(btn) {\n  if(typeof btn == 'object'){\n    return btn.pressed;\n  }\n\n  return btn == 1.0;\n};\n\nGamepad.prototype.gamepadListener = function() {\n  var gamepads = navigator.getGamepadss ? navigator.getGamepadss() : (navigator.webkitGetGamepadss ? navigator.webkitGetGamepadss : []);\n  var gp = gamepads[0];\n  if(!gamepads) {\n    return;\n  }\n\n  Gamepad.prototype.gamepads.forEach(function(pad) {\n    var gamepad = navigator.getGamepads()[pad.index];\n\n    for(var i = 0, len = gamepad.buttons.length; i < len; i++) {\n      if(Gamepad.prototype.isButtonPressed(gamepad.buttons[i])) {\n        //trigger press event\n        var buttonPressed = new CustomEvent('buttonpressed', {detail: {id: i, value: gamepad.buttons[i], type: 'button', message: 'button pressed'}});\n        window.dispatchEvent(buttonPressed);\n      }\n    }\n\n    for(var j = 0, l = gamepad.axes.length; j < l; j++) {\n      if(gamepad.axes[j] !== 0) { \n        var buttonPressed = new CustomEvent('buttonpressed', {detail: {id: j, value: gamepad.axes[j], type: 'axis', message: 'direction pressed'}}); \n        window.dispatchEvent(buttonPressed);\n      }\n    }\n  });\n\n  Gamepad.prototype.gamepadPoll = requestAnimationFrame(Gamepad.prototype.gamepadListener);\n};\n\nGamepad.prototype.addButtonPressListener = function() {\n  window.addEventListener('buttonpressed', function(e) {\n    console.log('triggered button press ', e);\n    if(e.detail) {\n      console.log('details: ', e.detail);\n    }\n  }, false);\n};\n\nGamepad.prototype.listenForGamepadConnected = function(context){\n  window.addEventListener('gamepadconnected', function(e) { \n    console.log('initializing gamepad');\n    Gamepad.prototype.gamepadHandler(e, true);\n    console.log('Gamepads connected: ',e);\n    console.log('Gamepads configured: ', context.gamepads);\n    Gamepad.prototype.gamepadListener();\n  }, false);\n};\n\nGamepad.prototype.listenForGamepadDisconnected = function(context) {\n  window.addEventListener('gamepaddisconnected', function(e) {\n    console.log('removing gamepad');\n    Gamepad.prototype.gamepadHandler(e, false);\n    console.log('Gamepads disconnected: ',e);\n    console.log('Gamepads configured: ', context.gamepads);\n    cancelAnimationFrame(Gamepad.prototype.gamepadPoll);\n  }, false);\n};\n\nGamepad.prototype.init = function() {\n  this.listenForGamepadConnected(this);\n  this.listenForGamepadDisconnected(this);\n};\n\nexport default Gamepad;\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/gamepads.js\n **/"],"sourceRoot":""}